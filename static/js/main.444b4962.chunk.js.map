{"version":3,"sources":["service/junior01.js","service/junior02.js","service/junior03.js","service/middle01.js","component/question/index.js","component/question/question.js","component/theme/index.js","component/theme/theme.js","component/stage/stage.js","service/getResource.js","component/stage/index.js","component/app/index.js","component/app/app.js","index.js"],"names":["Junior01","HTML","CSS","JS","Testing","GIT","Junior02","DOM","MobileBROW","DataAndTime","Literatura","React","Junior03","WebpackAndOthers","workWithData","Security","API","GraphQL","Middle01","OOP","FunctionPrg","DataTypesAndStructure","ProjectingPrinciple","AsyncInJS","Generator","IzomorfRender","Question","props","tableValue","allItems","counter","value","map","item","key","Object","keys","console","log","Theme","themes","dataSet","Collapse","getter","getAllJunior01","getAllJunior02","getAllJunior03","getAllMiddle01","getTheme","theme","getQuestion","quetion","header","file","title","className","type","data-toggle","data-target","aria-expanded","aria-controls","id","Stage","App","Component","Animal","this","ReactDOM","render","document","getElementById","isAnimal","obj","prototype","isPrototypeOf"],"mappings":"yNAwceA,EAxcE,CACf,CACEC,KAAM,CACJ,CACE,uSACE,y3EAEJ,CACE,+IACE,23DAEJ,CACE,4JACE,w7IAEJ,CACE,wOACE,ulCAEJ,CACE,iRACE,i/MAEJ,CACE,2bACE,s8IAEJ,CACE,qLACE,u+FAEJ,CACE,iKACE,82CAEJ,CACE,2pBACE,s8EAEJ,CACE,69CACE,sqHAEJ,CACE,g7BACE,0xIAEJ,CACE,kXACE,4rDAEJ,CACE,uYACE,otFAEJ,CACE,0oBACE,wieAEJ,CACE,2TACE,6sIAEJ,CACE,kHACE,w/DAEJ,CACE,6SACE,i9CAEJ,CACE,sZACE,+yFAEJ,CACE,qfACE,soGAIR,CACEC,IAAK,CACH,CACE,mSACE,22IAEJ,CACE,2bACE,qoHAEJ,CACE,qQACE,8uCAEJ,CACE,6DACE,2+BAEJ,CACE,gEACE,ioEAEJ,CACE,iuCACE,uuMAEJ,CACE,mzCACE,k+RAEJ,CACE,2IACE,q0BAEJ,CACE,+WACE,06JAEJ,CACE,q0BACE,8gMAEJ,CACE,oHACE,k6DAEJ,CACE,6tBACE,sqGAEJ,CACE,gmCACE,wtXAEJ,CACE,w2BACE,kvGAEJ,CACE,0kBACE,wgFAEJ,CACE,8yCACE,07LAEJ,CACE,4cACE,otPAEJ,CACE,qfACE,izEAEJ,CACE,qkCACE,q9TAEJ,CACE,+/BACE,8nMAEJ,CACE,i5BACE,+jPAEJ,CACE,oIACE,gwFAEJ,CACE,kUACE,qkSAEJ,CACE,2WACE,21DAEJ,CACE,+VACE,4CAEJ,CACE,mEACE,07FAEJ,CAAE,gHAAgD,IAClD,CACE,kRACE,85JAEJ,CACE,mYACE,8uJAEJ,CACE,0NACE,s9FAIR,CACEC,GAAI,CACF,CACE,mIACE,yQAEJ,CACE,4LACE,6vBAEJ,CACE,0KACE,kgCAEJ,CACE,2NACE,gvDAEJ,CACE,8WACE,oTAEJ,CACE,6mBACE,irEAEJ,CACE,mZACE,wFAEJ,CACE,0EACE,+eAEJ,CACE,iKACE,ujFAEJ,CACE,iRACE,y2BAEJ,CACE,gJACE,iyCAEJ,CACE,8SACE,kqCAEJ,CACE,uXACE,2qFAEJ,CACE,6JACE,6wDAEJ,CACE,wfACE,uuEAEJ,CACE,mbACE,uWAEJ,CACE,6XACE,u3BAEJ,CACE,sWACE,2/BAEJ,CACE,4GACE,4vBAEJ,CACE,yOACE,2HAEJ,CACE,0UACE,muIAEJ,CACE,2bACE,urKAEJ,CACE,+NACE,u4DAEJ,CACE,inBACE,uMAEJ,CACE,kdACE,w6FAEJ,CACE,iQACE,kgFAEJ,CACE,qyBACE,uxNAEJ,CACE,yIACE,omEAEJ,CACE,s0BACE,y4FAEJ,CACE,kWACE,y/CAEJ,CACE,8HACE,83JAEJ,CACE,yKACE,6pGAEJ,CACE,kHACE,usEAEJ,CACE,iXACE,ymEAEJ,CACE,iQACE,0zJAEJ,CACE,sWACE,sgDAEJ,CACE,orBACE,smBAEJ,CACE,qRACE,8TAEJ,CACE,8YACE,mrCAEJ,CACE,khBACE,6sCAEJ,CACE,8kBACE,iHAIR,CACEC,QAAS,CACP,CACE,ybACE,ulGAEJ,CACE,+DACE,ukGAEJ,CACE,yDACE,0zMAEJ,CACE,mTACE,64VAEJ,CACE,8YACE,wuTAEJ,CACE,qQACE,88FAEJ,CACE,mMACE,ywHAEJ,CACE,6NACE,kyEAEJ,CACE,yRACE,ycAEJ,CACE,gRACE,mpDAIR,CACEC,IAAK,CACH,CACE,yDACE,i1FAEJ,CACE,iIACE,o9VAEJ,CACE,+NACE,wsOAEJ,CACE,wlCACE,s4NAEJ,CACE,kHACE,+4HAEJ,CACE,8TACE,k3HAEJ,CACE,8mCACE,6zSAEJ,CACE,qGACE,41DAEJ,CACE,+KACE,29NClJKC,EAhTE,CACf,CACEL,KAAM,CACJ,CACE,ymBACE,0jMAEJ,CACE,q6BACE,KAGJ,CACE,yQACE,grDAEJ,CACE,qLACE,i9KAEJ,CACE,gOACE,2jbAEJ,CACE,yhCACE,m4PAIR,CACEC,IAAK,CACH,CACE,mGACE,k7EAEJ,CACE,oJACE,usFAEJ,CACE,6ZACE,8oKAIR,CACEC,GAAI,CACF,CACE,8WACE,ujKAEJ,CACE,2UACE,wpLAEJ,CACE,8VACE,y7RAEJ,CACE,0XACE,o1LAEJ,CACE,ySACE,+uFAEJ,CACE,0OACE,03JAEJ,CACE,8XACE,sBAEJ,CACE,kaACE,ooEAEJ,CACE,0fACE,smQAEJ,CACE,4WACE,slDAEJ,CACE,iYACE,2pXAEJ,CACE,2YACE,sjBAEJ,CACE,ymBACE,owQAIR,CACEC,QAAS,CACP,CACE,okBACE,IAEJ,CACE,8bACE,IAEJ,CAAE,qPAAmD,IACrD,CAAE,yPAAkD,IACpD,CACE,scACE,IAEJ,CAAE,2TAAkE,IACpE,CAAE,6QAAuD,IACzD,CACE,sXACE,IAEJ,CAAE,iRAAsD,MAG5D,CACEG,IAAK,CACH,CACE,4EACE,w5MAEJ,CACE,yLACE,6/CAEJ,CACE,gXACE,yoCAEJ,CACE,4sCACE,yuYAEJ,CACE,2TACE,ooJAEJ,CACE,4fACE,k5LAEJ,CACE,k5CACE,o4JAEJ,CACE,8uBACE,06UAEJ,CACE,sEACE,8kCAIR,CACEC,WAAY,CACV,CACE,kMACE,++LAEJ,CACE,yPACE,+/7BAEJ,CACE,0fACE,+xJAIR,CACEC,YAAa,CACX,CACE,oQACE,4gKAEJ,CACE,oNACE,m3HAEJ,CACE,sTACE,o6LAEJ,CACE,sWACE,++EAEJ,CACE,+PACE,i7MAEJ,CACE,qNACE,qxEAEJ,CACE,wbACE,otDAEJ,CACE,gVACE,62bAEJ,CACE,+KACE,4xEAIR,CACEC,WAAY,CACV,CACE,ijCACE,MAIR,CACEC,MAAO,CACL,CACE,2DACE,4jCAEJ,CACE,giBACE,glJAEJ,CACE,kkBACE,41HAEJ,CACE,s2CACE,85MAEJ,CACE,mJACE,85KAEJ,CACE,44EACE,+ybAEJ,CACE,mWACE,0pVAEJ,CACE,8rBACE,23SAEJ,CACE,iXACE,y2IAEJ,CACE,qNACE,o4KAEJ,CACE,6QACE,2iCAEJ,CACE,8dACE,mDAEJ,CACE,wmBACE,6vaAEJ,CACE,4nBACE,mzOAEJ,CACE,sMACE,gmLAEJ,CACE,igBACE,yySAEJ,CACE,ktBACE,u/LCiIKC,EA5aE,CACf,CACEC,iBAAkB,CAChB,CACE,0uBACE,87KAEJ,CACE,uSACE,ozJAEJ,CACE,qiBACE,giGAIR,CACEC,aAAc,CACZ,CACE,+OACE,o5cAEJ,CACE,siBACE,i4FAEJ,CACE,2xBACE,04KAEJ,CACE,wVACE,+OAEJ,CACE,8YACE,yqVAEJ,CACE,muBACE,gtOAIR,CACEX,GAAI,CACF,CACE,qLACE,8+KAEJ,CACE,4RACE,u0IAEJ,CACE,uaACE,irXAEJ,CACE,0mBACE,w9KAEJ,CACE,uRACE,o3JAEJ,CACE,gRACE,wsPAEJ,CACE,iOACE,0wXAEJ,CACE,2OACE,40RAEJ,CACE,myBACE,IAEJ,CACE,0NACE,8gHAEJ,CACE,2MACE,soQAEJ,CACE,kMACE,khJAEJ,CACE,0hBACE,igLAEJ,CACE,oqBACE,mwGAEJ,CACE,+UACE,+xEAEJ,CACE,y2CACE,IAEJ,CACE,sJACE,moBAEJ,CACE,meACE,mzCAEJ,CACE,osBACE,47OAEJ,CACE,6JACE,i+DAEJ,CACE,wMACE,qyFAEJ,CACE,oLACE,kgNAEJ,CACE,yRACE,8tIAEJ,CACE,gaACE,MAIR,CACEC,QAAS,CACP,CAAE,uQAAsD,IACxD,CAAE,6OAA0D,IAC5D,CAAE,6DAAsB,IACxB,CACE,uXACE,IAEJ,CACE,6iBACE,IAEJ,CACE,osBACE,IAEJ,CACE,ukBACE,IAEJ,CAAE,kMAAwC,IAC1C,CAAE,2SAAiE,IACnE,CAAE,+RAA0D,IAC5D,CACE,6oBACE,MAIR,CACEC,IAAK,CACH,CACE,qPACE,k5XAEJ,CACE,oHACE,IAEJ,CACE,+4BACE,IAEJ,CACE,ujDACE,IAEJ,CAAE,oFAA8B,IAChC,CACE,+JACE,w3kBAEJ,CACE,8KACE,inVAIR,CACEH,IAAK,CACH,CACE,0OACE,28FAEJ,CACE,gNACE,opGAEJ,CACE,+vCACE,yqUAEJ,CACE,oPACE,qrGAEJ,CACE,8hEACE,6hIAEJ,CACE,8fACE,0rVAGJ,CACE,mSACE,22IAEJ,CACE,6OACE,gwWAEJ,CACE,iOACE,26JAEJ,CACE,sEACE,+qKAEJ,CACE,yNACE,kgcAEJ,CACE,u/BACE,0xVAEJ,CACE,irBACE,4xHAEJ,CACE,kNACE,6nIAEJ,CACE,olBACE,0/QAIR,CACEa,SAAU,CACR,CACE,4SACE,omrBAEJ,CACE,yJACE,2/LAEJ,CACE,ihBACE,kiJAEJ,CACE,iOACE,65FAEJ,CACE,uIACE,o4SAIR,CACER,IAAK,CACH,CACE,8jDACE,irhBAEJ,CACE,2FACE,8igBAEJ,CACE,ySACE,6mSAEJ,CACE,4pBACE,KAGJ,CACE,oWACE,2zMAEJ,CACE,kIACE,kuGAEJ,CACE,mVACE,suDAIR,CACES,IAAK,CACH,CACE,gWACE,qzBAEJ,CACE,WACE,w9VAEJ,CACE,WACE,mlCAEJ,CACE,WACE,ynMAEJ,CACEC,QACE,qqWAIR,CACEP,WAAY,CACV,CAAE,gPAAmD,IACrD,CACE,kVACE,MAIR,CACEC,MAAO,CACL,CACE,muBACE,u/QAEJ,CACE,+tEACE,03QAEJ,CACE,yyBACE,6tMAEJ,CACE,q4BACE,s+EAEJ,CACE,wdACE,k0UAEJ,CACE,2IACE,qxNAEJ,CACE,k/DACE,iiDAEJ,CACE,4mBACE,y0BAEJ,CACE,+lEACE,+ylBAEJ,CACE,q3EACE,60yBAEJ,CACE,spBACE,0vDAEJ,CACE,iSACE,6vdAEJ,CACE,sYACE,yyhBAEJ,CACE,mBACE,wieAEJ,CACE,sBACE,0zDAEJ,CACE,cACE,okGC3CKO,EA5XE,CACf,CACEC,IAAK,CACH,CACE,wEACE,q1BAEJ,CACE,oFACE,0wFAEJ,CACE,0FACE,gwGAEJ,CACE,iJACE,++NAEJ,CACE,geACE,u+DAEJ,CACE,gQACE,86BAEJ,CACE,0qBACE,y63BAEJ,CACE,sOACE,8jlBAEJ,CACE,2PACE,2zsBAEJ,CACE,+TACE,q6CAEJ,CACE,mTACE,u9FAEJ,CACE,opBACE,80zBAEJ,CACE,mTACE,ooiBAIR,CACEC,YAAa,CACX,CACE,iPACE,mjDAEJ,CACE,qQACE,ynGAEJ,CACE,mMACE,2tMAEJ,CACE,wQACE,usGAEJ,CACE,sLACE,miGAEJ,CACE,snBACE,soGAEJ,CACE,ggCACE,whQAEJ,CACE,qdACE,g+eAEJ,CACE,6XACE,y1hBAEJ,CACE,0QACE,gtFAEJ,CACE,idACE,uwOAEJ,CACE,+YACE,ohBAEJ,CACE,q5DACE,2xJAEJ,CACE,qfACE,w8KAEJ,CACE,ouBACE,41GAEJ,CACE,igCACE,k0WAEJ,CACE,iuBACE,k7OAIR,CACEC,sBAAuB,CACrB,CACE,6GACE,yhIAEJ,CACE,gLACE,mrNAEJ,CACE,iJACE,yuCAEJ,CACE,0mBACE,y0KAEJ,CACE,qtBACE,isKAEJ,CACE,6qBACE,o0IAEJ,CACE,+pBACE,61TAEJ,CACE,urBACE,s3HAEJ,CACE,yzBACE,w6MAEJ,CACE,2mBACE,u6JAEJ,CACE,4ZACE,6nNAEJ,CACE,gbACE,ihDAIR,CACEC,oBAAqB,CACnB,CACE,2hBACE,upWAEJ,CACE,wOACE,qnwBAEJ,CACE,4SACE,gzUAEJ,CACE,moCACE,0+aAEJ,CACE,oyEACE,2nfAEJ,CACE,k+FACE,+iWAEJ,CACE,mQACE,+4HAIR,CACEC,UAAW,CACT,CACE,sNACE,igDAEJ,CAAE,+PAAmD,gEACrD,CACE,2NACE,ybAEJ,CACE,gEACE,6rKAEJ,CACE,+DACE,00bAEJ,CACE,6aACE,uzZAEJ,CACE,oPACE,sgBAEJ,CACE,qMACE,qMAEJ,CACE,iEACE,u8NAEJ,CACE,uOACE,sgBAEJ,CACE,kTACE,+tPAEJ,CACE,wdACE,wHAEJ,CACE,gkBACE,82GAEJ,CACE,qQACE,s5PAEJ,CACE,krBACE,2tXAIR,CACEC,UAAW,CACT,CACE,4GACE,m1OAEJ,CACE,yPACE,wsaAEJ,CACE,yOACE,08FAEJ,CACE,8XACE,gqNAEJ,CACE,2PACE,44OAEJ,CACE,sXACE,+xMAEJ,CACE,gJACE,+rJAIR,CACEC,cAAe,CACb,CACE,6RACE,mxeAEJ,CACE,mWACE,g/PAEJ,CACE,86DACE,k8TAEJ,CACE,2mBACE,wgIAEJ,CACE,4RACE,wzGAEJ,CACE,qSACE,m9KAEJ,CACE,2cACE,u7GAIR,CACErB,QAAS,CACP,CACE,ijBACE,IAEJ,CAAE,0PAAwD,IAC1D,CAAE,uQAAgE,IAClE,CACE,4VAAqE,IAEvE,CAAE,oUAAiE,IACnE,CACE,+iBACE,IAEJ,CAAE,iLAA+D,IACjE,CACE,+PACE,IAEJ,CAAE,oMAA8D,IAChE,CACE,oaACE,IAEJ,CACE,ySACE,IAEJ,CACE,2gBACE,IAEJ,CACE,orBACE,OCrXKsB,ECEE,SAACC,GAAW,IACnBC,EAAeD,EAAfC,WAEJC,EAAW,EACXC,EAAU,EAERC,EAAQH,EAAWI,KAAI,SAACC,GAC5B,IAAMC,EAAMC,OAAOC,KAAKH,GAMxB,OALAJ,IACiB,IAAbI,EAAKC,IACPJ,IAIA,6BACE,4BACE,4BACE,4BAAKI,GACL,2BAAID,EAAKC,UAOnB,OADAG,QAAQC,IAAR,wEAA2BT,EAA3B,qHAA2DC,IACpDC,GC3BMQ,ECKD,SAACZ,GACb,IAEMa,EAFQb,EAAMc,UAECT,KAAI,SAACC,GACxB,IAAIC,EAAMC,OAAOC,KAAKH,GACtB,OACE,6BACGS,EAAS,GAAD,OAAIR,GAAO,kBAAC,EAAD,CAAUN,WAAYK,EAAKC,KAAtC,UAAmDA,QAOlE,OAAO,6BAAMM,ICjBTG,EAAS,I,sCCGbC,eAAiB,WACf,OAAO5C,G,KAET6C,eAAiB,WACf,OAAOvC,G,KAETwC,eAAiB,WACf,OAAOlC,G,KAETmC,eAAiB,WACf,OAAO7B,G,KAGT8B,SAAW,SAACC,GACV,OAAOjD,EAASiD,I,KAElBC,YAAc,SAACD,EAAOE,GACpB,OAAOF,EAAME,KDlBXT,EAAW,SAACU,EAAQC,EAAMC,GAC9B,OACE,oCACE,4BACE,4BACEC,UAAU,kBACVC,KAAK,SACLC,cAAY,WACZC,cAAA,WAAiBJ,GACjBK,gBAAc,QACdC,gBAAeN,GAEdF,IAGL,yBAAKG,UAAU,WAAWM,GAAIP,GAC5B,yBAAKC,UAAU,kBAAkBF,MEpB1BS,EF0BD,WACZ,OACE,6BAqBGpB,EACC,WACA,kBAAC,EAAD,CAAOD,QAASE,EAAOC,iBACvB,YAEDF,EACC,WACA,kBAAC,EAAD,CAAOD,QAASE,EAAOE,iBACvB,YAEDH,EACC,WACA,kBAAC,EAAD,CAAOD,QAASE,EAAOG,iBACvB,YAEDJ,EACC,WACA,kBAAC,EAAD,CAAOD,QAASE,EAAOI,iBACvB,cGnEOgB,E,uKCIX,OAAO,kBAAC,EAAD,U,GAFsBC,aCIjC,SAASC,EAAOT,GACdU,KAAKV,KAAOA,EAHdW,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SAKjDL,EAAOM,SAAW,SAAUC,EAAKhB,GAC/B,QAAKS,EAAOQ,UAAUC,cAAcF,MAG7BhB,GAAOgB,EAAIhB,OAASA,K","file":"static/js/main.444b4962.chunk.js","sourcesContent":["const Junior01 = [\r\n  {\r\n    HTML: [\r\n      {\r\n        'HTML5 теги, как сделать верстку семантичной и зачем это нужно?':\r\n          'Семантическая вёрстка, или семантический HTML-код, — это подход к созданию веб-страниц на языке HTML, основанный на использовании HTML-тегов в соответствии с их семантикой (предназначением)[1], а также предполагающий логичную и последовательную иерархию страницы[2][3]. Он противопоставляется подходу, при котором написание HTML-кода определяется внешним видом веб-страницы. Чтобы передавать поисковикам, какая часть страницы является хедером, какая подвалом и какая навигацией <header>, <footer> и тд',\r\n      },\r\n      {\r\n        'Что такое doctype и зачем он нужен?':\r\n          'DOCTYPE (Document Type Definition) в начале HTML страницы указывает на тип документа, который вы будете использовать при написании HTML кода для вашего сайта. Директива doctype необходима, чтобы браузер понимал как обрабатывать текущую веб-страничку, так как существует несколько версий языка HTML, а еще имеется XHTML (EXtensible HyperText Markup Language, расширенный язык разметки гипертекста), который похож на HTML, но различается с ним по синтаксису.',\r\n      },\r\n      {\r\n        'Какие есть отличия у тегов div, p, span, a?':\r\n          'В то время как большинство HTML тегов в полной мере выполняют это предназначение (тег <p> создает параграф, тег <h1> – заголовок и т.д.), тег <span> и тег <div> никакого значения не имеют, что может вызвать некоторые сомнения в необходимости их существования. Однако эти теги используются чрезвычайно активно совместно с технологией CSS. Они используются для того, чтобы группировать области HTML кода и затем подключать к этой группе определенные стили CSS. Это осуществляется при помощи атрибутов class и id, ассоциирующих данные элементы с селекторами класса или идентификатора CSS. Разница между тегом <span> и тегом <div> заключается в том, что элемент <span> является строчным и обычно используется для группирования небольших областей строчного HTML кода, а элемент <div> является блоковым (что, грубо говоря, выражается в наличие перевода строки до и после этого элемента) и используется для группирования более крупных областей кода.',\r\n      },\r\n      {\r\n        'Что такое инлайновые элементы (например, b, i, strong, em)?':\r\n          'Встроенные (строчные) элементы генерируют внутристрочные контейнеры. Они не формируют новые блоки контента. Значения свойства display, такие как inline и inline-table делают элементы строчными. <a>, <area>, <b>, <bdo>, <bdi>, <cite>, <code>, <dfn>, <del>, <em>, <i>, <iframe>, <img>, <ins>, <kbd>, <label>, <map>, <mark>, <s>, <samp>, <small>, <span>, <strong>, <sub>, <sup>, <time>, <q>, <ruby>, <u>, <var>',\r\n      },\r\n      {\r\n        'Как создавать таблицы в html? border-spacing, border-collapse. colspan, rowspan. table-layout. caption. scope. display: table, table-cell, table-row и т.д.':\r\n          'Таблица создаётся при помощи парного тега <table></table>. Данный тег является контейнером для элементов таблицы и все элементы должны находиться внутри него. По умолчанию таблица и ячейки не имеют видимых границ. Границы задаются с помощью свойства border. Промежутки между ячейками таблицы убираются с помощью свойства table {border-collapse: collapse;}. Строки или ряды таблицы создаются с помощью тега <tr>. Количество горизонтальных строк таблицы определяется количеством парных тегов <tr></tr>. Элемент <th> создаёт заголовок столбца — специальную ячейку, текст в которой выделяется полужирным. Количество ячеек заголовка определяется количеством пар тегов <th></th>. Для элемента доступны атрибуты colspan, rowspan, headers. Элемент <caption> создает подпись таблицы. Добавляется непосредственно после тега <table>, вне строки или ячейки. самый распространённый способ использования display: table. С его помощью можно получить истинное выравнивание по вертикали элементов с динамической высотой.Чтобы горизонтально расположить по центру динамический элемент, можно сделать его блочно-строчным (display: inline-block). Затем внешнему контейнеру этого элемента нужно задать свойство text-align: center. Недостаток этого способа состоит в «побочном эффекте» выравнивания текста по центру. Все дочерние элементы внутри контейнера унаследуют свойство text-align: center, которое может переопределить существующие свойства. ',\r\n      },\r\n      {\r\n        'В чем заключаются отличие чекбокса от радио кнопок? Как связать радиокнопки в группу?':\r\n          'CheckBox Элемент CheckBox или флажок предназначен для установки одного из двух значений: отмечен или не отмечен. Чтобы отметить флажок, надо установить у его свойства Checked значение true. Кроме свойства Checked у элемента CheckBox имеется свойство CheckState, которое позволяет задать для флажка одно из трех состояний - Checked (отмечен), Indeterminate (флажок не определен - отмечен, но находится в неактивном состоянии) и Unchecked (не отмечен).Radiobutton На элемент CheckBox похож элемент RadioButton или переключатель. Переключатели располагаются группами, и включение одного переключателя означает отключение всех остальных. Чтобы установить у переключателя включенное состояние, надо присвоить его свойству Checked значение true. Для создания группы переключателей, из которых можно бы было выбирать, надо поместить несколько переключателей в какой-нибудь контейнер, например, в элементы GroupBox или Panel. Переключатели. находящиеся в разных контейнерах, будут относиться к разным группам:',\r\n      },\r\n      {\r\n        'Что такое тег <label> и как с ним работать?':\r\n          'Тег <label> устанавливает связь между определенной меткой, в качестве которой обычно выступает текст, и элементом формы (<input>, <select>, <textarea>). Такая связь необходима, чтобы изменять значения элементов формы при нажатии курсором мыши на текст. Кроме того, с помощью <label> можно устанавливать горячие клавиши на клавиатуре и переходить на активный элемент подобно ссылкам. Существует два способа связывания объекта и метки. Первый заключается в использовании идентификатора id внутри элемента формы и указании его имени в качестве атрибута for тега <label>. При втором способе элемент формы помещается внутрь контейнера <label>.',\r\n      },\r\n      {\r\n        'Что такое БЭМ и в чем его польза?':\r\n          'БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste»',\r\n      },\r\n      {\r\n        'Блок Что такое, когда следует создавать? Может ли блок содержать другие блоки? Почему не стоит задавать внешнюю геометрию блокам?':\r\n          'Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом class. Особенности: Название блока характеризует смысл, Блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование. В CSS по БЭМ также не рекомендуется использовать селекторы по тегам или id. Вложенность: Блоки можно вкладывать друг в друга. Допустима любая вложенность блоков.',\r\n      },\r\n      {\r\n        'Элемент Что такое, когда следует создавать? Может ли элемент содержать другие элементы? Может ли элемент содержать блоки (блок, к которому он относится, или другие блоки)? Можно ли создавать элемент элемента? Может ли элемент использоваться вне блока? Может ли существовать блок без элементов?':\r\n          'Составная часть блока, которая не может использоваться в отрыве от него. Особенности: Название элемента характеризует смысл, а не состояние. Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента. Имя элемента отделяется от имени блока двумя подчеркиваниями (__). Принципы работы с элементами: Вложенность - Элементы можно вкладывать друг в друга, Допустима любая вложенность элементов, Элемент — всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя прописывать иерархию вида block__elem1__elem2.; Принадлежность: Элемент — всегда часть блока и не должен использоваться отдельно от него.; Необязательность: Элемент — необязательный компонент блока. Не у всех блоков должны быть элементы.',\r\n      },\r\n      {\r\n        'Модификатор Что такое, когда следует использовать? Когда следует использовать булевый модификатор, а когда модификатор ключ-значение?Является ли корректным следующий код: <div class=\"button_red\"> Click me </div>':\r\n          'Cущность, определяющая внешний вид, состояние или поведение блока либо элемента. Особенности: Название модификатора характеризует внешний вид, Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_). Булевый - Используют, когда важно только наличие или отсутствие модификатора, а его значение несущественно. Например, «отключен»: disabled. Считается, что при наличии булевого модификатора у сущности его значение равно true. Структура полного имени модификатора соответствует схеме: имя-блока_имя-модификатора; имя-блока__имя-элемента_имя-модификатора. Ключ-значение - Используют, когда важно значение модификатора. Например, «меню с темой оформления islands»: menu_theme_islands. Структура полного имени модификатора соответствует схеме: имя-блока_имя-модификатора_значение-модификатора; имя-блока__имя-элемента_имя-модификатора_значение-модификатора.',\r\n      },\r\n      {\r\n        'Почему в CSS по БЭМ не рекомендуется использовать селекторы по id и по тегам?':\r\n          'Не следует использовать селекторы тэгов (это потенциально может помешать использовать блок/элемент в каком-то нестандартном месте на сайте, т.е. привязывает сущность к контексту); рекомендуется также избегать каскадных селекторов, т.к. получившийся класс сам по себе достаточно точно (специфично) выбирает соответствующий элемент.',\r\n      },\r\n      {\r\n        'Как препроцессоры помогают избежать боли с дублированием названий в коде?':\r\n          'SCSS — \"диалект\" языка SASS. А что такое SASS? SASS это язык похожий на HAML (весьма лаконичный шаблонизатор), но предназначенный для упрощения создания CSS-кода. Проще говоря, SASS это такой язык, код которого специальной ruby-программой транслируется в обычный CSS код. Синтаксис этого языка очень гибок, он учитывает множество мелочей, которые так желанны в CSS. Более того, в нём есть даже логика (@if, each), математика (можно складывать как числа, строки, так и цвета). Возможно, некоторые возможности SCSS покажутся вам избыточными, но, на мой взгляд, лишними они не будут, останутся \"про запас\".',\r\n      },\r\n      {\r\n        'Какие альтернативы есть БЭМ и в чем сила/слабость каждого? Знать хотя бы 2 альтернативы данному подходу, плюсы/минусы подходов.':\r\n          'OOCSS Заложены две основные идеи: Разделение структуры и оформления Разделение контейнера и контента (содержимого). Плюсы: уменьшение количества кода за счет повторного его использования (принцип DRY). Минусы: достаточно сложная поддержка: при изменении стиля конкретного элемента скорее всего придется менять не только CSS (т.к. большинство классов общие), но и добавлять классы в разметку. SMACSS - Основная цель подхода — уменьшение количества кода и на упрощение поддержки кода. разделить стили на 5 частей (в порядке включения их в документ): Base rules — базовые стили. Это стили основных элементов сайта — body, input, button, ul, ol и т.п. В этой секции используются в основном селекторы тэгов и атрибутов, классы — в исключительных случаях (например, если у вас стилизованные JavaScript’ом селекты); Layout rules — стили макета. Здесь находятся стили глобальных элементов размеры шапки, футера, сайдбара и т.п. Джонатан предлагает использовать здесь id в селекторах, так как эти элементы не будут встречаться более 1 раза на странице. Однако автор статьи считает это плохой практикой (каждый раз, когда в стилях появляется id селектор, где-то в мире грустит котенок). Используйте классы и будет вам счастье. Modules rules — стили модулей, то есть блоков, которые могут использоваться несколько раз на одной странице. Для классов модулей не рекомендуется использовать id и селекторы тэгов (для многократного использования и независимости от контекста соответственно). State rules — стили состояния. В этом разделе прописываются различные состояния модулей и скелета сайта. Это единственный раздел, в котором допустимо использование ключевого слова «!important». Theme rules — оформление. Здесь описываются стили оформлений, которые со временем, возможно, нужно будет заменить (так удобно делать, например, новогоднее оформление; для html-тем, выставленных на продажу такие стили позволяют переключать цветовую гамму и т.п.). Atomic CSS, редко также ACSS — атомарный CSS. В некотором роде этот подход представляет собой OOCSS, возведенный в абсолют. Минусы наименования классов представляют собой описательные названия свойств, не описывая семантическую сущность элемента, что иногда может усложнить разработку; настройки отображения элементов переносятся непосредственно в HTML (это не то, для чего были придуманы таблицы стилей, не так ли?).MCSS — многослойный CSS (Multilayer CSS) разделить стили на несколько частей, называемых слоями. Нулевой слой или фундамент — здесь содержится код, отвечающий за сброс стилей браузера (reset.css/normalize.css); Базовый слой — включает в себя стили многократно используемых на сайте элементов: кнопок, полей ввода для текста, подсказок и т.п.; Проектный слой — включает в себя отдельные модули, а также т.н. «контекст» — модификации элементов в зависимости от браузера клиента, устройства, на котором просматривается сайт/приложение, роли пользователя и т.п.; Косметический слой — в этом разделе находится код, написанный в стиле OOCSS, осуществляющий мелкие изменения в внешнем виде элементов. Здесь рекомендуется оставлять только стили, влияющие на внешний вид и не способные поломать верстку сайта — цвета, некоторые некритичные отступы.',\r\n      },\r\n      {\r\n        'Что такое миксы в БЭМе и какие особенности работы с ними есть?':\r\n          'Способ использования разных БЭМ-сущностей на одном DOM-узле. Миксы позволяют: совмещать поведение и стили нескольких БЭМ-сущностей без дублирования кода; создавать семантически новые компоненты интерфейса на основе имеющихся БЭМ-сущностей. Рассмотрим пример микса блока и элемента другого блока. Допустим, в проекте ссылки реализованы блоком link. Необходимо сделать ссылками пункты меню. Существует несколько способов: Создать модификатор для пункта меню, который превратит пункт в ссылку. Но в таком случае для реализации модификатора придется скопировать поведение и стили блока link. Это приведет к дублированию кода. Воспользоваться миксом универсального блока link и элемента link блока menu. Микс двух БЭМ-сущностей позволит применить базовую функциональность ссылок из блока link и дополнительные CSS-правила из блока menu без копирования кода.',\r\n      },\r\n      {\r\n        'Зачем нужны метатеги?':\r\n          'Мета-теги – это HTML-теги, с помощью которых указываются дополнительные данные о странице сайта. Основные функции тега <meta>: передают информацию роботам поисковых систем; служат инструкцией для браузеров, различных сервисов и программного обеспечения; содержат сведения об авторстве, источнике документа. Мета-теги бывают универсальными и поддерживаемыми только какими-то конкретными системами.',\r\n      },\r\n      {\r\n        'Что такое data-атрибуты, и привести примеры, когда они полезны?':\r\n          'Синтаксис прост — любой атрибут, чьё имя начинается с data-, является data-* атрибутом. Вот несколько задач, где это может потребоваться. Создание всплывающих подсказок без применения скриптов. Определение стиля элемента на основе значения атрибута. Получение и изменение значений через скрипты.',\r\n      },\r\n      {\r\n        'Как стилизовать svg? Какие основные атрибуты и CSS-свойства используются для этого?':\r\n          'В SVG заливка и обводка имеют много разных интересных опций, которые предоставляют возможности гораздо шире того, что есть в CSS. Например, можно нарисовать SVG-паттерн и использовать его не только в заливке, но и в обводке. Заливке и обводке можно указывать разную прозрачность, также можно управлять пунктирной обводкой, на чем можно построить интересные анимированные эффекты. В качестве заливки и обводки можно задавать none, цвета, ключевые слова (currentColor и transparent), а также градиенты и паттерны. текст и формы в SVG, как правило, контролируется с помощью атрибутов элементов а не CSS',\r\n      },\r\n      {\r\n        'Что такое специальные html-сущности (неразрывный пробел, тире, которое не дефис) и как с ними работать?':\r\n          'HTML-сущности — это части текста (\"cтроки\"), которые начинаются с символа амперсанда (&) и заканчиваются точкой с запятой (;). Сущности чаще всего используются для представления специальных символов (которые могут быть восприняты как часть HTML-кода) или невидимых символов (таких как неразрывный пробел).Некоторые специальные символы зарезервированы для использования в HTML. Это означает, что браузер может распознать их как часть HTML-кода. Например, если вы используете знак \"меньше\" (<), браузер может воспринять следующий за ним текст как тег. Чтобы такие символы отображались как текст, необходимо заменить их на соответствующие сущности ',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    CSS: [\r\n      {\r\n        'Какие значения бывают у свойства display? В чём их особенность?':\r\n          'none - не показыает элемент, block - Блочные элементы располагаются один над другим, вертикально (если нет особых свойств позиционирования, например float), Блок стремится расшириться на всю доступную ширину. Можно указать ширину и высоту явно. inline - Элементы располагаются на той же строке, последовательно, Ширина и высота элемента определяются по содержимому. Поменять их нельзя. inline-block - Это значение – означает элемент, который продолжает находиться в строке (inline), но при этом может иметь важные свойства блока. table-* Современные браузеры (IE8+) позволяют описывать таблицу любыми элементами, если поставить им соответствующие значения display. flex - удобно располагает дочерние элементы на странице Grid представляет собой пересекающийся набор горизонтальных и вертикальных линий - один набор определяет столбцы, а другой строки. Элементы могут быть помещены в сетку, соответственно строкам и столбцам. ',\r\n      },\r\n      {\r\n        'Что делает свойство margin? Какие есть особенности у отрицательных значений? Что такое margin collapsing?':\r\n          'Свойство margin позволяет задать величину отступа сразу для всех сторон элемента или определить ее только для указанных сторон. Отступы margin-top и margin-bottom иногда объединяются в один, с размером равным наибольшему из них (или размеру одного, если они равны).Это поведение известно как схлопывание внешних отступов (margin collapsing). Отрицательные значения margin-top/margin-left смещают элемент со своего обычного места. В CSS есть другой способ добиться похожего эффекта – а именно, position:relative. Но между ними есть одно принципиальное различие. При сдвиге через margin соседние элементы занимают освободившееся пространство, в отличие от position: relative, при котором элемент визуально сдвигается, но место, где он был, остаётся «занятым».То есть, элемент продолжает полноценно участвовать в потоке.',\r\n      },\r\n      {\r\n        'Что делает свойство vertical-align? Какие у него есть значения?':\r\n          'Свойство vertical-align управляет вертикальным выравниванием элементов внутри своих родителей. Оно применяется к строчным элементам и к ячейкам таблиц. У него десять возможных значений:baseline,sub,super,text-top,text-bottom,middle,top,bottom,указание расстояния,указание процентов. https://htmlacademy.ru/blog/boost/frontend/the-vertical-align-property',\r\n      },\r\n      {\r\n        'Что такое padding?':\r\n          'Устанавливает значение полей вокруг содержимого элемента. Полем называется расстояние от внутреннего края рамки элемента до воображаемого прямоугольника, ограничивающего его содержимое',\r\n      },\r\n      {\r\n        'Что такое box-sizing?':\r\n          'Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border. Аналогично обстоит и с высотой блока. Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height задавали размеры не содержимого, а размеры блока. border-box - Свойства width и height включают в себя значения padding и border, но не margin. content-box - Основывается на стандартах CSS, при этом свойства width и height задают ширину и высоту содержимого и не включают в себя значения margin, padding и border.',\r\n      },\r\n      {\r\n        'Шрифты Как и в каких единицах можно задавать размер шрифта? В чём заключаются отличия у разных семейств шрифтов (с засечками, без них и моноширинные шрифты)? Как они называются на английском? Какие есть особенности подключения шрифтов через font-face?':\r\n          'Размер шрифта в пикселях Наиболее простой и понятный способ задать размер шрифта – использовать единицу измерения px. Вы сами указываете высоту шрифта. Допустим, вам необходим шрифт размером 24 пикселя. Для этого запишите стиль CSS: font-size: 24px; Размер шрифта в процентах Вы наверняка уже сталкивались с ситуацией, когда размер шрифта в CSS не задан, вследствие чего браузеру приходится определять размер шрифта «по своему усмотрению». Если точнее, берется предустановленное значение по умолчанию. Именно от него зависят установленные в процентах значения. Единица измерения em По принципу работы единица измерения em похожа на проценты. Значение 1em эквивалентно 100% и соответствует базовому размеру шрифта по умолчанию. Соответственно, 0.6em = 60%, 3em = 300% и так далее. SS определяет пять базовых семейств шрифтов: Шрифты с засечками — Serif (Times New Roman, Times, Garamond, Georgia) Рубленые шрифты — Sans-serif (Helvetica, Geneva, Arial, Verdana, Trebuchet, Univers) Моноширинные шрифты — Monospace (Courier, Courier New, Andele Mono) Рукописные шрифты — Cursive (Comic Sans, Gabriola, Monotype Corsiva, Author, Zapf Chancery) Аллегорические шрифты (Western, Woodblock, Klingon). Чтобы подключить шрифт с помощью правила @font-face, нужно: 1) загрузить файл шрифта на сервер в нескольких форматах для поддержки всеми браузерами, 2) указать название шрифта, прописать ссылку на файл и задать описание шрифта, 3) добавить имя шрифта в свойство font-family элемента, который будет отображаться данным шрифтом.',\r\n      },\r\n      {\r\n        'Цвета Какие есть способы задать цвет? Как задать прозрачный цвет? Как в другом css-свойстве получить текущий цвет? Какие цветовые модели допустимо использовать в CSS? Какова структура перечисленных вами моделей? Какую роль играет альфа-канал? Как им пользоваться?':\r\n          ' Шестнадцатеричные цвета (hex) Шестнадцатеричная система счисления (hexadecimal, hex) основывается на числе 16. Для записи шестнадцатеричного значения используется 16 символов: арабские цифры от 0 до 9 и первые буквы латинского алфавита (A, B, C, D, E, F). Цвет в шестнадцатеричном формате записывается в виде трех двузначных чисел от 00 до FF (перед ними обязательно ставится символ решетки #), что соответствует трем компонентам: Red, Green, Blue (цветовая модель RGB). Иными словами, запись цвета можно представить как #RRGGBB. Цветовая модель RGB Второй способ указания цвета в CSS – использовать десятичные значения RGB (Red, Blue, Green). Для этого необходимо записать после свойства color ключевое слово rgb, а затем в скобках и через запятую – три числа в диапазоне от 0 до 255, каждое из которых означает интенсивность красного, зеленого и синего цветов (r, g, b). Чем больше число, тем более интенсивен цвет. Цветовая модель RGBA Задать цвет в формате RGBA можно почти так же, как и в RGB. Отличие RGBA от RGB заключается в наличии альфа-канала, который отвечает за прозрачность цвета. Задается прозрачность с помощью числа в диапазоне от 0 до 1, где 0 соответствует полной прозрачности, а 1, наоборот, означает полную непрозрачность. Промежуточные значения вроде 0.5 позволяют задать полупрозрачный вид (допускается сокращенная запись, без нуля, но с точкой – .5). Цветовые модели HSL (HSLA) Задавать цвет в CSS можно также с помощью координат цветовой модели HSL (Hue, Saturation, Lightness – тон, насыщенность, светлота). Записывается это так: p { color: hsl(165, 100%, 50%); } Первое число в скобках означает тон (hue) и задается в градусах (диапазон чисел от 0 до 359). Вам будет легко понять, почему используются именно градусы, если вы вспомните, как выглядит цветовой круг: Второе и третье числа в скобках означают насыщенность (saturation) и светлоту (lightness) соответственно. Их значения устанавливаются в процентах от 0 до 100. Чем ниже значение насыщенности, тем более приглушенным становится цвет. https://html5book.ru/transparency/',\r\n      },\r\n      {\r\n        'Что такое поток документа?':\r\n          'Потоком документа в HTML называется порядок вывода элементов на страницу. В обычном виде все блоки выводятся в том порядке, в котором они записаны внутри HTML документа',\r\n      },\r\n      {\r\n        'Что делает свойство float? Почему родитель элемента с float может схлопываться?':\r\n          'При применении этого свойства происходит следующее: Элемент позиционируется как обычно, а затем вынимается из документа потока и сдвигается влево (для left) или вправо (для right) до того как коснётся либо границы родителя, либо другого элемента с float. Если пространства по горизонтали не хватает для того, чтобы вместить элемент, то он сдвигается вниз до тех пор, пока не начнёт помещаться. Другие непозиционированные блочные элементы без float ведут себя так, как будто элемента с float нет, так как он убран из потока. Строки (inline-элементы), напротив, «знают» о float и обтекают элемент по сторонам. Ещё детали: Элемент при наличии float получает display:block. То есть, указав элементу, у которого display:inline свойство float: left/right, мы автоматически сделаем его блочным. В частности, для него будут работать width/height. Исключением являются некоторые редкие display наподобие inline-table и run-in (см. Relationships between „display“, „position“, and „float“) Ширина float-блока определяется по содержимому. («CSS 2.1, 10.3.5»). Вертикальные отступы margin элементов с float не сливаются с отступами соседей, в отличие от обычных блочных элементов.',\r\n      },\r\n      {\r\n        'Что делает свойство position? Какие элементы называют позиционированными? Относительно чего происходит позиционирование элементов при разных значениях свойства position?':\r\n          'Позволяет установить или изменить положение элемента и содержит четыре возможных значения: static (значение по умолчанию) relative absolute fixed Часто используется наряду с четырьмя свойствами координат: left right top bottom. static Это значение position по умолчанию: статичные элементы просто следуют естественному потоку. Любые значения left, right, top или bottom не оказывают влияния. relative Когда position установлено относительно, элемент может перемещаться относительно его текущей позиции. absolute Когда position устанавливается абсолютно, элемент может перемещаться относительно первого позиционированного предка. Позиционированного? Что такое позиционированный элемент? Позиционированный элемент — это тот, у которого значение position установлено как relative, absolute или fixed. Таким образом, если положение не задано статичным, то элемент позиционированный. Характеристикой позиционированного элемента является то, что он может выступать в качестве точки отсчёта для своих дочерних элементов. fixed Когда position задано как fixed, оно действует как абсолютное: вы можете установить координаты слева/справа и сверху/снизу. Единственное отличие состоит в том, что точкой отсчёта является окно просмотра. Это означает, что фиксированный элемент не перемещается со страницей, он фиксируется на экране.',\r\n      },\r\n      {\r\n        'Что делает свойство z-index?':\r\n          'Свойство z-index определяет положение элемента и нижестоящих элементов по оси z. В случае перекрытия элементов, это значение определяет порядок наложения. В общем случае, элементы с большим z-index перекрывают элементы с меньшим. Для позиционируемого контейнера свойство z-index определяет: порядок наложения в текущем контексте наложения; создаёт ли контейнер локальный контекст наложения.',\r\n      },\r\n      {\r\n        'Контекст наложения Что такое? Как влияет на расположение элементов с заданным значением z-index? Какие свойства создают новый контекст наложения?':\r\n          'Контекст наложения (stacking context) это концепция трехмерного расположения HTML элементов вдоль оси Z по отношению к пользователю, находящемуся перед экраном.  HTML элементы занимают это место по порядку, основанному на атрибутах элемента. Суммируем: Позиционирование и присваивание HTML элементам свойства z-index создает контекст наложения, (так же как и присваивание элементу opacity меньше 1). Контексты наложения могут быть частью других контекстов наложения и вместе создавать иерархию контекстов наложения. Каждый контекст наложения абсолютно независим от своего соседа: только подчиненные элементы учитываются при обработке контекста наложения.',\r\n      },\r\n      {\r\n        'Flex Что такое flexbox? Существует ли инлайновый flexbox? Что такое flex-container и flex-items? Как выравнивать элементы с помощью flexbox? Принципы работы flex-grow, flex-shrink. Каким образом рассчитывается занимаемое и свободное пространство при использовании этих свойств?':\r\n          'Основные преимущества flexbox Все блоки очень легко делаются “резиновым”, что уже следует из названия “flex”. Элементы могут сжиматься и растягиваться по заданным правилам, занимая нужное пространство. Выравнивание по вертикали и горизонтали, базовой линии текста работает шикарно. Расположение элементов в html не имеет решающего значения. Его можно поменять в CSS. Это особенно важно для некоторых аспектов responsive верстки. Элементы могут автоматически выстраиваться в несколько строк/столбцов, занимая все предоставленное место. Множество языков в мире используют написание справа налево rtl (right-to-left), в отличии от привычного нам ltr (left-to-right). Flexbox адаптирован для этого. В нем есть понятие начала и конца, а не права и лева. Т.е. в браузерах с локалью rtl все элементы будут автоматически расположены в реверсном порядке. Синтаксис CSS правил очень прост и осваивается довольно быстро. display: inline-flex контент внутри контейнера был флексовым, но сам контейнер вёл бы себя как инлайновый элемент. CSS flexbox (Flexible Box Layout Module) — модуль макета гибкого контейнера — представляет собой способ компоновки элементов, в основе лежит идея оси. Flexbox состоит из гибкого контейнера (flex container) и гибких элементов (flex items). Гибкие элементы могут выстраиваться в строку или столбик, а оставшееся свободное пространство распределяется между ними различными способами. Модуль flexbox позволяет решать следующие задачи: Располагать элементы в одном из четырех направлений: слева направо, справа налево, сверху вниз или снизу вверх. Переопределять порядок отображения элементов. Автоматически определять размеры элементов таким образом, чтобы они вписывались в доступное пространство. Решать проблему с горизонтальным и вертикальным центрированием. Переносить элементы внутри контейнера, не допуская его переполнения. Создавать колонки одинаковой высоты. Создавать прижатый к низу страницы подвал сайта. flex-shrink — свойство CSS, которое определяет фактор сжатия flex-элемента. Flex-элементы будут заполнять контейнер в зависимости от значения flex-shrink, когда стандартная ширина flex-элементов шире, чем flex-контейнер. flex-shrink используется вместе со свойствами flex flex-grow и flex-basis. Обычно определяется с помощью сокращения flex.  flex-grow берет оставшееся место и делит его на общее количество flex-grow значений. Полученный показатель умножается на соответствующее каждой части значение flex-grow и полученный результат добавляется каждому дочернему элементу с его изначальной шириной. https://tpverstak.ru/flex-cheatsheet/',\r\n      },\r\n      {\r\n        'Рамки Что делают и какие значения могут принимать свойства: border-style, border-color, border-width,  border-radius, border. Можно ли задать стили для каждой рамки отдельно (например, отдельно для левой и для правой рамок)?':\r\n          'Универсальное свойство border позволяет одновременно установить толщину, стиль и цвет границы вокруг элемента. Значения могут идти в любом порядке, разделяясь пробелом, браузер сам определит, какое из них соответствует нужному свойству. Для установки границы только на определенных сторонах элемента, воспользуйтесь свойствами border-top, border-bottom, border-left, border-right. Значение border-width определяет толщину границы. Для управления ее видом предоставляется несколько значений border-style. border-color устанавливает цвет границы, значение может быть в любом допустимом для CSS формате. border-radius Устанавливает радиус скругления уголков рамки. Если рамка не задана, то скругление также происходит и с фоном.',\r\n      },\r\n      {\r\n        'Внешние рамки (outline) В чем отличие от обычных рамок?Что делают и какие значения могут принимать свойства: outline-style,outline-color,outline-width,outline-offset,outline':\r\n          'Свойство outline задаёт дополнительную рамку вокруг элемента, за пределами его CSS-блока. В отличие от border, рамка outline не участвует в блочной модели CSS. Она не занимает места и не меняет размер элемента. Поэтому его используют, когда хотят добавить рамку без изменения других CSS-параметров. Также, в отличие от border, рамку outline можно задать только со всех сторон: свойств outline-top, outline-left не существует.outline-offset, задающее отступ outline от внешней границы элемента. outline-color Задает цвет линии в любом допустимом для CSS формате. outline-style Стиль линии. outline-width Толщина границы.',\r\n      },\r\n      {\r\n        'Тени Что делает свойство text-shadow? Как им пользоваться? Что делает свойство box-shadow? Как им пользоваться? Как сделать так, чтобы у одного элемента было несколько теней? Есть ли возможность задавать параметры теней отдельно (например, задать отдельно цвет или размер тени)?':\r\n          'CSS-свойство text-shadow добавляет тени к тексту. Свойство задаётся разделённым запятыми списком теней, которые будут применены к тексту и к любым его свойствам decorations. Любая тень описывается комбинацией смещений по осям X и Y относительно элемента, радиусом размытия и цветом. Каждая тень определена как два или три значения <длина>, за которыми следует необязательное значение <цвет>. Первые два значения <длина> определяют параметры <смещение-x> и <смещение-y>. Третье необязательное значение <длина> задаёт <радиус-размытия>. Значение <цвет> определяет цвет тени. Если определены больше чем одна тень, тени накладываются друг на друга в порядке обратном порядку их определения, что значит, первая тень окажется поверх последующих. CSS-свойство box-shadow позволяет добавлять элементу одну или несколько теней, указывая их параметры через запятую. Свойство тени представляет собой описанные смещения по x и y от элемента, радиус размытия и его радиус, а также цвет. Свойство box-shadow позволяет вам задать тень для почти любого элемента. Если элементу задано свойство border-radius, то тень также будет с закруглёнными углами. Расположение теней по оси z будет такое же, как и при применении свойства text-shadow (первая тень будет впереди остальных).',\r\n      },\r\n      {\r\n        'Фоны Что делают и какие значения могут принимать свойства:background-image,background-position,background-size,background-repeat,background-origin,background-clip,background-attachment,background-color,background':\r\n          'Сокращенное CSS свойство background  устанаваливает сразу все свойства стиля фона, такие как цвет, изображение, источник и размер, или метод повтора. Свойство CSS  background-image устанавливает одно или несколько фоновых изображений для элемента. Изображения рисуются в слоях контекстов наложения одно поверх другого. Первый слой выводится так, чтобы он был ближе всего к пользователю. CSS свойство background-position устанавливает начальную позицию для каждого фонового изображения. Положение относительно уровня положения, установленного background-origin. Свойство background-repeat устанавливает, как фоновые изображения будет повторяться. Они могут повторяться по горизонтальной и вертикальной оси или не повторяться вовсе. Значение background-size в CSS позволяет задавать размер фонового изображения. Изображение может быть оставлено в исходном размере, растянуто, или подогнано под размеры доступного пространства. CSS-свойство background-color CSS устанавливает цвет фона элемента. Свойство CSS background-clip определяет как цвет фона или фоновое изображение будут выводиться под границами блока. Если фоновое изображение или цвет не заданы, это свойство будет иметь визуальный эффект, только если у границы есть прозрачные области или частично непрозрачные области (из-за border-style или border-image); в противном случае граница скрывает разницу. Если указано background-image, CSS свойство background-attachment определяет, является ли позиция этого изображения фиксированной в области просмотра, или прокручивается вместе с содержащим его блоком. Свойство background-origin определяет область позиционирования фонового рисунка. Это свойство не применяется, когда значение background-attachment задано как fixed.',\r\n      },\r\n      {\r\n        'Градиенты Что делает функция linear-gradient? Как ей пользоваться? Что делает функция radial-gradient? Как ей пользоваться?':\r\n          'CSS-функция linear-gradient() создаёт изображение, состоящее из постепенного перехода между двумя или более цветами вдоль прямой линии. Её результатом является объект типа данных <gradient>, являющийся особым видом <image>. CSS функция radial-gradient() создает картинку состоящую из последовательных переходов между двумя и более цветами, которые исходят из заданного центра. Они могут принимать форму круга или эллипса. Результатом функции будет объект типа <gradient>, который является расширением типа <image>.',\r\n      },\r\n      {\r\n        'Анимации Что такое @keyframes? Зачем нужно? Как им пользоваться? Что делают и какие значения могут принимать свойства: animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, transition, transition-delay,transition-duration,transition-property,transition-timing-function.Можно ли задать несколько анимаций для элемента?':\r\n          'Правило @keyframes устанавливает ключевые кадры при анимации элемента. Ключевой кадр это свойства элемента (прозрачность, цвет, положение и др.), которые должны применяться к элементу в заданный момент времени. Таким образом, анимация представляет собой плавный переход стилевых свойств от одного ключевого кадра к другому. Вычисление промежуточных значений между такими кадрами берёт на себя браузер. @keyframes box { from { left: 0; } to { left: 300px; } } Свойство animation имеет следующие подсвойства: animation-name Определяет имя @keyframes, настраивающего кадры анимации. animation-duration Определяет время, в течение которого должен пройти один цикл анимации. animation-timing-function Настраивает ускорение анимации. animation-delay Настраивает задержку между временем загрузки элемента и временем начала анимации. animation-iteration-count Определяет количество повторений анимации; Вы можете использовать значение infinite для бесконечного повторения анимации. animation-direction Дает возможность при каждом повторе анимации идти по альтернативному пути, либо сбросить все значения и повторить анимацию. animation-fill-mode Настраивает значения, используемые анимацией, до и после исполнения. animation-play-state Позволяет приостановить и возобновить анимацию. Свойство CSS transition - это сокращенное свойство для transition-property, transition-duration, transition-timing-function, и transition-delay. transition-property Указывает имя или имена свойств, чьи переходы должны анимироваться. Только свойства, указанные здесь, анимируются в переходах; изменение других свойств будет происходить обычным образом. transition-duration Определяет время происхождения перехода. Можно указать время анимирования всех свойств перехода сразу или для каждого свойства в отдельности. transition-timing-function Определяет функцию, указывающую, как вычисляются промежуточные значения свойств. Вы также можете выбрать ослабления от функции замедления Шпаргалка.Большинство функций времени может быть определено графиком соответствующей функции, образующей четырьмя точками кривую Безье. transition-delay Определяет как много должно пройти времени, перед тем как начнётся переход. Множественные анимации Для одного элемента можно задавать несколько анимаций, перечислив их названия через запятую',\r\n      },\r\n      {\r\n        'Трансформации Что делает свойство transform? Какие значения ему можно задавать? Можно ли задать несколько трансформаций для элемента? Изменяется ли положение координатной плоскости при трансформациях?':\r\n          'Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать виды трансформаций. Функции трансформации matrix Задаёт матрицу преобразований. rotate Поворот элемента на заданный угол относительно точки трансформации, задаваемой свойством transform-origin. transform: rotate(<угол>) scale Масштаб элемента по горизонтали и вертикали. transform: scale(sx[, sy]); Значение больше 1 увеличивает масштаб элемента, меньше 1 — уменьшает масштаб. scaleX Масштабирует элемент по горизонтали. transform: scaleX(sx); scaleY Масштабирует элемент по вертикали. transform: scaleY(sy); skewX Наклоняет элемент на заданный угол по вертикали. transform: skewX(<угол>) skewY Наклоняет элемент на заданный угол по горизонтали. transform: skewY(<угол>) translate Сдвигает элемент на заданное значение по горизонтали и вертикали. transform: translate(tx[, ty]) translateX Сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо, отрицательное влево. transform: translateX(tx) translateY Сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное вверх. transform: translateY(ty). Можно объединить несколько трансформаций одного элемента, перечислив их через пробел в порядке проявления. Трансформации преобразовывают элемент, не затрагивая остальные элементы веб-страницы, т.е. другие элементы не сдвигаются относительно него.',\r\n      },\r\n      {\r\n        'Единицы измерения Как рассчитываются width и height заданные в процентах?Как рассчитываются padding и margin заданные в процентах? Как рассчитывается line-height заданный в процентах? Как пользоваться vh, vw, vmin, vmax?':\r\n          'При использовании процентной записи высота элемента вычисляется в зависимости от высоты родительского элемента. Если родитель явно не указан, то в его качестве выступает окно браузера. auto устанавливает высоту исходя из содержимого элемента. Как браузеры вычисляют margin и padding для разных единиц измерения Браузеры по-разному вычисляют конечные значения margin и padding в зависимости от единиц измерения. Margin и padding, заданные в процентах, вычисляются относительно ширины контейнера. То есть padding 5% будет равен 5px, если ширина контейнера составляет 100px, или 50px, если ширина контейнера равна 1000px. Не забывайте, что верхнее и нижнее значения вычисляются также по ширине контейнера. line-height - Устанавливает интерлиньяж (межстрочный интервал) текста, отсчет ведется от базовой линии шрифта. При обычных обстоятельствах расстояние между строками зависит от вида и размера шрифта и определяется браузером автоматически. Отрицательное значение межстрочного расстояния не допускается. Любое число больше нуля воспринимается как множитель от размера шрифта текущего текста. Например, значение 1.5 устанавливает полуторный межстрочный интервал. В качестве значений принимаются также любые единицы длины, принятые в CSS — пикселы (px), дюймы (in), пункты (pt) и др. Разрешается использовать процентную запись, в этом случае за 100% берется высота шрифта.vh\tЭквивалентно 1% высоты окна браузера. vw\tЭквивалентно 1% ширины окна браузера. vmin\tЭквивалентно 1% меньшего размера окна браузера по высоте или ширине. vmax\tЭквивалентно 1% большего размера окна браузера по высоте или ширине. ',\r\n      },\r\n      {\r\n        'Как стилизовать чекбокс?':\r\n          'Данный процесс осуществляется посредством скрытия стандартного элемента и создания с помощью CSS другого «поддельного», такого как мы хотим. Но как же это будет работать, если стандартный input скрыть? Это можно выполнить благодаря тому, что в HTML переключить состояние checked можно не только с помощью самого элемента input, но и посредством связанного с ним label. В HTML связывание label с input выполняется одним из 2 способов: 1. Посредством помещения элемента input в label: <label> <input type=\"checkbox\" name=\"happy\" value=\"yes\">Happy </label> 2. Посредством задания элементу input атрибута id, а label – for с таким же значением как у id. <input type=\"checkbox\" id=\"happy\" name=\"happy\" value=\"yes\"> <label for=\"happy\">Happy</label> https://itchief.ru/html-and-css/styling-checkbox-and-radio',\r\n      },\r\n      {\r\n        'Как прижать футер к низу страницы (назвать хотя бы два способа)?':\r\n          ' 1 Отрицательный margin для wrapper Создадим два соседних блока wrapper и footer. Для wrapper зададим нижний минусовый отступ равен высоте футера. Для этого требуется дополнительный элемент внутри wraper (“push”), чтобы гарантировать, что отрицательный margin не подтянет footer и не закроет какой-либо контент. 2 Отрицательный margin для footer Этот метод не требовал использования элемента push, но вместо этого требовался дополнительный элемент обтекания вокруг содержимого, к которому нужно применить соответствующий нижний отступ. Опять же, чтобы избежать отрицательного поля поднять нижний колонтитул над любым содержимым. 3 Задать calc() для content Один из способов не использовать лишние элементы - отрегулировать высоту wrapper с помощью calc (). Тогда не будет никакого перекрытия, просто два элемента сложены друг на друга на общую высоту 100%. Обратите внимание на 70px в calc () и фиксированную высоту футера 50px. Предположим, что последний элемент в content имеет margin-bottom в 20 пикселей. Именно это нижнее поле плюс высоту футера необходимо сложить вместе, чтобы вычесть из высоты области просмотра. И да, мы используем здесь относительные единицы, как еще один маленький трюк, чтобы избежать необходимости устанавливать 100% высоты тела, прежде чем вы сможете установить 100% высоты контента. 4 С помощью flexbox Большая проблема с вышеупомянутыми тремя методами состоит в том, что они требуют футер фиксированной высоты. Фиксированные высоты, как правило, моветон в веб-дизайне. Содержание может измениться. Вещи гибки. Фиксированные высоты обычно являются территорией красного флага. Использование flexbox для футера колонтитула не только не требует дополнительных элементов, но и позволяет использовать футер переменной высоты. 5 С помощью Grid Разметка с помощью сетки еще новее (и менее широко поддерживается), чем flexbox. Вы также можете довольно легко использовать его для прилипания футера к низу страницы.   https://sgeek.pro/blog/coding/2019-05-30-5-sposobov-kak-prizhat-footer-k-nizu-stranicy.html',\r\n      },\r\n      {\r\n        'Как отцентровать элемент по горизонтали (назвать хотя бы три способа)?':\r\n          'Для центрирования инлайновых элементов – достаточно поставить родителю text-align: center. Блок по горизонтали центрируется margin: auto. Применяется display: table-cell, а не настоящая разметка таблицы; позволяет как горизонтальное, так и вертикальное центрирование. Обычно требует добавления и манипулирования второго, внешнего элемента, который может быть чем угодно – от div до самого body.  https://webformyself.com/sem-metodov-centrirovaniya-s-pomoshhyu-css/',\r\n      },\r\n      {\r\n        'Как отцентровать элемент по вертикали (назвать хотя бы три способа)?':\r\n          'https://ruseller.com/lessons.php?id=1248',\r\n      },\r\n      {\r\n        'Что такое media-queries?':\r\n          'Медиазапросы используются в тех случаях , когда нужно применить разные CSS-стили, для разных устройств по типу отображения (например: для принтера, монитора или смартфона), а также конкретных характеристик устройства  (например: ширины окна просмотра браузера), или внешней среды (например: внешнее освещение). Учитывая огромное количество подключаемых к интернету устройств, медиазапросы являются очень важным инструментом при создании веб-сайтов и приложений, которые будут правильно работать на всех доступных устройствах, которые  есть у Ваших пользователей. - например так @media (min-width: 30em) ',\r\n      },\r\n      { 'Чем отличаются responsive, adaptive, liquid?': '' },\r\n      {\r\n        'Какие есть типы селекторов (по тегу, по классу и далее)?':\r\n          '1. Селектор по элементу - Т.е. в качестве селектора использовалось непосредственно имя html элемента , к которому мы хотели применить данный стиль - p{}.2. Селектор по классу Давайте разберем как создать универсальный класс в CSS . А сделать это очень просто: сначала ставим точку, затем сразу, без пробела,пишем имя класса, ну а затем в фигурных скобках стиль. .class{}. 3. Селектор по id. Данный селектор применяется если необходимо выделить один единственный элемент , уникальный,отличный от всех остальных в документе. #firstheader. 4. Контекстный селектор. Это очень полезная вещь. Допустим у нас есть страничка с таблицами и параграфами текста, причем и в таблице, и в параграфах встречаются выделенные жирным шрифтом(strong) слова. И вот, нам резко понадобилось сделать так, чтобы слова, в параграфе, которые выделены жирным стали зеленого цвета. - p strong {color:green } Т.е. в начале P затем пробел, затем STRONG а уже потом стиль. Читается эта строчка примерно так: Если внутри элемента P имеется элемент STRONG то элементу strong присвоить стиль зеленого цвета.',\r\n      },\r\n      {\r\n        'Как работают приоритеты селекторов? Какие есть 4 вида возможных отношений?':\r\n          'Селекторы взвешивают, чтобы узнать какой из стилей будет примененен, когда несколько селекторов так или иначе указывают на один и тот же элемент, и пытаются изменить один и тот же его стиль. Кто больше весит того и стили. Теги. за каждый тег в селекторе можно накинуть в самое правое число единичку: a – это 0,0,0,0,0,0,0,1 div a – это  0,0,0,0,0,0,0,2. Классы, за каждый класс или псевдокласс в селекторе можно накинуть по единичке во второе число справа .head .logo – это  0,0,0,0,0,0,2,0 .logo.big  –    0,0,0,0,0,0,2,0 div:first-child – 0,0,0,0,0,0,1,1 .logog > .big – и это тоже 0,0,0,0,0,0,2,0. За каждый ID в селекторе добавляем по единичке в третье справа число. #head – это  0,0,0,0,0,1,0,0 #head  #logo –  тоже  0,0,0,0,0,2,0,0. Селектор * абсолютно невесомый, то есть совсем. Селектор атрибутов это самый обычный псевдокласс и весит он столько же сколько и обычные классы Любой инлайновый стиль написанный в атрибуте style=”” элемента автоматически получает приоритет0,0,0,0,1,0,0,0, что сразу делает его очень крутым. А следующие четыре цифры это все наши старые знакомые только с атрибутом !important. !important круче всего, даже круче чем инлайн стили ',\r\n      },\r\n      {\r\n        'Что делает CSS-правило * { box-sizing: border-box; }? Зачем оно нужно?':\r\n          'box-sizing Содержание Применяется для изменения алгоритма расчёта ширины и высоты элемента. Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border. Аналогично обстоит и с высотой блока. Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height задавали размеры не содержимого, а размеры блока. content-box Основывается на стандартах CSS, при этом свойства width и height задают ширину и высоту содержимого и не включают в себя значения margin, padding и border. border-box Свойства width и height включают в себя значения padding и border, но не margin. Явное указание border-box может быть полезно: растягивание элемента до ширины родителя.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    JS: [\r\n      {\r\n        'Какие типы данных есть в JS?':\r\n          'JavaScript определяет 7 типов данных: null, undefined, boolean, string, number, object, symbol (добавлен в ES6)',\r\n      },\r\n      {\r\n        'Какие типы в JS изменяемые, а какие нет?':\r\n          'Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением).',\r\n      },\r\n      {\r\n        'Что значит ссылка на переменную?':\r\n          'С объектами – всё не так. В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.Вот как выглядит переменная, которой присвоен объект:',\r\n      },\r\n      {\r\n        'Что такое NaN? Как проверить, что переменная - NaN?':\r\n          'Not a number, функция isNan. Функция isNaN() определяет является ли литерал или переменная нечисловым значением (NaN) или нет. При работе с функцией необходимо проявлять осторожность так как она имеет свои особенности. В качестве альтернативы можно использовать метод Number.isNaN() из ECMAScript 6, или дополнительно проверять литерал или переменную на нечисловое значение при помощи typeof.',\r\n      },\r\n      {\r\n        'Что значит создавать переменную через конструктор или через литерал?':\r\n          '// литеральная нотация: var cat = {name: \"Garfield\"}; // конструктор-функция: var cat = new Object(); cat.name = \"Garfield\";',\r\n      },\r\n      {\r\n        'Когда при обращении к свойству объекта стоит использовать точечную нотацию, а когда через строку в квадратных скобках?':\r\n          ' При обращении к свойствам через точку ключ должен представлять собой действительный JavaScript-идентификатор. obj.message - При попытке обращения к несуществующему свойству объекта сообщения об ошибке не появится, но возвращено будет значение undefined:, При использовании для доступа к свойствам квадратных скобок можно применять ключи, которые не являются действительными JavaScript-идентификаторами (например, ключ может быть строкой, содержащей пробелы).  ',\r\n      },\r\n      {\r\n        'Что произойдет, если попытаться получить несуществующее в объекте свойство?':\r\n          'Будет получен undefined ',\r\n      },\r\n      {\r\n        'Что делает hasOwnProperty?':\r\n          'Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство.',\r\n      },\r\n      {\r\n        'Когда использовать null, а когда undefined?':\r\n          'undefined возвращается, если переменная была объявлена, но значение переменной не было установлено. null - это тип данных в Javascript, который не определяет значение или несуществующее значение. null может рассматриваться как преднамеренное отсутствие значения какого-либо объекта.null вернет \"object. Потому, что тысячи сайтов зависят от такого неправильного поведения, исправление которого приведет к их поломке. null - это назначаемое значение, т.е. должно быть явно назначено программистом. Если переменная не назначена, она становится undefined:',\r\n      },\r\n      {\r\n        'Какие есть способы создания глобальных переменных?':\r\n          'Глобальная переменная - это такая, которая объявлена вне тела какой-либо функции. Все глобальные переменные являются свойствами глобального объекта (в браузере – это window).',\r\n      },\r\n      {\r\n        'Для чего нужна директива use strict?':\r\n          'появился ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: \"use strict\".',\r\n      },\r\n      {\r\n        'Что такое выражения и инструкции? В чем отличия между ними?':\r\n          'Выражением (expression) является любой корректный блок кода, который возвращает значение. Инструкция — это (грубо говоря) команда, действие. if, while, for, const — примеры инструкций. Они производят или контролируют действия, но не превращаются в значения.',\r\n      },\r\n      {\r\n        'Чем отличаются var, let, const? Почему использование const может быть предпочтительнее?':\r\n          'Область видимости var переменных ограничена функцией, если вы обратитесь к переменной до её объявления, то получите undefined. const и let ограничены блоком, а попытка обратится к переменной до её объявления, вернётся ошибкой ReferenceError. И наконец, разница между let и const в том, что в первом случае вы можете изменить значение переменной, а во втором нет.Используя const, вы как бы говорите себе будущему и другим разработчикам, которые будут читать ваш код, что эту переменную изменять не следует. Если вам нужна изменяемая переменная (например, в цикле for), то используйте let.',\r\n      },\r\n      {\r\n        'Что такое тернарный оператор?':\r\n          'Условный (тернарный) оператор - единственный оператор в JavaScript, принимающий три операнда: условие, за которым следует знак вопроса (?), затем выражение, которое выполняется, если условие истинно, сопровождается двоеточием (:), и, наконец, выражение для выполнить, если условие ложно. Он часто используется в качестве укороченного варианта условного оператора if.',\r\n      },\r\n      {\r\n        'Что делает оператор for..in? Какие имеются особенности при использовании этого оператора с массивами?':\r\n          'Цикл по ключам: for (key in obj). Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах). Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.',\r\n      },\r\n      {\r\n        'Как безопасно проверить, что переменная существует (была объявлена), и не словить ReferenceError?':\r\n          '// Проверяют так if (typeof variable !==\"undefined\") { // code } // Можно и так, ибо все глобалы лежат в window if (window.variable !== void 0) { // code }',\r\n      },\r\n      {\r\n        'Способы создания массивов (литерал, конструктор, фабричные методы Array.from() и Array.of());':\r\n          'С помощью литерала массива - const array = []; Через конструктор Array() - const array = new Array(); С помощью метода Array.of()  - const array = Array.of(7); Метод Array.from() создаёт новый экземпляр Array из массивоподобного или итерируемого объекта. const array = Array.from(\"foo\"); ',\r\n      },\r\n      {\r\n        'Удаление элемента из массива (какие есть способы и в чем особенности);':\r\n          'Удаление последнего элемента массива - var last = fruits.pop(); Удаление первого элемента массива - var first = fruits.shift(); Удаление элемента с определённым индексом - var removedItem = fruits.splice(pos, 1); Первые 2 возвращают элемент, последний возвращаетт массив',\r\n      },\r\n      {\r\n        'Свойство length у массива':\r\n          'Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.',\r\n      },\r\n      {\r\n        'Как проверить, что в переменной лежит массив?':\r\n          ' variable.constructor === Array или variable instanceof Array или Array.isArray(variable)',\r\n      },\r\n      {\r\n        'Что делают, как и когда использовать следующие методы: reduce, sort, filter, map, forEach, some, every':\r\n          'Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение - сворачивает массив. Метод sort() на месте сортирует элементы массива и возвращает отсортированный массив. Сортировка не обязательно устойчива (англ.). Порядок cортировки по умолчанию соответствует порядку кодовых точек Unicode. Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.  Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива. Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве (возвращает undefined). Метод some() проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции. Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.',\r\n      },\r\n      {\r\n        'Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой функции?':\r\n          'Вызов метода — Method Invocation - В «вызове метода» значение this будет ссылаться на объект, которому принадлежит функция, в нашем случае на obj, причем данная связь будет установлена после запуска функции, что носит термин позднего привязывания (late binding). Вызов функции — Function Invocation - Используя данный паттерн, this привязывается к global object. Это, несомненно, является ошибкой языка — постоянная привязка this к глобальному объекту может уничтожить его контекст. Это особенно заметно, если использовать функцию внутри метода. Вызов конструктора — Constructor Invocation - Паттерн запускается путем размещения оператора new прямо перед вызовом. Вызов apply и call — Apply And Call Invocation - Он позволяет вручную запустить функцию, попутно снабдив ее параметрами и обозначив this. Из-за того, что функции у нас являются полноправными объектами, каждая функция в JavaScript связана с Function.prototype, а значит мы можем легко добавлять к ним методы. Данный паттерн использует два параметра: первый — это объект, к которому привязывается this, второй — это массив, связанный с параметрами. Стрелочная ф-я имеет this -  это контекст, в котором определена стрелочная функция',\r\n      },\r\n      {\r\n        'Как директива use strict влияет на this внутри функции?':\r\n          'В глобальном контексте выполнения (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий). Не в строгом режиме, и значение this не устанавливается вызовом, по умолчанию будет использоваться объект global, которым в браузере является window. В строгом режиме, если значение this не установлено в контексте выполнения, оно остается undefined',\r\n      },\r\n      {\r\n        'Какой наиболее простой паттерн, позволяющий облегчить читаемость функции, когда у нее огромное количество аргументов?':\r\n          'Каррирование и частичное применение',\r\n      },\r\n      {\r\n        'Как получить все аргументы функции (включая те, что не объявлены, но все-таки были переданы)?':\r\n          'Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив. function sumAll(...args) Полезно запомнить: Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов. С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов. Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно. К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.',\r\n      },\r\n      {\r\n        'Что такое рекурсия? Когда удобно её использовать?':\r\n          'Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач. Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.Полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач.',\r\n      },\r\n      {\r\n        'Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с помощью замыкания, и для чего это состояние может быть использовано?':\r\n          'Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение. 1) Контекст выполнения и 2) Лексическое окружение. Когда выполняется “глобальный” код, он выполняется внутри глобального контекста выполнения, а код функции выполняется внутри контекста выполнения функции. Каждый раз, когда движок JavaScript создаёт контекст выполнения, чтобы выполнить функцию или глобальный код, он также создаёт новое лексическое окружение, чтобы хранить переменную определенную в этой функции во время её выполнения. У лексического окружения есть два компонента: (1) запись в окружении и (2) отсылка к внешнему окружению. Запись в окружении(environment record) это место хранятся объявления переменной или функции. Отсылка к внешнему окружению (reference to the outer environment) означает то, что у него есть доступ к внешнему (родительскому) лексическому окружению. Этот компонент самый важный для понимания того, как работают замыкания. когда функция выполняется, её контекст выполнения удаляется из стека, но её лексическое окружение может или не может быть удалено из памяти, в зависимости от того, ссылается ли на это лексическое окружение другое лексическое окружение.',\r\n      },\r\n      {\r\n        'Как реализовать функцию bind?':\r\n          'Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове. Простейшим способом использования bind() является создание функции, которая, вне зависимости от способа её вызова, вызывается с определённым значением this.',\r\n      },\r\n      {\r\n        'Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так, чтобы при клике на каждую выводился alertом ее порядковый номер. for (var i = 0; i < links.length; i++) { links[i].onclick = function() { alert(i); } }':\r\n          'На деле же оказывается, что при клике на любую ссылку выводится одно и то же число - значение links.length. Почему так происходит? В связи с замыканием объявленная вспомогательная переменная i продолжает существовать, при чем и в тот момент, когда мы кликаем по ссылке. Поскольку к тому времени цикл уже прошел, i остается равным кол-ву ссылок - это значение мы и видим при кликах. for (var i = 0; i < links.length; i++) { (function(i) { links[i].onclick = function() { alert(i); } })(i); } Здесь с помощью еще одного замыкания мы «затеняем» переменную i, создавая ее копию в его локальной области видимости на каждом шаге цикла. Благодаря этому все теперь работает как задумывалось.',\r\n      },\r\n      {\r\n        'Что такое callback (функция обратного вызова)? Когда они обычно применяются?':\r\n          'Функция обратного вызова - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия. Коллбэки позволяют нам быть уверенными в том, что определенный код не начнет исполнение до того момента, пока другой код не завершит исполнение.',\r\n      },\r\n      {\r\n        'Что такое каррирование?':\r\n          'Каррирование – это трансформация, которая превращает вызов f(a, b, c) в f(a)(b)(c). Каррирование или карринг (currying) в функциональном программирование — это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму замыканий, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат. Говоря о каррировании, можно сказать, что это процесс превращения функции с несколькими аргументами в функцию с меньшей арностью. Арность — это количество аргументов функции.',\r\n      },\r\n      {\r\n        'Что такое частичное применение?':\r\n          'Частичное применение— этот термин описывает преобразование функции с несколькими аргументами в функцию, которая принимает меньшее количество аргументов, при этом значения для опущенных аргументов задаются заранее. Этот прием вполне адекватен своему названию: он \"частично применяет\" некоторые аргументы функции, возвращая функцию с сигнатурой, которая состоит из остающихся аргументов. При частичном применении функцию преобразуют в другую функцию, обладающую меньшим числом аргументов (меньшей арностью). Некоторые аргументы такой функции оказываются зафиксированными (для них задаются значения по умолчанию).',\r\n      },\r\n      {\r\n        'Что такое мемоизация?':\r\n          'Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.  Функции, в которых используется мемоизация, обычно работают быстрее, так как при их повторных вызовах с одними и теми же параметрами, они, вместо выполнения неких вычислений, просто считывают результаты из кэша и возвращают их.',\r\n      },\r\n      {\r\n        'Что такое функция-конструктор? Как их создавать и как ими пользоваться?':\r\n          'Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы. Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце. Мы можем использовать конструкторы для создания множества похожих объектов. Функция конструктор - создает пустой объект и определяет его свойста и методы',\r\n      },\r\n      {\r\n        'Что такое прототип? Какие возможности имеет/дает?':\r\n          'В плане наследования JavaScript работает лишь с одной сущностью: объектами. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство prototype равно null.  По определению, null не имеет прототипа и является завершающим звеном в цепочке прототипов. Объекты в JavaScript — динамические \"контейнеры\", наполненные свойствами (называемыми собственными свойствами). Каждый объект содержит ссылку на свой объект-прототип. При попытке получить доступ к какому-либо свойству объекта, свойство вначале ищется в самом объекте, затем в прототипе объекта, после чего в прототипе прототипа, и так далее. Поиск ведется до тех пор, пока не найдено свойство с совпадающим именем или не достигнут конец цепочки прототипов.Другими словами, прототип — это «резервное хранилище свойств и методов» объекта, автоматически используемое при поиске.',\r\n      },\r\n      {\r\n        'Почему методы объекта лучше хранить в прототипе, а не в самом объекте?':\r\n          'Например у вас есть 1000 объектов, у каждого объекта в конструкторе есть метод который делает одно и тоже для каждого объекта. Занимает память? думаю да. Можно в прототип вынести этот метод и метод будет всего один для каждого объекта, а к нему будут вести ссылки. С точки зрения оптимизации так будет лучше.',\r\n      },\r\n      {\r\n        'Можно ли создать инстанс функции через конструктор? И если да, то как, а если нет, то какой бы интерфейс вы реализовали бы для этой задачи?':\r\n          'Нет, нельзя, функции конструкторы создают объекты. new Function(\"x\", \"y\", \"return x+y\")  - получим функцию принимащую 2 аргумента, и возращающую сумму',\r\n      },\r\n      {\r\n        'Как создать объект, который ни от чего не наследуется?':\r\n          'Object.create вы можете создать объект, который не наследует ничего, Object.create(null);',\r\n      },\r\n      {\r\n        'Какие 3 (как минимум) способа есть отнаследоваться в JavaScript-е? В чем отличия и нюансы?':\r\n          'Чаще всего наследование в JavaScript реализуется с помощью функции Object.create(), позволяющий создать новый объект с заданным прототипом. Шаблон конструктор - Object.setPrototypeOf(Dog.prototype, Animal.prototype); Определение класса в ES2015 (ES6) - class Dog extends Animal. Явное объявление прототипа, Object.create, фабричный метод -  prototype: {}',\r\n      },\r\n      {\r\n        'Как в переопределенном методе у наследующего класса вызвать переопределяемый метод родительского?':\r\n          'У классов есть ключевое слово \"super\" для таких случаев. super.method(...) вызывает родительский метод. super(...) вызывает родительский конструктор (работает только внутри нашего конструктора). class Rabbit extends Animal { hide() { alert(`${this.name} прячется!`); } stop() { super.stop(); // вызываем родительский метод stop this.hide(); // и затем hide } }',\r\n      },\r\n      {\r\n        'Какие есть способы навсегда привязать метод класса к его инстансу (чтобы this всегда был текущим экземпляром класса)?':\r\n          'Стрелочная функция????',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Testing: [\r\n      {\r\n        'Что такое автоматизированное тестирование, и в чём отличие от ручного тестирования?':\r\n          'Автоматизированное тестирование предполагает использование специального программного обеспечения (помимо тестируемого) для контроля выполнения тестов и сравнения ожидаемого  фактического результата работы программы. Этот тип тестирования помогает автоматизировать часто повторяющиеся, но необходимые для максимизации тестового покрытия задачи. При ручном подходе тест-кейсы запускаются вручную без использования программных средств. Собственно, это понятно из названия. При автоматизированном тестировании запуск тест-кейсов осуществляется при помощи специально разработанных скриптов.',\r\n      },\r\n      {\r\n        'Что такое unit-test?':\r\n          'Модульное тестирование, или юнит-тестирование (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок. Юнит — это маленький самодостаточный участок кода, реализующий определенное поведение, который часто (но не всегда) является классом.',\r\n      },\r\n      {\r\n        'Что такое TDD?':\r\n          'TDD или Test Driven Development - это разработка через тесты: сначала пишутся интеграционные тесты, в которых детально описан будущий функционал. А новые функции разрабатываются на основе этих тестов. Как это работает Путь любого кода при разработке по TDD проходит 3 стадии: Красная стадия: пишем тесты. Первый прогон тестов будет всегда возвращать ошибку, потому что интерфейс, который они проверяют, не готов. Каждый тест должен переживать в своей жизни хоть одно падение. Как минимум, сразу после написания. Как говорят адепты TDD: «Я не могу доверять тесту, который никогда не видел упавшим». Упавший тест обратит на себя внимание, и вы задумаетесь о правильности реализации функционала или самого теста. Зеленая стадия: разрабатываем функционал и заново проверяем. Наша задача - добиться того, чтобы тест стал зеленым. Так мы понимаем, что функционал разработан верно. Важно, чтобы тест минимум один раз упал и минимум один раз прошёл. Легко ошибиться и написать тест, который всегда падает или всегда проходит. А вот тест, который и падал и проходил, явно проверяет какую-то логику. После этого можно считать, что функционал работает верно. Рефакторинг. Рефакторим конкретную задачу, потому что уже уверены, что у нас рабочий код теста. Просто пишем логичный и чистый код для нашего проекта.',\r\n      },\r\n      {\r\n        'В чем преимущество TDD? Зачем писать сначала тесты, а потом код?':\r\n          'Работая по TDD, вы: Получаете наиболее полные тесты. С помощью Devel::Cover я выяснил, что степень покрытия тестами кода, написанного по TDD (96.5% строк кода было выполнено хотя бы один раз), существенно превышает степень покрытия кода, тесты для которого писались в конце разработки (70.4% строк кода). Сразу выявляете большую часть ошибок. Откладывая поиск и исправление ошибок на потом, вы существенно рискуете сорвать сроки. Вам кажется, что разработка идет полным ходом и на исправление ошибок понадобится несколько дней. Горький опыт показывает, что эти ожидания никогда не оправдываются. Не боитесь делать рефакторинг. В любой момент времени весь код покрыт тестами. Если в результате рефакторинга что-то отвалится, вы сразу узнаете об этом и либо устраните проблему, либо сделаете git reset. Вы ничем не рискуете. Быстро выявляете проблемы при деплое. Недавно я выкатывал в бой один сайтик, написанный на Perl. Его разработка велась под FreeBSD, но боевой сервер работал под CentOS. В результате прогона тестов на боевом сервере выяснилось, что модуль File::fgets работает не совсем так, как ожидалось. Я потратил минут пять на переписывание кода так, чтобы он не использовал этот модуль. Если бы у меня не было тестов, проблема выявилась бы только через несколько дней. Страшно подумать, сколько времени мне понадобилось бы на ее устранение! Получаете более продуманный код. Я имел дело как с «обычными» проектами, так и с проектами, написанными по TDD. В первом случае код часто напоминает спагетти и даже непонятно, как написать для него тесты. Во втором случае код намного более структурирован, классы делают простые вещи и имеют понятный интерфейс, их легко использовать повторно. Имеете документацию в виде тестов. Обычно программисты не очень любят писать документацию, зато с написанием кода проблем не возникает. Модульные тесты представляют собой замечательно описание интерфейсов классов и примеры их использования. И не только! Решили собрать проект другим компилятором (или, например, перейти с Python 2 на Python 3)? Прогоняем тесты и смотрим, какие участки кода перестали работать. Добрый человек прислал вам pull request? Мерджим, прогоняем тесты и тут же узнаем — сломалось что-нибудь или нет. В общем, применений у автоматических тестов уйма.',\r\n      },\r\n      {\r\n        'Что такое регрессионные баги и как автоматические тесты помогают их решать?':\r\n          'Регрессионное тестирование - это исследование, испытание программного обеспечения (иными словами, тестирование), направленное на обнаружение ошибок в уже проверенных участках программ (или исходных кодах). Производится, чтобы исправить регрессионные ошибки (баги, которые появляются не во время написания программы, а при добавлении новых участков кода или исправлении допущенных ранее промахов в синтаксисе кода). Регрессионные ошибки- это когда после внесения изменений в программу перестаёт работать то, что должно было продолжать работать. Цель регрессионного тестирования – убедиться в том, что Regression-testing.jpgисправлении существующих проблем не привело к новым ошибкам в уже проверенных участках кода программы. Как правило, для регрессионного тестирования используются тестовые случаи, написанные на ранних стадиях разработки и тестирования. Тестовый случай-это набор условий, при которых тестировщик будет определять, удовлетворяется ли заранее определённое требование. Понятие \"Регрессионное тестирование\", в зависимости от контекста использования может иметь разный смысл. Основные типы: регрессия багов, регрессия старых багов, регрессия побочного эффекта. Регрессия багов (англ. Bug regression) - попытка доказать, что исправленная ошибка на самом деле не была исправлена. Регрессия старых багов (англ. Old bugs regression) - попытка доказать, что недавнее изменение кода или данных сломало исправление старых ошибок, то есть старые баги стали снова воспроизводиться. Регрессия побочного эффекта (англ. Side effect regression) - попытка доказать, что недавнее изменение кода или данных сломало другие части разрабатываемого приложения. Хотя регрессионное тестирование может быть выполнено вручную, зачастую это делается с помощью специализированных программ, позволяющих выполнять все регрессионные тесты автоматически. В некоторых проектах используются инструменты для автоматического прогона регрессионных тестов через заданный интервал времени.',\r\n      },\r\n      {\r\n        'Почему сайд-эффекты ухудшают тестируемость кода?':\r\n          'Код с сайд-эффектами сложен для анализа (как человеком, так и машиной). Так как функции с сайд-эффектами зависят от внешнего мира и влияют на него неявно, то, соотвественно, чтобы корректно протестировать такую функцию, необходимо: полностью смоделировать весь окружающий мир (сетевые запросы, состояние DOM, состояние файловой системы) в виде некоторого значения до вызова функции; вызвать функцию; проверить состояние значения, моделирующего весь внешний мир. Очевидно, что сделать это полностью корректно, скорее всего, невозможно, так как количество типов сайд-эффектов в JS не ограничено.',\r\n      },\r\n      {\r\n        'Что такое mock и когда их стоит применять?':\r\n          'В случае Mock-объекта, единственное, что будут делать все методы такого объекта, если не определять их поведение, – возвращать значения по-умолчанию: void, default-ы для примитивов, пустые коллекции и null для всех остальных объектов. Mocks Используйте Mock для: проверки контракта между тестируемым кодом и зависимостями проверки того, что методы зависимостей вызываются корректное число раз проверки корректности параметров, с которыми вызывается код зависимостей.Если мы хотим протестировать логику самого объекта и при этом не хотим внедрять какие-либо реальные сервисы и компоненты, то в данном случае стоит использовать вместо них Mock-объекты. В случае, если мы хотим протестировать всё вместе, за исключением каких-то специфических случаев, то стоит использовать Spy.',\r\n      },\r\n      {\r\n        'Что такое шпион и когда их стоит применять?':\r\n          'В случае Spy-объекта, по-умолчанию будет исполняться оригинальное поведение методов объекта. Используйте Spy для: тестирования легаси кода, который невозможно протестировать другими методами проверки того, что методы зависимостей вызываются корректное число раз проверки корректности передаваемых параметров предоставления предопределённого ответа от зависимостей выполнения предопределённых действий в ответ на вызовы методов зависимостей',\r\n      },\r\n      {\r\n        'Стоит ли тестировать приватные методы класса? Почему?':\r\n          'Нет, если в приватных методах скрыты ажные функции,то это повод к созданию нового класса',\r\n      },\r\n      {\r\n        'Зачем группировать отдельные тесты внутри unit-тестов?':\r\n          'Функция describe() объединяет в себе группу взаимосвязанных тестов. Первым параметром она принимает текстовое описание группы, вторым - функцию, которая содержит конфигурацию и набор тестов. Общепринято объединять в группу тесты, относящиеся к одному компоненту, сервису и т. д., а саму группу называть именем компонента, сервиса и т. д.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    GIT: [\r\n      {\r\n        'Что такое Git?':\r\n          'Git (произносится «гит»[8]) — распределённая система управления версиями. Подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.',\r\n      },\r\n      {\r\n        'В чём разница между Git, GitHub и GitLab?':\r\n          'GitHub — сервис онлайн-хостинга репозиториев, обладающий всеми функциями распределённого контроля версий и функциональностью управления исходным кодом — всё, что поддерживает Git и даже больше. Обычно он используется вместе с Git и даёт разработчикам возможность сохранять их код онлайн, а затем взаимодействовать с другими разработчиками в разных проектах. Также GitHub может похвастаться контролем доступа, багтрекингом, управлением задачами и вики для каждого проекта. Цель GitHub — содействовать взаимодействию разработчиков. GitHub — это «социальная сеть для разработчиков». Участникам, кроме непосредственного хранения кода, своих проектов, можно общаться, комментировать изменения друг друга, отслеживать новости знакомых. У программистов есть возможность объединять репозитории и выводить вклад участника в виде дерева. Ключевые особенности GitHub: Совместная работа с управлением большими командами. Графическое представление. Личные страницы проектов. Вики. Система отслеживания ошибок. Просмотр файлов проектов. Подсветка синтаксиса для большинства языков. Приватные репозитории. Прямое добавление новых файлов в репозиторий. Код проектов можно скопировать через Git или скачать. Поддержка получения и редактирования через SVN и Mercurial. Pastebin-сервис gist.github.com для мгновенной публикации фрагментов. Встроенное отслеживание задач и ошибок. Фильтры, назначения и метки у задач. Комментарии, сортировка и время обновления. Сочетания клавиш. Управление вехами. Управление доступом. Markdown-разметка. Добавление изображений. Поддержка SSL, HTTPS и SSH. GitLab — это платформа управления Git-репозиториями, анализа кода, отслеживания ошибок, тестирования, деплоя, ведения каналов и вики-страниц. GitLab помогает разработчикам вести непрерывный процесс развертывания для тестирования, создания и деплоя кода, следить за ходом тестов, повышать контроль над качеством, фокусирования на построении продукта вместо настройки инструментов. Ключевые возможности GitLab: Организация публичных и приватных репозиториев. Управление правами, группами. Импорт проектов, в том числе с GitHub. Вики. API. Доска идей и задач. Лейблы, вехи, шаблоны, поиск. Комментирование, объединение. Интеграция с Jenkins CI. Отслеживание изменений и прогресса. Отслеживание времени.',\r\n      },\r\n      {\r\n        'Что представляют из себя 3 области: Working directory, Staging area, Repository?':\r\n          'Система трёх основных стадий: working directory, staging area и repository. Стадия 1: Working Directory Working directory переводится как \"рабочая папка\". По сути это папка на компьютере, за которой GIT \"следит\". Когда GIT начинает \"видеть\" папку - Во-первых, все команды GIT по работе с файлами будут работать только в этой папке. Если Вы зайдете в папку \"Единороги\", которая не является рабочей папкой GIT, и попробуете добавить в GIT файлы оттуда - ничего не получится. Вам придется или скопировать файл из \"Единорогов\" в \"Calculator\", или сделать папку \"Единорогов\" тоже рабочей папкой GIT. Во-вторых, в такой папке создается скрытая папка .git.  GIT начинает хранить в своей рабочей папке мета данные по Вашему проекту. Стадия 2: Staging Area - Когда мы используем команду (наподобие \"Гит добавить\") - и вот теперь GIT начинает следить за измениями состояния нашего файла. Теперь файл находится в Staging area: Staging area - это файл, в котором хранится список того, что Вы хотите отправить на удаленный репозиторий (т.е. \"показать всему миру\" 🙂 ). Стадия 3: Repository - Вы даете команду GIT - \"запомни состояние этих файлов\". В этот момент GIT делает \"снимок\" нужных файлов - и они переходят в стадию \"repository\". Если бы у нас был только один файл - file.txt. Отлично! Теперь у нас есть \"снимок\" файла (или файлов) на определенный момент времени - и мы сможем к нему вернуться когда нам будет необходимо. сли Вы захотите поделиться с миром своим кодом (т.е. закинуть его на удаленный репозиторий), Вам придется сделать еще один шаг уже после комита. Вы грубо говоря пишите \"гит отправь\" - и если не будет ошибок, Ваши файлы успешно окажутся на каком-нибудь GitHub',\r\n      },\r\n      {\r\n        'Ветки Что такое ветка? Зачем нужны ветки? Что значит \"создать ветку\" и \"удалить ветку\" (что при этом происходит)? Как посмотреть список веток? Как сменить ветку? Как создать ветку? Как переименовать ветку? Как удалить ветку?':\r\n          'Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих СКВ создание веток — это очень затратный процесс, часто требующий создания новой копии директории, что может занять много времени для большого проекта. Ветка в Git — это простой перемещаемый указатель на один из таких коммитов. По умолчанию, имя основной ветки в Git — master. Как только вы начнёте создавать коммиты, ветка master будет всегда указывать на последний коммит. Каждый раз при создании коммита указатель ветки master будет передвигаться на следующий коммит автоматически. Создание новой ветки Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем testing. Вы можете это сделать командой git branch : $ git branch testing В результате создаётся новый указатель на текущий коммит. Команда git branch только создаёт новую ветку, но не переключает на неё. Для переключения на существующую ветку выполните команду git checkout. Давайте переключимся на ветку testing: $ git checkout testing В результате указатель HEAD переместится на ветку testing. Для удаления ветки выполните команду git branch с параметром -d:  Как переименовать локальную ветку Если вы хотите переименовать ветку, на которой находитесь git branch -m new-name Если вы на другой ветке: git branch -m old-name new-name. Для вывода всех веток, локальных и удаленных, используется ключ -a: git branch -a',\r\n      },\r\n      {\r\n        'Для чего нужен файл .gitignore?':\r\n          '.gitignore нужен для скрытия файлов и папок от системы контроля версий Git. Обычно скрывают конфигурационные файлы (особенно с паролями), временные файли и папки. gitignore использует glob формат для выборки файлов. Основной синтаксис: Каждая строка - отдельный шаблон Пустые строки игнорируются Строки начинающиеся с # являются комментариями Символ слеша \"/\" в начале строки указывает на текущую папку (где лежит .gitignore) Звёздочка(*) заменяет любое количество символов Две звёздочки(**) используются для указания всех подпапок. Восклицательный знак(!) в начале строки инвертирует шаблон (используется для исключений) Для экранирования спецсимволов используется обратный слэш \"\". Для игнорирования всей директории, правило должно оканчиваться на слэш(/), в противном случае правило считается именем файла.',\r\n      },\r\n      {\r\n        'git config: что позволяет делать и какие три уровня конфигурации есть?':\r\n          'В состав Git входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах: Файл /etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл. Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global. Файл config в каталоге Git (т.е. .git/config) репозитория, который вы используете в данный момент, хранит настройки конкретного репозитория. Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.',\r\n      },\r\n      {\r\n        'Что делают, как и зачем использовать команды: add commit Как и при каких условиях можно сделать коммит, не написав перед этим явно git add? Как написать сообщение для коммита не открывая редактора? push fetch merge Что такое fast-forward merge? Что делают флаги --squash и --no-ff? pull':\r\n          'Команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита. Команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок. Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add. Команда git merge используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит. Мы познакомили вас с этой командой в главе Основы ветвления. И хотя git merge встречается в этой книге повсеместно, практически все использования имеют вид git merge <branch> с указанием единственной ветки для слияния. Другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях. Это называется “fast-forward”. git merge feature --squash объединит изменения всех коммитов ветки feature, перенесет их в ветку master и добавит в индекс. При этом коммит слияния не будет создан, вам нужно будет сделать его вручную. Во время выполнения git merge — можно указать опцию --no-ff, что бы гит сохранил историю коммитов в feature-бранче.  Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально. Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию. ',\r\n      },\r\n      {\r\n        'Что такое Pull Request (или Merge Request)?':\r\n          'Pull request — это отправка ваших изменений в репозитории на проверку программистам. Пример ситуации. Вы нашли ошибку в каком-то фреймворке или библиотеке и хотите исправить ошибку и отправить разработчикам, чтобы они внесли ваши изменения в master-ветку репозитория.  Pull request это отправка ваших изменений, но без вливания кода сразу в репозиторий. Вначале ваш commit проверят разработчики.',\r\n      },\r\n      {\r\n        'Как посмотреть историю коммитов?':\r\n          'Одним из основных и наиболее мощных инструментов для этого является команда git log. По умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке – последние коммиты находятся вверху.  Команда git log имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них. Одним из самых полезных аргументов является -p или --patch, который показывает разницу (выводит патч), внесенную в каждый коммит. Так же вы можете ограничить количество записей в выводе команды; используйте параметр -2 для вывода только двух записей. Если вы хотите увидеть сокращенную статистику для каждого коммита, вы можете использовать опцию --stat. Следующей действительно полезной опцией является --pretty. Эта опция меняет формат вывода. Существует несколько встроенных вариантов отображения. Опция oneline выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов. К тому же, опции short, full и fuller делают вывод приблизительно в том же формате, но с меньшим или большим количеством информации соответственно. Наиболее интересной опцией является format, которая позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git:',\r\n      },\r\n    ],\r\n  },\r\n];\r\n\r\nexport default Junior01;\r\n","const Junior02 = [\r\n  {\r\n    HTML: [\r\n      {\r\n        'Как использовать теги <audio> и <video>? Как включить стандартные элементы управления? Как сделать кастомные элементы управления?':\r\n          'Добавляет, воспроизводит и управляет настройками аудиозаписи на веб-странице. Путь к файлу задается через атрибут src или вложенный тег <source>. Внутри контейнера <audio> можно написать текст, который будет выводиться в браузерах, не работающих с этим тегом.Добавляет, воспроизводит и управляет настройками видеоролика на веб-странице. Путь к файлу задается через атрибут src или вложенный тег <source>.Атрибуты autoplay Видео начинает воспроизводиться автоматически после загрузки страницы. controls Добавляет панель управления к видеоролику. height Задает высоту области для воспроизведения видеоролика. loop Повторяет воспроизведение видео с начала после его завершения. poster Указывает адрес картинки, которая будет отображаться, пока видео не доступно или не воспроизводится. preload Используется для загрузки видео вместе с загрузкой веб-страницы. src Указывает путь к воспроизводимому видеоролику. width Задает ширину области для воспроизведения видеоролика. Вы должны либо использовать атрибут controls,  чтобы использовать встроенный в браузер интерфейс управления  или создать собственный интерфейс, используя соответствующие  JavaScript API. Как минимум, интерфейс должен включать способ запуска и остановки медиа-носителя и регулировки громкости. https://metanit.com/web/html5/7.3.php',\r\n      },\r\n      {\r\n        'Как использовать тег <iframe>? Что такое и какую пользу приносит? Какие есть use cases общения родителя и iframe, какие есть способы реализации этого? Что такое кросс-доменные iframes и какие у них ограничения?':\r\n          'ег <iframe> создает плавающий фрейм, который находится внутри обычного документа, он позволяет загружать в область заданных размеров любые другие независимые документы. Тег <iframe> является контейнером, содержание которого игнорируется браузерами, не поддерживающими данный тег. Для таких браузеров можно указать альтернативный текст, который увидят пользователи. Он должен располагаться между элементами <iframe> и </iframe>. Содержимое внутри области существует независимо от окружающей страницы. Две страницы: родительская и дочерняя, отображаемая в рамке, могут взаимодействовать друг с другом через JavaScript или серверный язык программирования.Элемент iframe является обычным узлом DOM, как и любой другой. Существенное отличие – в том, что с ним связан объект window внутреннего окна. Он доступен по ссылке iframe.contentWindow. Таким образом, iframe.contentWindow.document будет внутренним документом, iframe.contentWindow.document.body – его <body> и так далее.Элемент <iframe> является «двуличным». С одной стороны, это обычный узел DOM, с другой – внутри находится окно, которое может иметь совершенно другой URL, содержать независимый документ из другого источника. Внешний документ имеет полный доступ к <iframe> как к DOM-узлу. А вот к окну – если они с одного источника. Это приводит к забавным последствиям. Например, чтобы узнать об окончании загрузки <iframe>, мы можем повесить обработчик iframe.onload. По сути, это то же самое что iframe.contentWindow.onload, но его мы можем поставить лишь в случае, если окно с того же источника.Интерфейс postMessage позволяет окнам общаться между собой независимо от их происхождения. Это способ обойти политику «Одинакового источника». Он позволяет обмениваться информацией, скажем john-smith.com и gmail.com, но только в том случае, если оба сайта согласны и вызывают соответствующие JavaScript-функции. Это делает общение безопасным для пользователя. Интерфейс имеет две части. postMessage Окно, которое хочет отправить сообщение, должно вызвать метод postMessage окна получателя. Другими словами, если мы хотим отправить сообщение в окно win, тогда нам следует вызвать win.postMessage(data, targetOrigin). Аргументы: data Данные для отправки. Может быть любым объектом, данные клонируются с использованием «алгоритма структурированного клонирования». IE поддерживает только строки, поэтому мы должны использовать метод JSON.stringify на сложных объектах, чтобы поддержать этот браузер. targetOrigin Определяет источник для окна-получателя, только окно с данного источника имеет право получить сообщение. Указание targetOrigin является мерой безопасности. Как мы помним, если окно (получатель) происходит из другого источника, мы из окна-отправителя не можем прочитать его location. Таким образом, мы не можем быть уверены, какой сайт открыт в заданном окне прямо сейчас: пользователь мог перейти куда-то, окно-отправитель не может это знать.onmessage Чтобы получать сообщения, окно-получатель должно иметь обработчик события message (сообщение). Оно срабатывает, когда был вызван метод postMessage (и проверка targetOrigin пройдена успешно). Объект события имеет специфичные свойства: data Данные из postMessage. origin Источник отправителя, например, http://javascript.info. source Ссылка на окно-отправитель. Можно сразу отправить что-то в ответ, вызвав source.postMessage(...). Чтобы добавить обработчик, следует использовать метод addEventListener, короткий синтаксис window.onmessage не работает.Чтобы вызвать метод или получить содержимое из другого окна, нам во-первых необходимо иметь ссылку на него. Для всплывающих окон (попапов) доступны ссылки в обе стороны: При открытии окна: window.open открывает новое окно и возвращает ссылку на него, Изнутри открытого окна: window.opener – ссылка на открывающее окно. Для ифреймов мы можем иметь доступ к родителям/потомкам, используя: window.frames – коллекция объектов window вложенных ифреймов, window.parent, window.top – это ссылки на родительское окно и окно самого верхнего уровня, iframe.contentWindow – это объект window внутри тега <iframe>. Если окна имеют одинаковый источник (протокол, домен, порт), то они могут делать друг с другом всё, что угодно. В противном случае возможны только следующие действия: Изменение свойства location другого окна (доступ только на запись). Отправить туда сообщение. Исключения: Окна, которые имеют общий домен второго уровня: a.site.com и b.site.com. Установка свойства document.domain=\"site.com\" в обоих окнах переведёт их в состояние «Одинакового источника». Если у ифрейма установлен атрибут sandbox, это принудительно переведёт окна в состояние «разных источников», если не установить в атрибут значение allow-same-origin. Это можно использовать для запуска ненадёжного кода в ифрейме с того же сайта. Метод postMessage позволяет общаться двум окнам с любыми источниками: Отправитель вызывает targetWin.postMessage(data, targetOrigin). Если targetOrigin не ' *\r\n          ', тогда браузер проверяет имеет ли targetWin источник targetOrigin. Если это так, тогда targetWin вызывает событие message со специальными свойствами: origin – источник окна отправителя (например, http://my.site.com) source – ссылка на окно отправитель. data – данные, может быть объектом везде, кроме IE (в IE только строки). В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.',\r\n      },\r\n      {\r\n        'Что делают async, defer у скриптов и какая между ними разница?':\r\n          'Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит. Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async – нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async – нет.',\r\n      },\r\n      {\r\n        'Рассказать про атрибуты <form>: action, autocomplete, enctype,method,name':\r\n          'Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению. Документ может содержать любое количество форм, но одновременно на сервер может быть отправлена только одна форма. По этой причине данные форм должны быть независимы друг от друга. Для отправки формы на сервер используется кнопка Submit, того же можно добиться, если нажать клавишу Enter в пределах формы. Если кнопка Submit отсутствует в форме, клавиша Enter имитирует ее использование. accept-charset Устанавливает кодировку, в которой сервер может принимать и обрабатывать данные. action Адрес программы или документа, который обрабатывает данные формы. autocomplete Включает автозаполнение полей формы. enctype Способ кодирования данных формы. method Метод протокола HTTP. name Имя формы. novalidate Отменяет встроенную проверку данных формы на корректность ввода. target Имя окна или фрейма, куда обработчик будет загружать возвращаемый результат.',\r\n      },\r\n      {\r\n        'Рассказать про атрибуты <input>: form,list,maxlength,multiple,name,placeholder,readonly,required,tabindex,value,type':\r\n          'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript. Основной атрибут тега <input>, определяющий вид элемента — type. Он позволяет задавать следующие элементы формы: текстовое поле (text), поле с паролем (password), переключатель (radio), флажок (checkbox), скрытое поле (hidden), кнопка (button), кнопка для отправки формы (submit), кнопка для очистки формы (reset), поле для отправки файла (file) и кнопка с изображением (image). Для каждого элемента существует свой список атрибутов, которые определяют его вид и характеристики. Кроме того, в HTML5 добавлено еще более десятка новых элементов. Атрибуты accept Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов. accesskey Переход к элементу с помощью комбинации клавиш. align Определяет выравнивание изображения. alt Альтернативный текст для кнопки с изображением. autocomplete Включает или отключает автозаполнение. autofocus Устанавливает фокус в поле формы. border Толщина рамки вокруг изображения. checked Предварительно активированный переключатель или флажок. disabled Блокирует доступ и изменение элемента. form Связывает поле с формой по её идентификатору. formaction Определяет адрес обработчика формы. formenctype Устанавливает способ кодирования данных формы при их отправке на сервер. formmethod Сообщает браузеру каким методом следует передавать данные формы на сервер. formnovalidate Отменяет встроенную проверку данных на корректность. formtarget Определяет окно или фрейм в которое будет загружаться результат, возвращаемый обработчиком формы. list Указывает на список вариантов, которые можно выбирать при вводе текста. max Верхнее значение для ввода числа или даты. maxlength Максимальное количество символов разрешенных в тексте. min Нижнее значение для ввода числа или даты. multiple Позволяет загрузить несколько файлов одновременно. name Имя поля, предназначено для того, чтобы обработчик формы мог его идентифицировать. pattern Устанавливает шаблон ввода. placeholder Выводит подсказывающий текст. readonly Устанавливает, что поле не может изменяться пользователем. required Обязательное для заполнения поле. size Ширина текстового поля. src Адрес графического файла для поля с изображением. step Шаг приращения для числовых полей. tabindex Определяет порядок перехода между элементами с помощью клавиши Tab. type Сообщает браузеру, к какому типу относится элемент формы. value Значение элемента.',\r\n      },\r\n      {\r\n        'Тег <textarea>  Как запретить изменение размера? Как задать значение по умолчанию? Как избежать вертикальной прокрутки для большого текста? Какие есть html-pure альтернативы? В чем разница задания размеров через cols & rows и height & width?':\r\n          'Вид уголка различается, но его функции остаются одинаковыми, если щёлкнуть мышью и потянуть за уголок, то можно изменить размеры поля. Чтобы запретить эту возможность, следует для селектора textarea задать свойство resize со значением none Поле <textarea> представляет собой элемент формы для создания области, в которую можно вводить несколько строк текста. В отличие от тега <input> в текстовом поле допустимо делать переносы строк, они сохраняются при отправке данных на сервер. Между тегами <textarea> и </textarea> можно поместить любой текст, который будет отображаться внутри поля. cols Ширина текстового поля, которое определяется числом символов моноширинного шрифта. Иными словами, ширина задаётся количеством близстоящих букв одинаковой ширины по горизонтали. Если размер шрифта изменяется с помощью стилей, ширина также соответственно меняется.Специально для задания размеров textarea используются два атрибута cols и rows. rows - это атрибут, который позволяет задать высоту текстовой области в строках. Задавая здесь какое-нибудь значение, мы указываем сколько строк текста должна отображать текстовая область без прокрутки. cols - это параметр, который задает количество символов, которые будут отображаться по горизонтали, без использования полосы прокрутки. С ее помощью вы можете регулировать ширину текстовой области. Кроме того, изменять высоту и ширину можно с помощью стилей CSS и свойств width и height.Согласно w3c, cols и строки являются обязательными атрибутами для текстовых областей. Строки и Cols - это количество символов, которые будут помещаться в textarea, а не пиксели или какое-либо другое потенциально произвольное значение. ',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    CSS: [\r\n      {\r\n        'Что такое web-safe шрифты?':\r\n          'Часто используемые сочетания шрифтов Свойство font-family должно содержать несколько имен шрифтов в качестве \"резервной\" системы, чтобы обеспечить максимальную совместимость между браузерами/операционными системами. Если обозреватель не поддерживает первый шрифт, он пытается следующий шрифт. Начните с нужного шрифта и заканчивайте родовым семейством, чтобы позволить обозревателю выбрать аналогичный шрифт в родовом семействе, если другие шрифты недоступны: Пример p { font-family: \"Times New Roman\", Times, serif; }',\r\n      },\r\n      {\r\n        'Что такое autoprefixer и зачем он нужен?':\r\n          'рограммист, который использует CSS3 сталкивался с префиксами: -webkit, -ms, -o, -moz. Эти префиксы обеспечивают поддержку браузерами CSS3 свойств. Когда вы пишите эти префиксы руками, то легко можете забыть установить какой либо из них. Вы конечно можете воспользоваться caniuse.com, чтобы найти нужные префиксы, но эту рутинную работу можно (и нужно) автоматизировать. Для системы сборки Gulp существует плагин gulp-autoprefixer, который использует базу caniuse.com для определения какие префиксы нужно использовать. Autoprefixer сканирует ваши CSS файлы, и автоматически проставляет префиксы к css свойствам.',\r\n      },\r\n      {\r\n        'Что такое спрайты и зачем они нужны? Какие проблемы адаптивности с ними связаны?':\r\n          'Спрайты это много картинок (обычно небольшого размера), объединенных в одну. В бэкграунде каждого блока прописывается это изображение, затем оно смещается при помощи css-свойства бэкграунд-позишн (background-position). Так как размер блока фиксированный, то мы видим только ту часть картинки, которую нужно. Основное назначение CSS спрайтов: Сокращение числа HTTP-запросов. Чем их меньше, тем меньше нагрузка на сервер и тем быстрее загрузится сайт — всё просто. На этом многие «веб-мастера» успокаиваются и знать больше про спрайты ничего не хотят.  одной стороны спрайты помогают в оптимизации страницы, но с другой они абсолютно не адаптивны, что в нынешних реалиях существенный недостаток. Для адаптации иконок мы вынуждены задавать им размеры в относительных величинах. Но в случае со спрайтами это не работает. Так как, задавая background-size и background-position в процентном отношении, за основу, логично, берется размер всей таблицы спрайтов. Что нас, естественно, ни коим образом не устраивает. Решить эту проблему, причем двумя способами. При помощи SASS и при помощи JS/jQuery.  https://habr.com/ru/post/196030/',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    JS: [\r\n      {\r\n        'Что такое геттеры и сеттеры? Как ими пользоваться в JS нативным способом?':\r\n          'Свойство-функция Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в get. Например, у объекта user есть обычные свойства: имя firstName и фамилия surname. Создадим свойство fullName, которое на самом деле является функцией: var user = { firstName: \"Вася\", surname: \"Петров\" } Object.defineProperty(user, \"fullName\", { get: function() { return this.firstName + \" \" + this.surname; } }); alert(user.fullName); // Вася Петров Обратим внимание, снаружи fullName – это обычное свойство user.fullName. Но дескриптор указывает, что на самом деле его значение возвращается функцией. Также можно указать функцию, которая используется для записи значения, при помощи дескриптора set. Например, добавим возможность присвоения user.fullName к примеру выше: var user = { firstName: \"Вася\", surname: \"Петров\" } Object.defineProperty(user, \"fullName\", { get: function() { return this.firstName + \" \" + this.surname; }, set: function(value) { var split = value.split(\" \"); this.firstName = split[0]; this.surname = split[1]; } }); user.fullName = \"Петя Иванов\"; alert( user.firstName ); // Петя alert( user.surname ); // Иванов  Указание get/set в литералах Если мы создаём объект при помощи синтаксиса { ... }, то задать свойства-функции можно прямо в его определении. Для этого используется особый синтаксис: get свойство или set свойство. Например, ниже объявлен геттер-сеттер fullName: var user = { firstName: \"Вася\", surname: \"Петров\", get fullName() { return this.firstName + \" \" + this.surname; }, set fullName(value) { var split = value.split(\" \"); this.firstName = split[0]; this.surname = split[1]; } };',\r\n      },\r\n      {\r\n        'Дескрипторы свойств объектов: что такое и что позволяют делать?':\r\n          'Основной метод для управления свойствами – Object.defineProperty. Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить. Синтаксис: Object.defineProperty(obj, prop, descriptor) Аргументы: obj Объект, в котором объявляется свойство. prop Имя свойства, которое нужно объявить или модифицировать. descriptor Дескриптор – объект, который описывает поведение свойства. В нём могут быть следующие поля: value – значение свойства, по умолчанию undefined writable – значение свойства можно менять, если true. По умолчанию false. configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false. enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false. get – функция, которая возвращает значение свойства. По умолчанию undefined. set – функция, которая записывает значение свойства. По умолчанию undefined. Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций. var user = {}; // 1. простое присваивание user.name = \"Вася\"; // 2. указание значения через дескриптор Object.defineProperty(user, \"name\", { value: \"Вася\", configurable: true, writable: true, enumerable: true });',\r\n      },\r\n      {\r\n        'Приведение объектов к примитивам: когда происходит и как работает? ':\r\n          'Все объекты в логическом контексте являются true. Существуют лишь их численные и строковые преобразования. Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции. Например, объекты Date (мы рассмотрим их в статье Дата и время) могут вычитаться, и результатом date1 - date2 будет временной отрезок между двумя датами. Что касается строковых преобразований – они обычно происходят, когда мы выводим объект alert(obj), а также в других случаях, когда объект используется как строка. Преобразование к примитивам Мы можем тонко настраивать строковые и численные преобразования, используя специальные методы объекта. Существуют три варианта преобразований («три хинта»), описанные в спецификации: \"string\" Для преобразования объекта к строке, когда операция ожидает получить строку, например alert: // вывод alert(obj); // используем объект в качестве имени свойства anotherObj[obj] = 123; \"number\" Для преобразования объекта к числу, в случае математических операций: // явное преобразование let num = Number(obj); // математическое (исключая бинарный оператор \"+\") let n = +obj; // унарный плюс let delta = date1 - date2; // сравнения больше/меньше let greater = user1 > user2; \"default\" Происходит редко, когда оператор «не уверен», какой тип ожидать. Например, бинарный плюс + может работать с обоими типами: строками (объединять их) и числами (складывать). Таким образом, и те, и другие будут вычисляться. Или когда происходит сравнение объектов с помощью нестрогого равенства == со строкой, числом или символом, и неясно, какое преобразование должно быть выполнено. // бинарный плюс let total = car1 + car2; // obj == string/number/symbol if (user == 1) { ... }; Оператор больше/меньше <> также может работать как со строками, так и с числами. Однако, по историческим причинам он использует хинт «number», а не «default». На практике все встроенные объекты, исключая Date (мы познакомимся с ним чуть позже), реализуют \"default\" преобразования тем же способом, что и \"number\". И нам следует поступать также.',\r\n      },\r\n      {\r\n        'Как сделать так, чтобы было возможно сложение двух объектов? const a = { x: 3 }; const b = { x: 5 }; console.log(a + b); // 8':\r\n          'Symbol.toPrimitive является символом (symbol), который описывает свойство объекта как функцию, которая вызывается при преобразовании объекта в соответсвующее примитивное значение. С помощью свойства Symbol.toPrimitive (которое описывается как функция), объект может быть приведен к примитивному типу. Функция вызывается со строковым аргументом hint, который передает желаемый тип примитива. Значением аргумента hint может быть одно из следующих значений \"number\", \"string\", и \"default\". Описанные ниже примеры показывают как с помощью свойства Symbol.toPrimitive можно привести объект к примитивному типу. // Объект без свойства Symbol.toPrimitive var obj1 = {}; console.log(+obj1);     // NaN console.log(`${obj1}`); // \"[object Object]\" console.log(obj1 + \"\"); // \"[object Object]\" // Объект со свойством Symbol.toPrimitive var obj2 = { [Symbol.toPrimitive](hint) { if (hint == \"number\") { return 10; } if (hint == \"string\") { return \"hello\"; } return true; } }; console.log(+obj2);     // 10        -- желаемый тип (hint) - \"number\" console.log(`${obj2}`); // \"hello\"   -- желаемый тип (hint) - \"string\" console.log(obj2 + \"\"); // \"true\"    -- желаемый тип (hint) - \"default\" Методы toString и valueOf берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов. Для примера, используем их в реализации всё того же объекта user. Воспроизведём его поведение комбинацией методов toString и valueOf: let user = { name: \"John\", money: 1000, // для хинта равного \"string\" toString() { return `{name: \"${this.name}\"}`; }, // для хинта равного \"number\" или \"default\" valueOf() { return this.money; } }; alert(user); // toString -> {name: \"John\"} alert(+user); // valueOf -> 1000 alert(user + 500); // valueOf -> 1500',\r\n      },\r\n      {\r\n        'Как сделать так, чтобы следующее выражение вернуло true? (c==1 && c==2 && c==3)':\r\n          'const a = { num: 0, valueOf: function() { return this.num += 1 } }; const equality = (a==1 && a==2 && a==3); console.log(equality); // true этот код использует две базовые концепции JavaScript: Оператор нестрогого равенства. Метод объекта valueOf(). Обратите внимание на то, что в исследуемом выражении, (a==1 && a==2 && a==3), применяется оператор нестрогого равенства. Это означает, что в ходе вычисления значения этого выражения будет использоваться приведение типов, то есть, с помощью == сравнивать можно значения разных типов. В JavaScript имеется встроенный метод для преобразования объекта в примитивное значение: Object.prototype.valueOf(). По умолчанию этот метод возвращает объект, для которого он был вызван.',\r\n      },\r\n      {\r\n        'Можно ли прервать обход элементов в методе forEach?':\r\n          'Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве. Диапазон элементов, обрабатываемых методом forEach(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода forEach(), не будут посещены функцией callback. Если существующие элементы массива изменятся, значения, переданные в функцию callback, будут значениями на тот момент времени, когда метод forEach() посетит их; удалённые элементы посещены не будут. Если уже посещённые элементы удаляются во время итерации (например, с помощью shift()), последующие элементы будут пропущены. Не существует способа остановить или прервать цикл forEach() кроме как выбрасыванием исключения. Если вам необходимо такое поведение, метод forEach() неправильный выбор. Досрочное прекращение может быть достигнуто с: Простой цикл for Циклы for...of / for...in Array.prototype.every() Array.prototype.some() Array.prototype.find() Array.prototype.findIndex() Если очень хочется использовать именно forEach - можно поместить его в try..catch и кидать ошибку если элемент найден. var massiv = [\"2\", \"1\", \"3\"]; try { massiv.forEach(function(item, i) { console.log(\"foreach\", i); if (item == \"1\") { throw { reason: \"finded\", index: i } } }); } catch ({ reason, index }) { if (reason) { console.log(reason, \":\", index) } }',\r\n      },\r\n      {\r\n        'Можно ли с помощью метода indexOf определить позицию подмассива [3, 4] в массиве [1, 2, [3, 4], 5]?':\r\n          'Нет',\r\n      },\r\n      {\r\n        'Как строку преобразовать в массив? Можно ли для строк применить методы массивов?':\r\n          'Метод .join(\"seprator\") seprator - разделитель. Иногда хочется применить методы массива к строкам или другим массивоподобным объектам (например, к аргументам функции). Делая это, вы трактуете строку как массив символов (другими словами, рассматриваете не-массив в качестве массива).  Общие методы также доступны для объекта String. В настоящее время они не являются частью стандартов ECMAScript (хотя в ES2015 для достижения поставленной цели можно использовать Array.from()).',\r\n      },\r\n      {\r\n        'Что такое \"всплытие\" объявления переменных, и в каком случае у функций тут появляются особенности?':\r\n          'Что же такое хоистинг переменных ? Интерпретатор JavaScript всегда незаметно для нас перемещает («поднимает») объявления функций и переменных в начало области видимости.То есть переменные могут быть доступны до их объявления. В ES6 ввели область видимости на блочном уровне, что дало разработчикам возможность большего контроля над жизненным циклом переменных.Переменная, объявленная внутри блока, будет доступна только в области этого блока. Объявление let. Синтаксис объявления аналогичен с var, просто замените var на let, чтобы объявить переменную с ее областью, являющейся только этим блоком кода. Разместите объявления переменных let в верхней части блока, чтобы они были доступны во всем блоке. JavaScript функции могут классифицироваться как объявленные функции, так и как функциональные выражения. Далее мы узнаем как «поднятие» влияет на оба типа. Объявленные функции Такие функции полностью поднимаются вверх кода. Теперь понятно почему JavaScript позволяет нам вызывать функции прежде, чем мы их объявим по упоминанию в коде. hoisted(); // Вывод: \"This function has been hoisted.\" function hoisted() { console.log(\"This function has been hoisted.\"); Функциональные выражения, однако, не поднимаются. expression(); //Вывод: \"TypeError: expression is not a function var expression = function() { console.log(\"Will this work?\"); }; Как мы можем видеть выше, объявление переменной var expression поднимается, но его назначение как функции — нет. Следовательно, движок выдаст TypeError как увидит expression в виде переменой, а не функции. Порядок по приоритетам Очень важно помнить несколько вещей, объявляя JavaScript функции и переменные. Назначение переменных имеет приоритет перед объявлением функции. Объявление функции имеет приоритет перед объявлением переменной. Объявления функций «поднимаются» над объявлением переменных, но не над их назначениями. https://medium.com/@stasonmars',\r\n      },\r\n      {\r\n        'Влияет ли директива use strict на \"всплытие\"? Как избежать \"всплытия\" переменных?':\r\n          'Запуск кода в strict mode: Мы включаем «строгий режим», заранее указывая в нашем файле или функции следующее: \"use strict\"; // или \"use strict\"; Давайте протестируем. \"use strict\"; console.log(hoist); // Вывод: ReferenceError: hoist is not defined hoist = \"Hoisted\"; Мы видим, что вместо того, чтобы указать, то что мы пропустили объявление нашей переменной, use strict остановил нас на полпути, выдав Reference error. Не использовать var, использовать IIFE',\r\n      },\r\n      {\r\n        'Что такое IIFE (immediately invoked function expression)? Какие есть способы написать IIFE и почему это так работает?':\r\n          'Немедленно вызываемое функциональное выражение. !function() { alert(\"Hello from IIFE!\"); }(); // Покажет alert “Hello from IIFE!” Всякий раз, когда JavaScript видит слово function, как вводное слово, он ожидает того, что сейчас будет объявлена функция. Чтобы этого не случилось, мы префиксим “!” перед словом function на первой строке. Это просто подталкивает JavaScript рассматривать всё, что идёт после восклицательного знака, как выражение.  Ещё один быстрый пример: void function() { alert(\"Hello from IIFE!\"); }(); Снова, void просто принуждает функцию к тому, чтобы ее рассматривали как выражение. два варианта стилизации: // Variation 1 (function() { alert(\"I am an IIFE!\"); }()); // Variation 2 (function() { alert(\"I am an IIFE, too!\"); })(); В чем действительно хороши IIFE, так это в возможности создания области видимости. Любые переменные внутри IIFE не видимы для внешнего мира.В следующий раз, когда вы будете создавать группу переменных и функций в глобальной области видимости, которые никто не использует за пределами вашего кода, просто оберните все их в IIFE и получит в ответочку много хорошей JavaScript кармы за такие дела. Ваш код будет также работать, но только теперь вы не будете загрязнять глобальную область видимости. А еще вы защитите ваш код от тех, кто может случайно внести изменения в глобальные переменные, ну а может быть и не случайно. Но ещё одной реально важной и полезной фичей IIFE является то, что с их помощью вы можете отдавать значение, которое будет назначено переменной. var result = (function() { return \"From IIFE\"; }()); alert(result); // alerts \"From IIFE\" IIFE не только могут отдавать значения, но ещё и брать аргументы во время своего вызова. Давайте посмотрим на этот короткий пример. (function IIFE(msg, times) { for (var i = 1; i <= times; i++) { console.log(msg); } }(\"Hello!\", 5)); В примере выше, на 1й строке, IIFE чисто формально имеет два параметра с именами msg и times. Когда мы выполняем её на 5й строке, то вместо пустых скобок, мы в них передаём аргументы IIFE. Вот несколько преимуществ такой передачи параметров к IIFE. JavaScript всегда делает поиск по области видимости заданной функции и продолжает поиск в области видимости выше, пока не найдёт указанный идентификатор. лассический модульный паттерн в JavaScript Теперь, когда вы отточили навыки работы с IIFE, давайте посмотрим на пример модульного паттерна, который раскрывают всю мощь совместного применения замыканий и IIFE функций. Тут мы применим классический синглтон объект Sequence, в котором всё стабильно отрабатывает без возможности непреднамеренного изменения значения. Мы разделим код на два шага, чтобы постепенно понять то, что происходит под капотом. var Sequence = (function sequenceIIFE() { // приватная переменная для хранения значения счетчика var current = 0; // объект, возвращаемый IIFE return { }; }()); alert(typeof Sequence); // alerts \"object\" ',\r\n      },\r\n      {\r\n        'Как сделать так, чтобы при вызове immediately invoked function expression сохранялся родительский контекст?':\r\n          'Привязкой контекста через bind var a = { property1: \"test\", method1: function() { (function(par1, par2, par3) { console.log(this.property1); }).bind(this)(1, 2, 3); } }; a.method1(); или стрелочной функцией var a = { property1: \"test\", method1: function() { ((par1, par2, par3) => { console.log(this.property1); })(1, 2, 3); } }; a.method1();',\r\n      },\r\n      {\r\n        'Как использовать стандартные методы массива для ненастоящих массивов (например, вызвать map для arguments) и почему это работает?':\r\n          'Псевдомассив — это объект, который структурно похож на массив. То есть у него есть числовые свойства (индексы) и свойство length. Главным отличием псевдомассива от массива является его наследование прототипа, то есть свойство __proto__. Когда мы посмотрим в свойства массива, то увидим, что он наследует прототип Array объекта. То есть, все свойства, которые есть в объекте Array.prototype будут доступны для любого массива. Если же посмотреть в свойства какого-либо псевдомассива, то можно заметить, что он наследует прототип другого объекта вместе с другими свойствами.Чтобы преобразить псевдомассив в массив, есть несколько вариантов:  Перебрать значения псевдомассива в обычный массив Первый вариант, который приходит в голову новичкам — с помощью цикла перебрать все значения из псевдомассива в массив. С помощью функции Array.from() Данный вариант немного спорный, так как таблицы, поддержки браузерами данной функции, на разных сайтах разные. Но я с уверенностью могу сказать, что во всех современных браузерах данный метод будет работать. С помощью функции Array.prototype.slice.call() ( [].slice.call() ) Этот метод «наших дедушек и бабушек», который работает до сих пор. С помощью spread оператора Данный метод во время написания данной статьи является довольно спорным, так как поддерживается до сих пор не всеми браузерами и будет работать только с «корневыми» псевдомассивами (NodeList, HTMLCollection и прочее). С помощью изменения свойства __proto__ Про это свойство я упоминал в начале статьи. Если мы изменим свойство __proto__ объекта на Array.prototype, то псевдомассив преобразуется в массив. Но этот метод входит в те самые «кроме некоторых случаев», про которые я писал више, так как, для полного преображения в массив, свойство length должно являться целым числом. ',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Testing: [\r\n      {\r\n        'Какое время должен длиться идеальный рабочий цикл: написание теста -> изменение функциональности -> рефакторинг?':\r\n          '',\r\n      },\r\n      {\r\n        'Какие библиотеки есть для создания тестов и их запуска (и чем отличаются друг от друга)?':\r\n          '',\r\n      },\r\n      { 'Как тесты помогают со входом в проект новичков?': '' },\r\n      { 'Как тесты помогают в документировании проекта?': '' },\r\n      {\r\n        'Как тесты ускоряют получение фидбека от проделанной работы и почему этот фидбек важен?':\r\n          '',\r\n      },\r\n      { 'Какие этапы ручного тестирования помогают избегать unit-тесты?': '' },\r\n      { 'Зачем добиваться того, чтобы тесты работали быстро?': '' },\r\n      {\r\n        'Как добиваться того, чтобы ошибки в тестах были максимально очевидными?':\r\n          '',\r\n      },\r\n      { 'Нужно ли автоматизированно тестировать сами тесты?': '' },\r\n    ],\r\n  },\r\n  {\r\n    DOM: [\r\n      {\r\n        'Что такое DOM, BOM и window?':\r\n          'Глобальный объект window можно разделить на три части: Объектная модель документа (DOM) — объект document,через который осуществляется доступ к содержимому страницы. Объектная модель браузера (BOM) — объекты, методы и свойства для работы с браузером. Сам javascript — его объекты, свойства и функции. Как мы видим, имеется корневой объект window, который выступает в 2 ролях: Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект. Во-вторых, он также представляет собой окно браузера и располагает методами для управления им. Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа. Например: Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее). Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.  https://learn.javascript.ru/browser-environment',\r\n      },\r\n      {\r\n        'Как происходит построение DOM дерева?':\r\n          'Чтобы получить DOM-дерево так как его строит браузер, необходимо просто «выстроить» все элементы в зависимости от их отношения друг к другу. Создание DOM-дерева выполняется сверху вниз. При этом корнем DOM-дерева всегда является сам документ (узел document). Далее дерево строится в зависимости от структуры HTML кода.',\r\n      },\r\n      {\r\n        'Что такое document и в чем его отличия от window? Когда лучше использовать document, а когда window?':\r\n          'window - окно браузера document - это содержимое всего сайта. Объект window представляет собой окно, содержащее DOM документ; свойство document указывает на DOM document, загруженный в данном окне. Окно текущего документа может быть получено с помощью свойства document.defaultView.',\r\n      },\r\n      {\r\n        'Как происходит навигация по DOM-элементам? Для чего используются объекты node и element? В чем их сходства и различия? Что такое: previousSibling/nextSibling, children, childNodes, firstChild/lastChild, firstElementChild/lastElementChild? Рассказать про методы навигации по DOM: getElementById, getElementsByClassName, getElementsByTagName, getElementsByName, querySelector, querySelectorAll, closest. Рассказать про навигацию внутри HTMLTable​Element и HTMLFormElement.':\r\n          'Доступ к DOM начинается с объекта document. Из него можно добраться до любых узлов.Существуют следующие классы: EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже. Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. Но есть определённые классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев. Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement. HTMLElement – является базовым классом для всех остальных HTML-элементов. Свойство Node.previousSibling используется только для чтения, оно возвращает узел предшедствующий указанному в родительском элементе childNodes, или null,  если указанный узел первый в своём родителе. Свойство Node.firstChild только для чтения, возвращающее первый потомок узла в древе или null, если узел является бездетным. Если узел это документ, он возвращает первый узел в списке своих прямых детей. Объекты table описывают интерфейс HTMLTableElement, который содержит дополнительные свойства и методы (по сравнению с обычным объектным интерфейсом element которые также доступны вследствии наследования) для управления внешним видом таблиц HTML. Наследует свойства от родителя, HTMLElement. table.caption caption возвращает заголовок таблицы. table.tHead tHead возвращает header таблицы. table.tFoot tFoot возвращает footer таблицы. table.rows rows возвращает строки таблицы. table.tBodies tBodies возвращает тела таблицы. table.align align возвращает/устанавливает выравнивание таблицы. table.bgColor bgColor возвращает/устанавливает цвет фона таблицы. table.border border возвращает/устанавливает рамку таблицы. table.cellPadding cellPadding возвращает/устанавливает cellpadding. table.cellSpacing cellSpacing возвращает/устанавливает cellspacing. table.frame frame определяет, какие стороны таблицы имеют рамку. table.rules rules определяет, какие внутренние рамки являются видимыми. table.summary summary возвращает/устанавливает описание таблицы. table.width width возвращает/устанавливает ширину таблицы.HTMLFormElement.length  - свойство только для чтения, которое возвращает количество элементов управления в элементе <form>. Вы можете получить доступ к списку элементов управления формы с помощью свойства elements. Это свойство учитывает элементы, которые являются потомками элемента <form>, а также элементы, которые были определены как члены этой формы с помощью их свойства form.',\r\n      },\r\n      {\r\n        'Рассказать про методы навигации по DOM: getElementById, getElementsByClassName, getElementsByTagName, getElementsByName, querySelector, querySelectorAll, closest.':\r\n          'document.getElementById или просто id Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни находился.querySelectorAll Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору. querySelector Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору. Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0], но он сначала найдёт все элементы, а потом возьмёт первый, в то время как elem.querySelector найдёт только первый и остановится. closest Предки элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины. Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск. Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.',\r\n      },\r\n      {\r\n        'Добавление/удаление/клонирование/вставка элементов и узлов. Какими способами это можно сделать?':\r\n          'Создание элемента DOM-узел можно создать двумя методами: document.createElement(tag) Создаёт новый элемент с заданным тегом: let div = document.createElement(\"div\"); document.createTextNode(text) Создаёт новый текстовый узел с заданным текстом: let textNode = document.createTextNode(\"А вот и я\"); Методы вставки Чтобы наш div появился, нам нужно вставить его где-нибудь в document. Например, в document.body. Для этого есть метод append, в нашем случае: document.body.append(div).Вот методы для различных вариантов вставки: node.append(...nodes or strings) – добавляет узлы или строки в конец node, node.prepend(...nodes or strings) – вставляет узлы или строки в начало node, node.before(...nodes or strings) –- вставляет узлы или строки до node, node.after(...nodes or strings) –- вставляет узлы или строки после node, node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками. insertAdjacentHTML/Text/Element С этим может помочь другой, довольно универсальный метод: elem.insertAdjacentHTML(where, html). Первый параметр – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих: \"beforebegin\" – вставить html непосредственно перед elem, \"afterbegin\" – вставить html в начало elem, \"beforeend\" – вставить html в конец elem, \"afterend\" – вставить html непосредственно после elem. Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML». Удаление узлов Для удаления узла есть методы node.remove().Вызов elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов. ',\r\n      },\r\n      {\r\n        'Атрибуты и свойства Как взаимодействовать с атрибутами HTML элемента через JS? Что от чего зависит: свойство от атрибута или атрибут от свойства? Могут ли не совпадать значения в свойстве объекта и в атрибуте одного и того же HTML элемента?  Что выведет данный код:<div id=\"topId\" href=\"http://fsd.com\" foo=\"bar\"></div><script> console.log(document.getElementById(\"topId\").foo);</script>':\r\n          'Узел DOM – это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы. Обратим внимание, пользовательские DOM-свойства: Могут иметь любое значение. Названия свойств чувствительны к регистру. Работают за счёт того, что DOM-узлы являются объектами JavaScript. Доступ к атрибутам осуществляется при помощи стандартных методов: elem.hasAttribute(name) – проверяет наличие атрибута elem.getAttribute(name) – получает значение атрибута elem.setAttribute(name, value) – устанавливает атрибут elem.removeAttribute(name) – удаляет атрибут. Также все атрибуты элемента можно получить с помощью свойства elem.attributes, которое содержит псевдо-массив объектов типа Attr. В отличие от свойств, атрибуты: Всегда являются строками. Их имя нечувствительно к регистру (ведь это HTML) Видны в innerHTML (за исключением старых IE) Исходное значение value Изменение некоторых свойств обновляет атрибут. Но это скорее исключение, чем правило. Чаще синхронизация – односторонняя: свойство зависит от атрибута, но не наоборот. Например, при изменении свойства input.value атрибут input.getAttribute(\"value\") не меняется',\r\n      },\r\n      {\r\n        'CSS стили в DOM Зачем нужно свойство style у HTML-элемента? Как им пользоваться? Какими способами можно задать стили элементу через JS? Для чего используется window.getComputedStyle?':\r\n          'JavaScript может менять и классы, и свойство style. Классы – всегда предпочтительный вариант по сравнению со style. Мы должны манипулировать свойством style только в том случае, если классы «не могут справиться». Например, использование style является приемлемым, если мы вычисляем координаты элемента динамически и хотим установить их из JavaScript: let top = /* сложные расчёты */; let left = /* сложные расчёты */; elem.style.left = left; // например, \"123px\", значение вычисляется во время работы скрипта elem.style.top = top; // например, \"456px\" В других случаях, например, чтобы сделать текст красным, добавить значок фона – описываем это в CSS и добавляем класс (JavaScript может это сделать). Это более гибкое и лёгкое в поддержке решение. свойство \"className\": elem.className соответствует атрибуту \"class\". Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами. Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс. Для этого есть другое свойство: elem.classList. elem.classList – это специальный объект с методами для добавления/удаления одного класса. Так что мы можем работать как со строкой полного класса, используя className, так и с отдельными классами, используя classList. Выбираем тот вариант, который нам удобнее. Методы classList: elem.classList.add/remove(\"class\") – добавить/удалить класс. elem.classList.toggle(\"class\") – добавить класс, если его нет, иначе удалить. elem.classList.contains(\"class\") – проверка наличия класса, возвращает true/false. Свойство elem.style – это объект, который соответствует тому, что написано в атрибуте \"style\". Установка стиля elem.style.width=\"100px\" работает так же, как наличие в атрибуте style строки width:100px. Для управления классами существуют два DOM-свойства: className – строковое значение, удобно для управления всем набором классов. classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами. Чтобы изменить стили: Свойство style является объектом со стилями в формате camelCase. Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте \"style\". Чтобы узнать, как добавить в него important и делать некоторые другие редкие вещи – смотрите документацию. Свойство style.cssText соответствует всему атрибуту \"style\", полной строке стилей. Для чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется: Метод getComputedStyle(elem, [pseudo]) возвращает объект, похожий по формату на style. Только для чтения.',\r\n      },\r\n      {\r\n        'Что такое DocumentFragment?':\r\n          'DocumentFragment DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов. Мы можем добавить к нему другие узлы, но когда мы вставляем его куда-то, он «исчезает», вместо него вставляется его содержимое.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    MobileBROW: [\r\n      {\r\n        'Как работает hover в мобильных браузерах?':\r\n          'Есть обычная конструкция кнопок css с основным цветом и hover. Всё работает, как и положено, но не для мобильных. Там после нажатия на кнопку цвет остаётся в положении hover. И лишь \"ткнув\" пальцем в экран ещё раз, меняется hover на исходное значение.Псевдокласс :hover в сочетании со свойством transition часто применяется для создания различных анимационных эффектов при наведении курсора мыши на элемент. На мобильных устройствах :hover по понятным причинам не работает — там нет курсора, а взаимодействие происходит касанием пальца. Однако на сенсорном экране с псевдоклассом :hover возникают проблемы: после того, как нажатие выполнено, эффект наведения закрепляется на элементе. Более того, это происходит, даже тогда, когда элемента не касались напрямую. Например, когда пользователь в процессе прокрутки страницы задевает элемент и его отображение меняется, согласно CSS правилам :hover. Такая же проблема возникает при перетаскивании пользователем элементов с :hover по веб-странице. Это происходит, потому что технически — ваш палец (или стилус) и есть указатель, который и активирует :hover. Но проблема состоит в том, что даже после прекращения перетаскивания элемента — эффекты, активированные :hover, остаются. https://medium.com/nuances-of-programming/%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D1%81-css-hover-58977e81a42f',\r\n      },\r\n      {\r\n        'События touch и pointer Что такое? Зачем нужны? Какие бывают?':\r\n          'Чтобы предоставить качественную поддержку touch-based пользовательского интерфейса, тач-события предлагают возможность интерпретации воздействия пальца (или стилуса) на тач-экраны или трекболы. Интерфейсы тач-событий являются относительно низкоуровневым API который может быть использован для поддержки приложений со специфическими мультитач взаимодействиями, например с жестом двух пальцев. Мультитач взаимодействие запускается когда палец (или стилус) впервые касается контакной поверхности. Другие пальцы могут затем нажать поверхность и опционально двигаться по ней. Взаимодействие заканчивается когда пальцы удаляются с поверхности. Во время взаимодействия, приложение получает тач события в начале, в ходе и конце фаз. Тач-события подобны событиям мыши за исключением что они поддерживают одновременные касания и различные расположения на поверхности касания. Интерфейс TouchEvent инкапсулирует все точки касания которые сейчас активны. Интерфейс Touch, который представляет одну точку касания, включает информацию такую как позиция точки касания относительно viewport браузера.События touch включают три интерфейса: (Touch, TouchEvent и TouchList). Так же событие touch поддерживает следующие типы событий: touchstart - срабатывает  в момент касания. touchmove - срабатывает при перемещении. touchend - срабатывает в момент завершения касания (отжатие). touchcancel -  срабатывает в  момент прерывания события (например, создано слишком много точек касания). Интерфейс Touch представляет собой одну точку контакта на сенсорном устройстве. Точка контакта обычно называется точкой касания или просто касанием. Касание обычно производится пальцем или стилусом на сенсорном экране, ручке или трекпаде. Свойства точки касания включают в себя уникальный идентификатор (id), целевой элемент точки касания (target), а также координаты X и Y положения точки касания относительно области просмотра, страницы и экрана. Интерфейс TouchList представляет массив точек контакта с сенсорной поверхностью. Таким образом, если пользователь активирует сенсорную поверхность одним пальцем, массив будет содержать один элемент, а если пользователь коснется поверхности тремя пальцами, длина массива будет равна трем. Интерфейс TouchEvent представляет событие, отправляемое при изменении состояния контактов с сенсорной поверхностью. Изменения состояния включают начальный контакт с сенсорной поверхностью, перемещение точки касания при сохранении контакта с поверхностью, отпускание точки касания и отмену события касания. Атрибуты этого интерфейса включают состояние нескольких клавиш-модификаторов (например, клавиши Shift) и данных: touches - массив из всех точек касания, находящихся в данный момент на экране. targetTouches - массив точек касания на целевом элементе DOM. changedTouches - массив точек касания, элементы которых зависят от типа связанного события: Для события touchstart - массив точек касания, которые стали активными в момент касания. Для события touchmove - массив точек касания, которые изменились со времени последнего события. Для события touchend - массив точек касания, которые были удалены с поверхности (то есть набор точек касания, соответствующих пальцам, которые больше не касаются поверхности). Вместе эти интерфейсы определяют относительно низкоуровневый набор функций, но при этом поддерживают многие виды взаимодействия на основе касания, включая привычные жесты с несколькими касаниями, включая пролистывание несколькими пальцами, вращение, сжатие и масштабирование.CSS свойство pointer-events позволяет контролировать события, при которых элемент может стать объектом события мыши. Если это свойство не задано, то к содержимому SVG будут применяться характеристики значения visiblePainted. Вдобавок к указанию того, что элемент не является объектом события мыши, значение none сообщает событию мыши проходить \"через\" элемент и обращаться к элементу, находящемуся \"под\" ним. Значения auto Элемент ведёт себя так же, как и если бы свойство pointer-events не было задано. В SVG это значение даёт такой же эффект, как и значение visiblePainted. none Элемент не может быть целью (target) cобытий мыши; тем не менее, целью событий мыши могут быть его потомки, если их pointer-events имеет какое-либо другое значение. В этом случае события мыши вызовут ожидаемое срабатывание обработчиков на этом родительском элементе на пути к/от потомк(у)/(а) во время фазы захвата/всплытия. visiblePainted Только SVG. Элемент может быть целью события мыши только когда свойство visibility установлено в значение visible и когда курсор мыши находится над внутренней частью (\"fill\") элемента, при этом свойство fill установлено в значение отличное от none, или над периметром элемента (\"stroke\"), при этом свойство stroke установлено в значение отличное от none. visibleFill Только SVG. Элемент может быть целью события мыши только когда свойство visibility установлено в значение visible и когда курсор мыши находится над внутренней частью (\"fill\") элемента. Значение свойства fill не влияет на обработку события. visibleStroke Только SVG. Элемент может быть целью события мыши только когда свойство visibility установлено в значение visible и когда курсор мыши находится над периметром элемента (\"stroke\"). Значение свойства stroke не влияет на обработку события. visible Только SVG. Элемент может быть целью события мыши только когда свойство visibility установлено в значение visible и когда курсор мыши находится над внутренней частью (\"fill\") или над периметром (\"stroke\") элемента. Значение свойств fill и stroke не влияют на обработку события. painted Только SVG. Элемент может быть целью события мыши только когда курсор мыши находится над внутренней частью (\"fill\") элемента, при этом свойство fill установлено в значение отличное от none, или над периметром элемента (\"stroke\"), при этом свойство stroke установлено в значение отличное от none. Значение свойства visibility не влияет на обработку события. fill Только SVG. Элемент может быть целью события мыши только когда курсор мыши находится над внутренней частью (\"fill\") элемента. Значение свойств visibility и fill не влияют на обработку события. stroke Только SVG. Элемент может быть целью события мыши только когда курсор мыши находится над периметром элемента (\"stroke\"). Значение свойств visibility и stroke не влияют на обработку события. all Только SVG. Элемент может быть целью события мыши только когда курсор мыши находится над внутренней частью (\"fill\") или над периметром (\"stroke\") элемента. Значение свойств visibility, fill и stroke не влияют на обработку события.',\r\n      },\r\n      {\r\n        'Как работают события мыши в мобильных браузерах? Зачем нужна задержка при клике и как ее избежать?':\r\n          'При использовании сенсорных экранов браузеры умышленно задействуют искусственную задержку длительностью около 300 мс между действием касания (например, нажатием на кнопку или ссылку) и фактической активацией клика. Эта задержка позволяет пользователям совершать даблтапы (например, для увеличения и уменьшения изображения) без случайной активации других элементов страницы. Работа над задержкой клика Если мы протестируем последовательность событий, передаваемых в браузер на сенсорных устройствах и включающих информацию о синхронизации (example5.html), мы увидим, что задержка в 300 мс появляется после события touchend: touchstart > [ touchmove ]+ > touchend > [300ms delay] > mouseover > (a single) mousemove > mousedown > mouseup > click. Итак, если наши скрипты реагируют на клик, от задержки браузера по умолчанию можно избавиться, прописав реакции на touchend или touchstart. Мы делаем это, отвечая на любое из этих событий. Touchstart используется для элементов интерфейса, которые должны запускаться сразу при касании экрана — например, кнопок управления в html-играх. https://www.youtube.com/watch?v=bjxjAESwejE&t=640s',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    DataAndTime: [\r\n      {\r\n        'Что такое UTC? В чем разница между GMT и UTC? Что такое Unix-время?':\r\n          'Нет разницы во времени между всемирным координированным временем и средним временем по Гринвичу 7:17 утра пятницы, всемирное координированное время (UTC) 7:17 пятница, среднее время по Гринвичу (GMT) Основное различие: UTC и GMT являются стандартами времени, которые различаются с точки зрения их происхождения и использования. Цитировать timeanddate.com: Разница между временем по Гринвичу и UTC: Среднее время по Гринвичу (GMT) часто перепутывают или путают с Всемирное координированное время (UTC). Но GMT - это часовой пояс, а UTC - это стандарт времени. Хотя на практике GMT и UTC имеют одинаковое текущее время, основное различие между ними: GMT - часовой пояс, официально используемый в некоторых европейских и африканских странах. Время может отображаться как в 24-часовом формате (0–24), так и в 12-часовом формате (1–12 часов дня/час). UTC - это не часовой пояс, а стандарт времени, который является основой для гражданских часовых поясов и часовых поясов во всем мире. Это означает, что ни одна страна или Территория UTC официально использует местное время. https://fooobar.com/questions/15211213/difference-between-utc-and-gmt',\r\n      },\r\n      {\r\n        'Какие существуют способы создания даты?':\r\n          'Для создания нового объекта типа Date используется один из синтаксисов: new Date() Создаёт объект Date с текущей датой и временем: var now = new Date(); alert( now ); new Date(milliseconds) Создаёт объект Date, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0. // 24 часа после 01.01.1970 GMT+0 var Jan02_1970 = new Date(3600 * 24 * 1000); alert( Jan02_1970 ); new Date(datestring) Если единственный аргумент – строка, используется вызов Date.parse (см. далее) для чтения даты из неё. new Date(year, month, date, hours, minutes, seconds, ms) Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице. Заметим: Год year должен быть из 4 цифр. Отсчёт месяцев month начинается с нуля 0. Например: new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 января 2011, 00:00:00 new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0 Дата задана с точностью до миллисекунд: var date = new Date(2011, 0, 1, 2, 3, 4, 567); alert( date ); // 1.01.2011, 02:03:04.567',\r\n      },\r\n      {\r\n        'Что такое RFC2822/ISO 8601? Как преобразовать дату из формата RFC2822/ISO 8601 в Unix-время?':\r\n          ' RFC 2822 - Internet Message Format Формат даты унаследован с 1970-х годов и выглядит так: Tue, 5 Feb 02 00:59:59 +0300. День недели с запятой и секунды с двоеточием можно опускать. Заметьте 2 цифры, отведенные на номер года в RFC 822 (увеличено до 4 цифр в RFC 1123, RFC 2822). Последнее слово определяет смещение локальной временной зоны относительно UTC в часах и минутах. Иногда используются сокращенные наименования временных зон вместо смещения, но это не рекомендуется (а в RFC 2822 явно запрещается). Для временной зоны UTC должно указываться смещение +0000. Смещение -0000 обозначает отсутствие информации о временной зоне..  ISO 8601 — международный стандарт, выпущенный организацией ISO (International Organization for Standardization), который описывает форматы дат и времени и даёт рекомендации для его использования в международном контексте. Название нормы — Data elements and interchange formats — Information interchange — Representation of dates and times. Значения даты и времени расположены в порядке от более к менее значимому. Каждое число (год, месяц, день, время) записывается с фиксированным числом знаков и, при необходимости, должно быть дополнено до него ведущими нулями. Например, время «7:40» должно быть записано как «07:40». В результате для каждого из ряда форматов дат и времен лексикографический порядок соответствует хронологическому, с исключением для отрицательных лет. https://ru.wikipedia.org/wiki/ISO_8601',\r\n      },\r\n      {\r\n        'Что произойдет если передать некорректное значение компоненты в new Date()?':\r\n          'в JavaScript указание некорректных компонентов даты и времени не приводит к ошибкам, они просто автоматически распределятся по остальным. Например: // число 44 распределится следующим образом: 44 - 31 = 13, 13 февраля 2019 newDate.setFullYear(2019, 01, 44); Этот приём можно использовать когда вам нужно получить дату, отличающуюся от данной на определённый промежуток времени. Примеры: // дата, которая будет больше newDate на 7 дней newDate.setDate(date1.getDate() + 7); // дата, которая будет меньше newDate на 120 секунд newDate.setSeconds(date1.getSeconds()-120); // так можно установить последнее число предыдущего месяца для newDate newDate.setDate(0);',\r\n      },\r\n      {\r\n        'Как получить текущие значения компонентов даты?':\r\n          'Для доступа к компонентам даты-времени объекта Date используются следующие методы: getFullYear() Получить год (из 4 цифр) getMonth() Получить месяц, от 0 до 11. getDate() Получить число месяца, от 1 до 31. getHours(), getMinutes(), getSeconds(), getMilliseconds() Получить соответствующие компоненты. Не getYear(), а getFullYear() Некоторые браузеры реализуют нестандартный метод getYear(). Где-то он возвращает только две цифры из года, где-то четыре. Так или иначе, этот метод отсутствует в стандарте JavaScript. Не используйте его. Для получения года есть getFullYear(). Дополнительно можно получить день недели: getDay() Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота). Все методы, указанные выше, возвращают результат для местной временной зоны. Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после \"get\" вставляется \"UTC\". Если ваше локальное время сдвинуто относительно UTC, то следующий код покажет разные часы: // текущая дата var date = new Date(); // час в текущей временной зоне alert( date.getHours() ); // сколько сейчас времени в Лондоне? // час в зоне GMT+0 alert( date.getUTCHours() ); Кроме описанных выше, существуют два специальных метода без UTC-варианта: getTime() Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе new Date(milliseconds). getTimezoneOffset() Возвращает разницу между местным и UTC-временем, в минутах. alert( new Date().getTimezoneOffset() ); // Для GMT-1 выведет 60',\r\n      },\r\n      {\r\n        'Как задать значение для компоненты даты?':\r\n          'Следующие методы позволяют устанавливать компоненты даты и времени: setFullYear(year [, month, date]) setMonth(month [, date]) setDate(date) setHours(hour [, min, sec, ms]) setMinutes(min [, sec, ms]) setSeconds(sec [, ms]) setMilliseconds(ms) setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC) Все они, кроме setTime(), обладают также UTC-вариантом, например: setUTCHours(). Как видно, некоторые методы могут устанавливать несколько компонентов даты одновременно, в частности, setHours. При этом если какая-то компонента не указана, она не меняется. Например: var today = new Date; today.setHours(0); alert( today ); // сегодня, но час изменён на 0 today.setHours(0, 0, 0, 0); alert( today ); // сегодня, ровно 00:00:00.',\r\n      },\r\n      {\r\n        'Как вычислить разность дат? Какие имеются особенности вычисления разности даты в TypeScript?':\r\n          'Разницу в днях между 2-мя датами в JavaScript можно получить следующим образом: Создать две переменные типа Date, передав обязательно даты как строку обернутую кавычками. Получить разницу между датами в миллисекундах. Применить деление, чтобы привести результат к дням. var date1 = new Date(\"7/11/2010\"); var date2 = new Date(\"12/12/2010\"); var timeDiff = Math.abs(date2.getTime() - date1.getTime()); var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24)); alert(diffDays); 1 2 3 4 5 var date1 = new Date(\"7/11/2010\"); var date2 = new Date(\"12/12/2010\"); var timeDiff = Math.abs(date2.getTime() - date1.getTime()); var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24)); alert(diffDays);',\r\n      },\r\n      {\r\n        'Какие существуют способы форматирования даты? Что такое локаль?':\r\n          'Форматирование и вывод дат Во всех браузерах, кроме IE10-, поддерживается новый стандарт Ecma 402, который добавляет специальные методы для форматирования дат. Это делается вызовом date.toLocaleString(локаль, опции), в котором можно задать много настроек. Он позволяет указать, какие параметры даты нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку. Пример с почти всеми параметрами даты и русским, затем английским (США) форматированием: var date = new Date(2014, 11, 31, 12, 30, 0); var options = { era: \"long\", year: \"numeric\", month: \"long\", day: \"numeric\", weekday: \"long\", timezone: \"UTC\", hour: \"numeric\", minute: \"numeric\", second: \"numeric\" }; alert( date.toLocaleString(\"ru\", options) ); // среда, 31 декабря 2014 г. н.э. 12:30:00 alert( date.toLocaleString(\"en-US\", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM Вы сможете подробно узнать о них в статье Intl: интернационализация в JavaScript, которая посвящена этому стандарту. Методы вывода без локализации: toString(), toDateString(), toTimeString() Возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему – читаемость человеком. Метод toString возвращает дату целиком, toDateString() и toTimeString() – только дату и время соответственно. var d = new Date(); alert( d.toString() ); // вывод, похожий на \"Wed Jan 26 2011 16:40:50 GMT+0300\" toUTCString() То же самое, что toString(), но дата в зоне UTC. toISOString() Возвращает дату в формате ISO Детали формата будут далее. Поддерживается современными браузерами, не поддерживается IE8-. var d = new Date(); alert( d.toISOString() ); // вывод, похожий на \"2011-01-26T13:51:50.417Z\" Если хочется иметь большую гибкость и кросс-браузерность, то также можно воспользоваться специальной библиотекой, например Moment.JS или написать свою функцию форматирования.  Локаль – первый и самый важный аргумент всех методов, связанных с интернационализацией. Локаль описывается строкой из трёх компонентов, которые разделяются дефисом: Код языка. Код способа записи. Код страны. На практике не всегда указаны три, обычно меньше: ru – русский язык, без уточнений. en-GB – английский язык, используемый в Англии (GB). en-US – английский язык, используемый в США (US). zh-Hans-CN – китайский язык (zh), записываемый упрощённой иероглифической письменностью (Hans), используемый в Китае.Все методы принимают локаль в виде строки или массива, содержащего несколько локалей в порядке предпочтения. Если локаль не указана или undefined – берётся локаль по умолчанию, установленная в окружении (браузере).localeMatcher – вспомогательная настройка, которую тоже можно везде указать, она определяет способ подбора локали, если желаемая недоступна. У него два значения: \"lookup\" – означает простейший порядок поиска путём обрезания суффикса, например zh-Hans-CN → zh-Hans → zh → локаль по умолчанию. \"best fit\" – использует встроенные алгоритмы и предпочтения браузера (или другого окружения) для выбора подходящей локали. По умолчанию стоит \"best fit\". Если локалей несколько, например [\"zh-Hans-CN\", \"ru-RU\"] то localeMatcher пытается подобрать наиболее подходящую локаль для первой из списка (китайская), если не получается – переходит ко второй (русской) и так далее. Если ни одной не нашёл, например на компьютере не совсем поддерживается ни китайский ни русский, то используется локаль по умолчанию. Как правило, \"best fit\" является здесь наилучшим выбором.',\r\n      },\r\n      {\r\n        'Можно ли сконвертировать дату в JSON?':\r\n          'JSON сам по себе не определяет, как даты должны быть представлены, но JavaScript делает. Вы должны использовать формат , испускаемый Date«S toJSONметодом: 2012-04-23T18:25:43.511Z Вот почему: Это читается человеком, но также кратко Сортирует правильно Он включает доли секунды, которые могут помочь восстановить хронологию Соответствует ISO 8601 ISO 8601 был признан во всем мире уже более десяти лет. ISO 8601 одобрен W3C , RFC3339 и XKCD При этом каждая библиотека дат, когда-либо написанная, может понимать «миллисекунды с 1970 года».',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Literatura: [\r\n      {\r\n        'Изучить книгу \"Code Craft: The Practice of Writing Excellent Code\" Pete Goodliffe (\"Ремесло программиста\" Питера Гудлифа). Уделите внимание разделу \"резюме\" в конце каждой главы, а так же вопросам. На собеседовании будут задаваться случайные вопросы из разных глав.':\r\n          '',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    React: [\r\n      {\r\n        'Что такое React?':\r\n          'React — это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный UI из маленьких изолированных кусочков кода, называемых «компонентами».',\r\n      },\r\n      {\r\n        'Что такое React Element? Как его можно создать? Из чего он состоит? Что будет, если передать булевые, null или undefined значения в children?':\r\n          'Элементы — мельчайшие кирпичики React-приложений. Элемент описывает то, что вы хотите увидеть на экране: const element = <h1>Hello, world</h1>; В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам. Простыми словами, React элемент описывает то что вы хотите увидеть экране. А если не простыми, то React элемент описывает узел DOM в виде объекта. Обратите внимание на то, что я использовал слово описывает. Важно, что React элемент это не то что вы увидите на экране, а он описывает то что вы увидите. Для этого есть несколько причин. Первая причина заключается в том, что JavaScript объекты достаточно лёгкие и React может создавать и уничтожать их без слишком большого оверхэда. Вторая причина заключается в том, что React может анализировать объект и анализировать настоящий DOM, а затем обновлять DOM только в том месте, где произошли изменения. Это даёт некоторые плюсы в плане производительности.',\r\n      },\r\n      {\r\n        'Что такое React Component? Что делают конструкторы в родительских классах реакт компонент? Когда надо вызывать super, а когда нет?':\r\n          'Проще всего объявить React-компонент как функцию: function Welcome(props) { return <h1>Привет, {props.name}</h1>; } Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями. Ещё компоненты можно определять как классы ES6: class Welcome extends React.Component { render() { return <h1>Привет, {this.props.name}</h1>; } } С точки зрения React, эти два компонента эквивалентны. Ключевое слово super используется для вызова функций, принадлежащих родителю объекта.В конструкторе ключевое слово super() используется как функция, вызывающая родительский конструктор. Её необходимо вызвать до первого обращения к ключевому слову this в теле конструктора. Ключевое слово super также может быть использовано для вызова функций родительского объекта. ',\r\n      },\r\n      {\r\n        'Что такое JSX и зачем он нужен? Почему атрибуты в JSX пишутся, используя camelCase (например, tabIndex, а не tabindex)? Почему className, а не class? Почему название компоненты, которая используется в JSX, нужно писать с большой буквы? В чём проблема следующего кода <p>{items.length && <El items={items} />}</p>?Написать аналог с React.createElement: <OuterComponent color=\"black\" disabled> <InnerComponent hidden={false} /> <div>  Div text content </div> </OuterComponent>':\r\n          'Это JSX — расширение языка JavaScript. React исходит из принципа, что логика рендеринга неразрывно связана с прочей логикой UI: с тем, как обрабатываются события, как состояние изменяется во времени и как данные готовятся к отображению. Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику в разные файлы, React разделяет ответственность с помощью слабо связанных единиц, называемых «компоненты», которые содержат и разметку, и логику. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript. Из этого следует, что JSX можно использовать внутри выражений if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. Например, class становится className в JSX, а tabindex становится tabIndex.Babel компилирует JSX в вызовы React.createElement(). const element = React.createElement( \"h1\", {className: \"greeting\"}, \"Привет, мир!\"); React.createElement() проводит некоторые проверки с целью выявить баги в коде, но главное — создаёт объект похожий на такой: // Примечание: этот код несколько упрощён. const element = { type: \"h1\", props: { className: \"greeting\", children: \"Привет, мир!\" } }; Эти объекты называются React-элементами. Можно сказать, что они описывают результат, который мы хотим увидеть на экране. React читает эти объекты и использует их, чтобы конструировать и поддерживать DOM.',\r\n      },\r\n      {\r\n        'Что такое Virtual DOM и зачем он нужен?':\r\n          'Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием. Такой подход и делает API React декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а React добивается, чтобы DOM соответствовал этому состоянию. Это абстрагирует манипуляции с атрибутами, обработку событий и ручное обновление DOM, которые в противном случае пришлось бы использовать при разработке приложения. Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.',\r\n      },\r\n      {\r\n        'Что такое state и props у компонента? Как обновить state? Почему не стоит это делать через прямую запись в this.state? Если передать в setState не все свойства, которые до этого уже были в стейте, то будут ли удалены те, что не переданы? В каких случаях стоит хранить значения в стейте компоненты, а в каких случаях в инстансе? Как правильно обновлять state на основе предыдущего значения state? Какие могут при этом возникнуть проблемы? Что такое top-down data flow? Что является основным механизмом синхронизации нескольких компонент?':\r\n          'props (намеренно сокращённо от англ. «properties» — свойства) и state — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: props передаётся в компонент (служат как параметры функции), в то время как state находится внутри компонента (по аналогии с переменными, которые объявлены внутри функции). setState() добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера. Думайте о setState(), как о запросе, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент updater  Первым аргументом передаётся функция updater, которая имеет следующий вид: (state, props) => stateChange state — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из state и props. Предположим, что мы хотели бы увеличить значение состояния с помощью props.step: this.setState((state, props) => { return {counter: state.counter + props.step}; }); Как state, так и props, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с state. Второй параметр в setState() — необязательный колбэк, вызываемый после выполнения setState и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать componentDidUpdate(). В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. Также не важно, как был создан определённый компонент — с помощью функции или класса. Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других. Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов: <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2> Своё состояние можно передать и другому пользовательскому компоненту: <FormattedDate date={this.state.date} /> Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения: function FormattedDate(props) { return <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>; } Посмотреть на CodePen Этот процесс называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов. Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.',\r\n      },\r\n      {\r\n        'props.children Что это такое? Когда может быть полезным? Что позволяет делать React.Children API?':\r\n          'Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод: function FancyBorder(props) { return ( <div className={\"FancyBorder FancyBorder-\" + props.color}> {props.children} </div> ); } Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX: function WelcomeDialog() { return ( <FancyBorder color=\"blue\"> <h1 className=\"Dialog-title\"> Добро пожаловать </h1> <p className=\"Dialog-message\"> Спасибо, что посетили наш космический корабль! </p> </FancyBorder> ); } Посмотреть на CodePen Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри <div>, все переданные элементы отображаются в конечном выводе. React.Children предоставляет функции для работы с непрозрачной структурой данных this.props.children. React.Children.map React.Children.map(children, function[(thisArg)]) Вызывает функцию для каждого непосредственного потомка, содержащегося в children передавая их по очереди в thisArg. Если children — это массив, он будет пройден, и функция будет вызвана для каждого потомка в массиве. Если children равен null или undefined, этот метод вернёт null или undefined, а не массив. Примечание Если children — это Fragment, он будет рассматриваться как целый потомок, а элементы внутри не будут пройдены. React.Children.forEach React.Children.forEach(children, function[(thisArg)]) Похож на React.Children.map(), но не возвращает массив. React.Children.count React.Children.count(children) Возвращает общее количество компонентов в children, равное числу раз которое будет вызван обратный вызов, переданный в map или forEach. React.Children.only React.Children.only(children) Проверяет, что у children есть только один потомок (React элемент), и возвращает его. Иначе этот метод выдаёт ошибку. Примечание: React.Children.only() не принимает возвращаемое значение React.Children.map(), потому что это массив, а не React-элемент. React.Children.toArray React.Children.toArray(children) Возвращает непрозрачную структуру данных children в виде плоского массива с ключами, заданные каждому дочернему элементу. Полезно, если вы хотите манипулировать коллекциями потомков в ваших методах рендера, особенно если вы хотите отсортировать или извлечь часть this.props.children перед её передачей куда-либо. Примечание: React.Children.toArray() изменяет ключи, чтобы сохранить семантику вложенных массивов, когда делает плоским список дочерних элементов. То есть toArray ставит префикс перед каждым ключом в возвращаемом массиве, так что ключ каждого элемента находится в области входного массива, содержащего его.',\r\n      },\r\n      {\r\n        'Component Lifecycle Что это такое? Когда какие методы вызываются? В каком порядке? Как и в каких случаях использовать те или иные методы жизненного цикла?':\r\n          'Каждый компонент имеет несколько «методов жизненного цикла». Переопределение такого метода позволяет выполнять код на конкретном этапе этого процесса. Монтирование При создании экземпляра компонента и его вставке в DOM, следующие методы вызываются в установленном порядке: constructor() static getDerivedStateFromProps() render() componentDidMount().  Обновление происходит при изменении пропсов или состояния. Следующие методы вызываются в установленном порядке при повторном рендере компонента: static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate().  Размонтирование Этот метод вызывается при удалении компонента из DOM: componentWillUnmount() Обработка ошибок Следующие методы вызываются, если произошла ошибка в процессе рендеринга, методе жизненного цикла или конструкторе любого дочернего компонента. static getDerivedStateFromError() componentDidCatch(). componentDidMount() вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов. Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount(). componentDidUpdate() вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.componentDidUpdate(prevProps) { // Популярный пример (не забудьте сравнить пропсы): if (this.props.userID !== prevProps.userID) { this.fetchData(this.props.userID); } } В componentDidUpdate() можно вызывать setState(), однако его необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл. Вызов setState() влечет за собой дополнительный рендер, который незаметен для пользователя, но может повлиять на производительность компонента.componentWillUnmount() вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount(). https://ru.reactjs.org/docs/react-component.html',\r\n      },\r\n      {\r\n        'Что должен делать метод render? Почему необходимо держать этот метод чистым?':\r\n          'render() — единственный обязательный метод в классовом компоненте. При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React. Обычно создаётся с помощью JSX. Указывает React, что рендерить: DOM-узел или пользовательский компонент. Например, <div /> или <MyComponent />. Массивы и фрагменты. Возвращает несколько элементов из render(). Подробнее про фрагменты. Порталы. Рендерит несколько дочерних элементов в другое поддерево DOM. Подробнее про порталы. Строки и числа. Рендерит текстовые DOM-узлы. Booleans или null. Ничего не рендерит. (Обычно необходим для поддержки паттерна return test && <Child />, где test — логическое значение.) Функция render() должна быть чистой. Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же результат, не взаимодействует напрямую с браузером. Взаимодействовать с браузером необходимо в componentDidMount() или других методах жизненного цикла. Чистый render() делает компонент понятным.',\r\n      },\r\n      {\r\n        'Что такое HOC? Когда хоки могут быть полезны?':\r\n          'компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. const EnhancedComponent = higherOrderComponent(WrappedComponent); Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент. Компонент высшего порядка в React это паттерн, используемый для того, чтобы делить функционал между компонентами без повторения кода. Такие компоненты, по факту, не совсем являются компонентами, это скорее функции. Такая функция берёт компонент как аргумент и отдаёт компонент. Она переделывает компонент в другой компонент и добавляет дополнительные данные или фунционал.Такие компоненты это функции, которые берут компонент как аргумент и возвращают компонент. Это говорит о том, что HOC будет всегда иметь форму как тут: import React from \"react\"; const higherOrderComponent = (WrappedComponent) => { class HOC extends React.Component { render() { return <WrappedComponent />; } } return HOC; }; Тут higherOrderComponent это функция, которая берёт компонент под названием WrappedComponent как аргумент. Мы создаём новый компонент под названием HOC, который отдаёт из рендера <WrappedComponent />. Пока тут нет никакого функционала, этот пример просто описывает общий партерн, которому должна следовать любая функция HOC. https://ru.reactjs.org/docs/higher-order-components.html',\r\n      },\r\n      {\r\n        'Что такое React Fragment? Для чего он нужен? Как его использовать?':\r\n          'Компонент React.Fragment позволяет возвращать несколько элементов в методе render() без создания дополнительного элемента DOM: render() { return ( <React.Fragment> Какой-то текст. <h2>Заголовок</h2> </React.Fragment> ); } Вы также можете использовать его сокращённый синтаксис <></>.',\r\n      },\r\n      {\r\n        'Performance Когда передача инлайн-коллбека ухудшает производительность и почему? Пример: <LoginButton onClick={(e) => this.handleClick(e, user)}>':\r\n          'https://habr.com/ru/company/tuturu/blog/348584/',\r\n      },\r\n      {\r\n        'refs Что это такое? Зачем нужны? Как их использовать? Что делает и зачем нужен метод React.forwardRef? Почему refs стоит использовать умеренно?':\r\n          'Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе. В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через пропсы. Чтобы модифицировать потомка, вы должны заново отрендерить его с новыми пропсами. Тем не менее, могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент, обойдя обычный поток данных. Подлежащий изменениям дочерний элемент может быть как React-компонентом, так и DOM-элементом. React предоставляет лазейку для обоих случаев. Когда использовать рефы Ситуации, в которых использования рефов является оправданным: Управление фокусом, выделение текста или воспроизведение медиа. Императивный вызов анимаций. Интеграция со сторонними DOM-библиотеками. Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом. Например, вместо того чтобы определять методы open() и close() в компоненте Dialog, лучше передавать ему проп isOpen. Рефы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента. class MyComponent extends React.Component { constructor(props) { super(props); this.myRef = React.createRef(); } render() { return <div ref={this.myRef} />; } }Когда реф передаётся элементу в методе render, ссылка на данный узел доступна через свойство рефа current. const node = this.myRef.current; Значение рефа отличается в зависимости от типа узла: Когда атрибут ref используется с HTML-элементом, свойство current созданного рефа в конструкторе с помощью React.createRef() получает соответствующий DOM-элемент. Когда атрибут ref используется с классовым компонентом, свойство current объекта-рефа получает экземпляр смонтированного компонента. Нельзя использовать ref атрибут с функциональными компонентами, потому что для них не создаётся экземпляров.По умолчанию нельзя использовать атрибут ref с функциональными компонентами, потому что для них не создаётся экземпляров. Если вам нужен реф на функциональный компонент, можете воспользоваться forwardRef (возможно вместе с useImperativeHandle), либо превратить его в классовый компонент.Перенаправление рефов позволяет взять ref из атрибутов компонента, и передать («перенаправить») его одному из дочерних компонентов. В данном примере мы используем React.forwardRef в компоненте FancyButton, чтобы получить реф и передать его в дочерний DOM-элемент button. const FancyButton = React.forwardRef((props, ref) => ( <button ref={ref} className=\"FancyButton\"> {props.children} </button> )); // Теперь реф будет указывать непосредственно на DOM-узел button: const ref = React.createRef(); <FancyButton ref={ref}>Click me!</FancyButton>;Рассмотрим этот пример пошагово: Мы создаём реф, вызвав React.createRef и записываем его в переменную ref. Мы передаём переменную ref в <FancyButton ref={ref}>, указывая её в JSX-атрибуте. React передаёт ref в функцию (props, ref) => ... внутри forwardRef в качестве второго аргумента. Мы передаём аргумент ref дальше в <button ref={ref}>, указывая его в JSX-атрибуте. После привязки рефа ref.current будет указывать на DOM-узел <button>.',\r\n      },\r\n      {\r\n        'Controlled и uncontrolled компоненты Что это такое? Как происходит работа с инпутами? Как задать дефолтное значение для инпута в uncontrolled компоненте?':\r\n          'В HTML элементы формы, такие как <input>, <textarea> и <select>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState() Мы можем скомбинировать оба подхода и сделать состояние React-компонента «единственным источником правды». Тогда React-компонент будет рендерить форму и контролировать её поведение в ответ на пользовательский ввод. Значение элемента формы input в этом случае будет контролировать React, а сам элемент будет называться «управляемый компонент». В управляемом компоненте, данные формы обрабатываются React-компонентом. В качестве альтернативы можно использовать неуправляемые компоненты. Они хранят данные формы прямо в DOM. Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф. Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты. На этапе рендеринга атрибут value полей ввода переопределяет значение в DOM. С неуправляемым компонентом зачастую нужно, чтобы React определил первоначальное значение, но впоследствии ничего не делал с ним. В этом случае необходимо определить атрибут defaultValue вместо value. https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/',\r\n      },\r\n      {\r\n        'Что такое Context и когда может быть полезен?':\r\n          'Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях. В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, этот способ может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева. React.createContext - возвращает пару - Provider и Consumer Оборачиваем наше приложение в <Provider value={value}></Provider> В качестве value передадим то что мы хотим сделать доступным в нашем приложении. Теперь заходим нужный компонент, импортируем в него Consumer и при помощи его достаем данные из Provider. <MyContext.Consumer> {value => /* отрендерить что-то, используя значение контекста */} </MyContext.Consumer>. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента',\r\n      },\r\n      {\r\n        'Portals Что это такое? Зачем нужны? Как использовать? Как будет работать контекст и event bubbling в случае с порталами?':\r\n          'Портал - компонент, который рендерит свое содержимое в другую часть ДОМ дерева, за пределы корневого дива. Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. ReactDOM.createPortal(child, container) Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент. Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла: render() { // React монтирует новый div и рендерит в него дочерние элементы return ( <div> {this.props.children} </div> ); } Но иногда требуется поместить потомка в другое место в DOM: render() { // React *не* создаёт новый div. Он рендерит дочерние элементы в `domNode`. // `domNode` — это любой валидный DOM-узел, находящийся в любом месте в DOM. return ReactDOM.createPortal( this.props.children, domNode ); } Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.Перехват событий, всплывающих от портала к родительскому компоненту, позволяет создавать абстракции, которые не спроектированы специально под порталы. Например, вы отрендерили компонент <Modal />. Тогда его события могут быть перехвачены родительским компонентом, вне зависимости от того, был ли <Modal /> реализован с использованием порталов или без них. Несмотря на то, что портал может быть где угодно в дереве DOM, он ведет себя как обычный дочерний элемент React во всех отношениях. Такие функции, как контекст, работают как и ранее, независимо от того, является ли дочерний элемент порталом, поскольку портал все еще существует в дереве React независимо от его положения в дереве DOM. Это же касается и всплытия события. Событие, созданное внутри портала, будет распространяться к предкам в объемлющем дереве React, даже если они не являются предками в дереве DOM. https://www.youtube.com/watch?v=xcWaYD4gZAs',\r\n      },\r\n      {\r\n        'Что такое Error Boundaries? Зачем они нужны? Как ими пользоваться? Будут ли \"пойманы\" в catch блоке ошибки, возникающие при рендере InnerComponent? Почему? function OuterComponent() {  try {return <InnerComponent />; } catch (error) {  handleError(error); } }':\r\n          'Ошибка JavaScript где-то в коде UI не должна прерывать работу всего приложения. Чтобы исправить эту проблему для React-пользователей, React 16 вводит концепцию «предохранителя» (error boundary). Предохранители — это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов, сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов. Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов, расположенных под ними.Классовый компонент является предохранителем, если он включает хотя бы один из следующих методов жизненного цикла: static getDerivedStateFromError() или componentDidCatch(). Используйте static getDerivedStateFromError() при рендеринге запасного UI в случае отлова ошибки. Используйте componentDidCatch() при написании кода для журналирования информации об отловленной ошибке. Обратите внимание, что предохранители отлавливают ошибки исключительно в своих дочерних компонентах. Предохранитель не сможет отловить ошибку внутри самого себя. Если предохранителю не удаётся отрендерить сообщение об ошибке, то ошибка всплывает до ближайшего предохранителя, расположенного над ним в дереве компонентов. Этот аспект их поведения тоже напоминает работу блоков catch {} в JavaScript.',\r\n      },\r\n    ],\r\n  },\r\n];\r\nexport default Junior02;\r\n","const Junior03 = [\r\n  {\r\n    WebpackAndOthers: [\r\n      {\r\n        'Что такое Webpack? Для чего он нужен? Что такое точка входа и граф зависимостей? Что такое лоадеры? Для чего они нужны? Что такое плагины? Для чего они нужны?':\r\n          'Webpack — это инструмент, позволяющий скомпилировать, например, JavaScript модули в единый JS-файл. Webpack также известен как сборщик модулей. При большом количестве файлов он создает один объемный файл (или несколько файлов) для запуска вашего приложения. Он также способен выполнять множество иных операций: помогает собрать воедино ваши ресурсы следит за изменениями и повторно выполняет задачи может выполнить транспиляцию JavaScript следующего поколения до более старого стандарта JavaScript (ES5) с помощью Babel, что позволит использовать новейшие функции JavaScript, не беспокоясь о том, поддерживает их браузер или нет может выполнить транспиляцию CoffeeScript в JavaScript может конвертировать встроенные изображения в data:URI позволяет использовать require() для CSS файлов может запустить webpack-dev-server (в нём встроен локальный сервер и livereload (“живая перезагрузка браузера”)) может работать с Hot Module Replacement (замена горячего модуля) может разделить выходной файл (output file) на несколько файлов, чтобы избежать медленной загрузки страницы из-за большого размера JS-файла может выполнить Tree Shaking Webpack не ограничивается одним лишь фронтендом, его также успешно применяют в бэкенд разработке на Node.js.',\r\n      },\r\n      {\r\n        'Что такое таск-раннеры и чем они отличаются от бандлеров?':\r\n          'Таск-менеджер — инструмент для автоматизации задач. В конфигурации раннеров можно записать имена этих задач; функцию, которая их выполняет; плагины для ускорения стандартных действий, но сами задачи могут быть произвольными. Например: Задачи для деплоя (zip проекта, загрузка проекта на удаленный сервер и тп) Задачи по сборке проекта (минификация, оптимизация, проверка кода на валидность и тп) Задачи для миграции данных и т.д. Примеры таких инструментов — grunt и gulp. Система сборки — это инструмент, который решает только одну типовую задачу сборки проекта на java script, в которую входят: конкатенация, проверка кода на валидность, минификация кода, и тд. К подобным инструментам относятся Webpack, Broccoli, Brunch, Browserify и другие. Все подобные frontend-задачи можно автоматически выполнять при помощи других средств: к примеру, с помощью npm run, о котором мы также поговорим в статье. Материал предоставлен компанией WaveAccess, узнайте больше на waveaccess.ru Таск раннер - выполняет какие то задачи, бандлер - собирают программу',\r\n      },\r\n      {\r\n        'Что такое препроцессор? В чем разница между понятиями \"язык\" и \"препроцессор\"? Зачем нужны CSS и HTML препроцессоры?':\r\n          'CSS препроцессор (от англ. CSS preprocessor) — это надстройка над CSS, которая добавляет ранее недоступные возможности для CSS, с помощью новых синтаксических конструкций. Основная задача препроцессора — это предоставление удобных синтаксических конструкций для разработчика, чтобы упростить, и тем самым, ускорить разработку и поддержу стилей в проектах. CSS препроцессоры преобразуют код, написанный с использованием препроцессорного языка, в чистый и валидный CSS-код. При помощи препроцессоров вы можете писать код, который нацелен на: Читабельность для человека Структурированность и логичность Производительность',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    workWithData: [\r\n      {\r\n        'Что такое Symbol? Какие примеры использования есть?':\r\n          'Символ (анг. Symbol) — это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов. Символьный объект (анг. symbol object) — это объект-обёртка (англ. wrapper) для примитивного символьного типа. Symbol([описание]) Параметры описание Необязательный Необязательный, строка. Описание символа, которое может быть использовано во время отладки, но не для доступа к самому символу. Создаются новые символы с помощью функции Symbol(): // Создаём новый символ - id let id = Symbol(); При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода: // Создаём символ id с описанием (именем) \"id\" let id = Symbol(\"id\"); Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет. Метод Object.getOwnPropertySymbols() возвращает массив символов и позволяет получить символьные свойства конкретного объекта. Следует заметить, что при инициализации объекты не получают символьных свойств, так что этот массив будет пуст, пока вы не зададите ему какое-либо символьное свойство. В добавок к вашим собственным символам, JavaScript имеет несколько встроенных символов, представляющих внутренние механизмы языка, которые не были доступны разработчикам в версиях ECMAScript 5 и более ранних. Эти символы доступны посредством следующих свойств: Итерационные символы Symbol.iterator Метод, возвращающий итератор по умолчанию для объекта. Используется конструкцией for...of. Символы регулярных выражений Symbol.match Метод для сопоставления объекта со строкой, также используемый для определения возможности объекта выступать в качестве регулярного выражения. Используется функцией String.prototype.match(). Symbol.replace Метод, заменяющий совпавшие подстроки в строке. Используется функцией String.prototype.replace(). Symbol.search Метод, возвращающий индекс вхождения подстроки, соответствующей регулярному выражению. Используется функцией String.prototype.search(). Symbol.split Метод, разбивающий строку на части в местах, соответствующих регулярному выражению. Используется функцией String.prototype.split(). Другие символы Symbol.hasInstance Метод, определяющий, распознает ли конструктор некоторый объект как свой экземпляр. Используется оператором instanceof. Symbol.isConcatSpreadable Булево значение, показывающее, должен ли объект быть сведен к плоскому представлению (англ. flatten) в виде массива его элементов функцией Array.prototype.concat(). Symbol.unscopables Массив строковых имен свойств. Позволяет скрыть свойства от инструкции with (прежде всего для обратной совместимости). Symbol.species Метод, определяющий конструктор для порождённых объектов. Symbol.toPrimitive Метод, преобразующий объект в примитив (примитивное значение). Symbol.toStringTag Строковое значение, используемое в качестве описания объекта по умолчанию. Используется функцией Object.prototype.toString() Методы Symbol.for(key) Ищет существующие символы по заданному ключу и возвращает его, если он найден. В противном случае создается новый символ для данного ключа в глобальном реестре символов. Symbol.keyFor(sym) Получает по разделямому символу его ключ из глобального реестра символов.',\r\n      },\r\n      {\r\n        'В чем отличия между массивами и массивоподобными объектами? Привести примеры массивоподобных объектов.':\r\n          'Знаменитые HTMLCollection (документация ) и arguments ( документация)-это массивоподобные объекты, которые создаются автоматически. Некоторые быстрые массивоподобные (например, HTMLCollection ) различия между примерами реальных массивов: var realArray = [\"value1\", \"value2\"]; var arrayLike = document.forms; Сходные элементы: Длина getter такая же: arrayLike.length; // returns 2; realArray.length; // returns 2; //there are 2 forms in the DOM. Индексированный getter-это то же самое: arrayLike[0]; // returns an element. realArray[0]; // returns an element. (\"value\") Они оба objects : typeof arrayLike; // returns \"object\" typeof realArray; // returns \"object\" Различия: В массивах , подобных join() , concat(), includes() и т.д., методы не являются функциями: arrayLike.join(\", \"); // returns Uncaught TypeError: arrayLike.join is not a function (also relevant to `concat()`, `includes()` etc.) realArray.join(\", \"); // returns \"value1, value2\" Массив, как на самом деле не массив: Array.isArray(arrayLike); //returns \"false\" Array.isArray(realArray); //returns \"true\" В array like вы не можете установить свойство length: arrayLike.length = 1; arrayLike.length; //return 2; //there are 2 forms in the DOM. realArray.length = 1; realArray.length; //return 1;',\r\n      },\r\n      {\r\n        'Деструктуризация Переименование свойств (например, как положить значение свойства foo объекта { foo: \"foo\", ... } в переменную bar), дефолтные параметры, вложенные дефолты.':\r\n          'В JavaScript есть две чаще всего используемые структуры данных – это Object и Array. Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам, а массивы – хранить упорядоченные коллекции данных. Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности. Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее. Деструктуризация позволяет разбивать объект или массив на переменные при присвоении. Полный синтаксис для объекта: let {prop : varName = default, ...rest} = object Свойства, которые не были упомянуты, копируются в объект rest. Полный синтаксис для массива: let [item1 = default, item2, ...rest] = array Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest. Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.',\r\n      },\r\n      {\r\n        'Какие значения примут переменные a и b в каждом случае? function f({ a, b = 0 } = { a: \"\" }) {// ..} f({ a: \"yes\" }) f() f({})':\r\n          'function f({ a, b = 0 } = { a: \"\" }) { console.log(`its a - ${a}, its b - ${b}`); } undefined f({ a: \"yes\" }) VM198:2 its a - yes, its b - 0 undefined f() VM198:2 its a - , its b - 0 undefined f({}) VM198:2 its a - undefined, its b - 0',\r\n      },\r\n      {\r\n        'Утечки памяти - что это? Когда они могут возникать? Как их находить и устранять?':\r\n          'Утечка памяти — память, которая больше не требуется приложению, но по какой-то причине не возвращается операционной системе или пулу доступной памяти (примечание переводчика: в кучу). Главной причиной утечек памяти в языках со сборщиками мусора являются нежелательные ссылки. 1: Случайные глобальные переменные Одной из целей, стоявших при разработке JavaScript, было создать похожий на Java язык, но настолько нестрогий, чтобы с ним могли работать даже новички. Одним из послаблений языка стала обработка необъявленных переменных: обращение к такой переменной создаст новую переменную в глобальном объекте. 2: Забытые таймеры и коллбэки Довольно часто встречается подобное использование функции setInterval: var someResource = getData(); setInterval(function() { var node = document.getElementById(\"Node\"); if(node) { // Сделаем что-нибудь с node и someResource. node.innerHTML = JSON.stringify(someResource)); } }, 1000); Этот пример показывает, чем вредны подвисшие таймеры (обращающиеся к уже не нужным узлам или данным). Если удалить узел, весь блок внутри функции-обработчика станет ненужным. Но, до тех пор, пока setInterval активен, обработчик тоже активен и не может быть очищен сборщиком мусора (ведь для этого надо сперва остановить интервал). А значит, его зависимости тоже не могут быть удалены из памяти. Получим, что someResource, хранящий, вероятно, большой объём данных, не может быть очищен сборщиком мусора. 3: Ссылки на удалённые из DOM элементы Иногда полезно хранить DOM-узлы внутри структур данных. Предположим, вы хотите точечно обновить содержимое нескольких строк в таблице. Имеет смысл сохранить ссылку на каждый DOM-ряд в словаре или массиве. В этом случае на один и тот же DOM-элемент будут указывать две ссылки — одна в DOM-дереве, а вторая в словаре. Если в будущем вы решите удалить эти строки, вам понадобится сделать и ту, и другую ссылку недостижимыми. 4: Замыкания Основополагающей частью JavaScript являются замыкания: функции, получающие переменные из родительских областей видимости. Разработчики Meteor обнаружили ситуацию, при которой из-за особенностей реализации среды исполнения JavaScript можно создать утечку памяти подобным хитрым способом https://habr.com/ru/post/309318/  Chrome предоставляет набор инструментов для профилирования расхода памяти в JavaScript. Для работы с памятью предназначены два важнейших инструмента: вкладка timeline и вкладка профилей.',\r\n      },\r\n      {\r\n        'Какие есть способы хранения информации на клиенте? В каких случаях какой способ лучше использовать? Какие у каждого способа есть особенности?':\r\n          'Хранение данных непосредственно в браузере обладает множеством преимуществ, основное из которых это быстрый и независимый от сети доступ к “базе данных”. На данный момент есть 4 активных метода для этого (плюс один устаревший): Куки Локальное хранилище Сессионное хранилище IndexedDB WebSQL (устаревшее) Преимущества куки Их можно использовать для коммуникации с сервером Мы можем определить для куки срок их автоматического окончания вместо того, чтобы удалять вручную. Недостатки куки Они добавляются к загрузке страницы документа Они могут хранить небольшое количество данных Они могут содержать только строки. Потенциальные проблемы с безопасностью. Это метод не рекомендуется для хранения данных на клиенте с момента появления Web Storage API (локальное и сессионное хранилище). Поддержка в браузерах У куки есть базовая поддержка во всех больших браузерах. Преимущества локального хранилища Предлагает более простой и интуитивный интерфейс хранения данных . Более безопасно для хранения данных на клиенте. Позволяет хранить больше данных (все 3 пункта — в сравнении с куки). Недостатки локального хранилища Позволяет хранить только строки, он синхронный. Преимущества IndexedDB Могут обрабатывать более сложные структурированные данные. Может работать с разными “базами данными” и “таблицами” внутри каждой “базы данных”. Больше объем хранения. Больше контроля по взаимодействию с хранилищем. Недостатки IndexedDB Более сложное по сравнению с Web Storage API.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    JS: [\r\n      {\r\n        'Зачем нужны регулярные выражения?':\r\n          'Сравнение с шаблоном: Регулярные выражения отлично помогают определять, соответствует ли строка тому или иному формату – например, телефонному номеру, адресу электронной почты или номеру кредитной карты. Замена: При помощи регулярных выражений легко находить и заменять шаблоны в строке. Так, выражение text.replace(/s+/g, \" \") заменяет все пробелы в text, например, \" \\n\\t \", одним пробелом. Извлечение: При помощи регулярных выражений легко извлекать из шаблона фрагменты информации. Например, name.matches(/^(Mr|Ms|Mrs|Dr).?s/i)[1] извлекает из строки обращение к человеку, например, \"Mr\" из \"Mr. Schropp\". Портируемость: Почти в любом распространенном языке программирования есть своя библиотека регулярных выражений. Синтаксис в основном стандартизирован, поэтому вам не придется переучиваться регулярным выражениям при переходе на новый язык. Код: Когда пишете код, можно пользоваться регулярными выражениями для поиска информации в файлах; так, в Atom для этого предусмотрен find and replace, а в командной строке — ack. Четкость и лаконичность: Если вы с регулярными выражениями на «ты», то сможете выполнять весьма нетривиальные операции, написав минимальный объем кода.',\r\n      },\r\n      {\r\n        'Какие методы есть у инстансов регулярных выражений в JS?':\r\n          'regexp.exec(str) Метод regexp.exec(str) ищет совпадение с regexp в строке str. В отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке. Он ведёт себя по-разному в зависимости от того, имеет ли регулярное выражение флаг g. Если нет g, то regexp.exec(str) возвращает первое совпадение в точности как str.match(regexp). Такое поведение не даёт нам ничего нового. Но если есть g, то: Вызов regexp.exec(str) возвращает первое совпадение и запоминает позицию после него в свойстве regexp.lastIndex. Следующий такой вызов начинает поиск с позиции regexp.lastIndex, возвращает следующее совпадение и запоминает позицию после него в regexp.lastIndex. …И так далее. Если совпадений больше нет, то regexp.exec возвращает null, а для regexp.lastIndex устанавливается значение 0. Таким образом, повторные вызовы возвращают одно за другим все совпадения, используя свойство regexp.lastIndex для отслеживания текущей позиции поиска. regexp.test(str) Метод regexp.test(str) ищет совпадение и возвращает true/false, в зависимости от того, находит ли он его. ',\r\n      },\r\n      {\r\n        'Какие методы есть у строк, которые позволяют работать с регулярными выражениями?':\r\n          'str.match(regexp) Метод str.match(regexp) ищет совпадения с regexp в строке str. У него есть три режима работы: Если у регулярного выражения нет флага g, то он возвращает первое совпадение в виде массива со скобочными группами и свойствами index (позиция совпадения), input (строка поиска, равна str) Если у регулярного выражения есть флаг g, то он возвращает массив всех совпадений, без скобочных групп и других деталей. Если совпадений нет, то, вне зависимости от наличия флага g, возвращается null. Это очень важный нюанс. При отсутствии совпадений возвращается не пустой массив, а именно null. str.matchAll(regexp) Новая возможность Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил. Метод str.matchAll(regexp) – «новый, улучшенный» вариант метода str.match. Он используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами. У него 3 отличия от match: Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи Array.from. Каждое совпадение возвращается в виде массива со скобочными группами (как str.match без флага g). Если совпадений нет, то возвращается не null, а пустой перебираемый объект. str.split(regexp|substr, limit) Разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr. мы можем разделить по регулярному выражению аналогичным образом: alert(\"12, 34, 56\".split(/,s*/)) // массив [12, 34, 56] str.search(regexp) Метод str.search(regexp) возвращает позицию первого совпадения с regexp в строке str или -1, если совпадения нет. Важное ограничение: str.search умеет возвращать только позицию первого совпадения. Если нужны позиции других совпадений, то следует использовать другой метод, например, найти их все при помощи str.matchAll(regexp).  str.replace(str|regexp, str|func) Это универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены в строке. Когда первый аргумент replace является строкой, он заменяет только первое совпадение. Вы можете видеть это в приведённом выше примере: только первый \"-\" заменяется на \":\". Для ситуаций, которые требуют «умных» замен, вторым аргументом может быть функция. Она будет вызываться для каждого совпадения, и её результат будет вставлен в качестве замены. Функция вызывается с аргументами func(match, p1, p2, ..., pn, offset, input, groups): match – найденное совпадение, p1, p2, ..., pn – содержимое скобок (см. главу Скобочные группы). offset – позиция, на которой найдено совпадение, input – исходная строка, groups – объект с содержимым именованных скобок (см. главу Скобочные группы). Если скобок в регулярном выражении нет, то будет только 3 аргумента: func(match, offset, input).',\r\n      },\r\n      {\r\n        'Что такое флаги в регулярных выражениях? Рассказать про флаги глобальности, регистронезависимости, многострочности.':\r\n          'Регулярные выражения имеют четыре опциональных флага, которые делают возможным глобальный и регистронезависимый поиск. Флаги могут использоваться самостоятельно или вместе в любом порядке, а также могут являтся частью регулярного выражения. Флаги регулярных выражений Flag\tDescription g\tГлобальный поиск. i\tРегистронезависимый поиск. m\tМногострочный поиск. y\tВыполняет поиск начиная с символа, который находится на позиции свойства lastindex текущего регулярного выражения. Регулярные выражения могут иметь флаги, которые влияют на поиск. В JavaScript их всего шесть: i С этим флагом поиск не зависит от регистра: нет разницы между A и a (см. пример ниже). g С этим флагом поиск ищет все совпадения, без него – только первое. m Многострочный режим (рассматривается в главе Многострочный режим якорей ^ $, флаг \"m\"). s Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \\n (рассматривается в главе Символьные классы). u Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар (подробнее об этом в главе Юникод: флаг \"u\" и класс p{...}). y Режим поиска на конкретной позиции в тексте',\r\n      },\r\n      {\r\n        'Как работают методы указания количества (кванторы) *, +, {3}?':\r\n          'Самый простой квантификатор — это число в фигурных скобках: {n}. Он добавляется к символу (или символьному классу, или набору [...] и т.д.) и указывает, сколько их нам нужно. Можно по-разному указать количество, например: Точное количество: {5} Шаблон d{5} обозначает ровно 5 цифр, он эквивалентен ddddd. Диапазон: {3,5}, от 3 до 5 Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: d{3,5} alert( \"Мне не 12, а 1234 года\".match(/d{3,5}/) ); // \"1234\" Верхнюю границу можно не указывать. Тогда шаблон d{3,} найдёт последовательность чисел длиной 3 и более цифр. Для самых востребованных квантификаторов есть сокращённые формы записи: + Означает «один или более». То же самое, что и {1,}. ? Означает «ноль или один». То же самое, что и {0,1}. По сути, делает символ необязательным. Например, шаблон ou?r найдёт o после которого, возможно, следует u, а затем r. * Означает «ноль или более». То же самое, что и {0,}. То есть символ может повторяться много раз или вообще отсутствовать. Например, шаблон d0* находит цифру и все нули за ней (их может быть много или ни одного)',\r\n      },\r\n      {\r\n        'Что в регулярных выражениях означают символы [] и [^], ., ?, ^, $, |?':\r\n          'Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных». Ещё квадратные скобки могут содержать диапазоны символов. К примеру, [a-z] соответствует символу в диапазоне от a до z, или [0-5] – цифра от 0 до 5. Экранирование внутри […] Обычно, когда мы хотим найти специальный символ, нам нужно экранировать его, например .. А если нам нужна обратная косая черта, тогда используем \\\\, т.п. В квадратных скобках большинство специальных символов можно использовать без экранирования: Символы . + ( ) не нужно экранировать никогда. Тире - не надо экранировать в начале или в конце (где оно не задаёт диапазон). Символ каретки ^ нужно экранировать только в начале (где он означает исключение). Закрывающую квадратную скобку ], если нужен именно такой символ, экранировать нужно. Другими словами, разрешены без экранирования все специальные символы, кроме случаев, когда они означают что-то особое в наборах.  Точка . – это специальный символьный класс, который соответствует «любому символу, кроме новой строки». Чтобы проверить, удовлетворяет ли строка хотя бы одному из шаблонов, можно воспользоваться аналогом булевого оператора OR, который записывается с помощью символа | - Альтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ». В регулярных выражениях она обозначается символом вертикальной черты |. У символов каретки ^ и доллара $ есть специальные значения в регулярных выражениях. Они называются «якоря» (anchors). Каретка ^ означает совпадение с началом текста, а доллар $ – с концом.',\r\n      },\r\n      {\r\n        'Что такое жадные и ленивые квантификаторы?':\r\n          'Жадный поиск Чтобы найти совпадение, движок регулярных выражений работает по следующему алгоритму: Для каждой позиции в строке для поиска: Попробовать найти совпадение с шаблоном на этой позиции. Если нет совпадения, переход к следующей позиции. Регулярное выражение вроде /\".+\"/g (кавычка, какой-то текст, другая кавычка) может выглядеть хорошим решением, но это не так! Давайте это проверим: let regexp = /\".+\"/g; let str = \"a \"witch\" and her \"broom\" is one\"; alert( str.match(regexp) ); // \"witch\" and her \"broom\" …Как мы видим, регулярное выражение работает не как задумано! Вместо того, чтобы найти два совпадения \"witch\" и \"broom\", было найдено одно:\"witch\" and her \"broom\". Причину можно описать, как «жадность – причина всех зол». В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно. Движок регулярного выражения пытается получить максимальное количество символов, соответствующих .+, а затем сокращает это количество символ за символом, если остаток шаблона не совпадает. Ленивый режим «Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз». Мы можем включить его, вставив знак вопроса \"?\" после квантификатора, то есть будет *? или +? или даже ?? для \"?\". Проясним: обычно знак вопроса ? сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора (или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый. Регулярное выражение /\".+?\"/g работает как задумано, оно находит \"witch\" и \"broom\": let regexp = /\".+?\"/g; let str = \"a \"witch\" and her \"broom\" is one\"; alert( str.match(regexp) ); // witch, broom. Ленивый режим включается только для квантификаторов с ?. Остальные квантификаторы остаются жадными. У квантификаторов есть два режима работы: Жадный По умолчанию движок регулярного выражения пытается повторить квантификатор столько раз, сколько это возможно. Например, d+ получит все возможные цифры. Когда цифры закончатся или он дойдёт до конца строки, движок продолжит искать совпадение для оставшегося шаблона. Если совпадения не будет, он уменьшит количество повторов (осуществит возврат) и попробует снова. Ленивый Включается с помощью знака вопроса ? после квантификатора. Движок регулярного выражения пытается найти совпадение для оставшегося шаблона перед каждым повторением квантификатора. Как мы увидели на примере поиска строк в кавычках, ленивый режим не «панацея» от всех проблем жадного поиска. В качестве альтернативы может выступать «хорошо настроенный» жадный поиск, как в шаблоне \"[^\"]+\".',\r\n      },\r\n      {\r\n        'Как использовать базовые плейсхолдеры W, w,D, d, S, s, B, \\\\b?':\r\n          'Наиболее используемые: d («d» от английского «digit» означает «цифра») Цифра: символ от 0 до 9. s («s»: от английского «space» – «пробел») Пробельные символы: включает в себя символ пробела, табуляции \\\\t, перевода строки \\\\n и некоторые другие редкие пробельные символы, обозначаемые как \\v, \\f и \\r. w («w»: от английского «word» – «слово») Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание _. Нелатинские буквы не являются частью класса w, то есть буква русского алфавита не подходит. Для примера, dsw обозначает «цифру», за которой идёт пробельный символ, а затем символ слова, например 1 a. Для каждого символьного класса существует «обратный класс», обозначаемый той же буквой, но в верхнем регистре. «Обратный» означает, что он соответствует всем другим символам, например: D Не цифра: любой символ, кроме d, например буква. S Не пробел: любой символ, кроме s, например буква. W Любой символ, кроме w, то есть не буквы из латиницы, не знак подчёркивания и не цифра. В частности, русские буквы принадлежат этому классу. Граница слова \\b – проверка, как ^ и $. Когда движок регулярных выражений (программный модуль, реализующий поиск по регулярным выражениям) видит \\\\b, он проверяет, что позиция в строке является границей слова. Есть три вида позиций, которые являются границами слова: Начало текста, если его первый символ w. Позиция внутри текста, если слева находится \\\\w, а справа – не \\\\w, или наоборот. Конец текста, если его последний символ \\\\w. B Соответствует несловообразующей границе. Несловообразующая граница соответствует позиции, в которой предыдущий и следующий символы являются символами одного типа: либо оба должны быть словообразующими символами, либо несловообразующими. Начало и конец строки считаются несловообразующими символами. Например, /B../ соответствует \"oo\" в слове \"noonday\" (, а /yB./ соответствует \"ye\" в \"possibly yesterday.\"',\r\n      },\r\n      {\r\n        'Как работает \\\\b для начала строки и для конца строки? Почему регулярное выражение \\babc\\b сработает для строки abc, но регулярное выражение \\b..\\b не сработает для строки ..?':\r\n          '',\r\n      },\r\n      {\r\n        'Когда использовать экранирующий символ ?':\r\n          'Допустим, мы хотим найти буквально точку. Не «любой символ», а именно точку. Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: .. Это называется «экранирование символа». Символ косой черты \"/\", так называемый «слэш», не является специальным символом, но в JavaScript он используется для открытия и закрытия регулярного выражения: /...шаблон.../, поэтому мы должны экранировать его. Для поиска специальных символов [  ^ $ . | ? * + ( ), нам нужно добавить перед ними  («экранировать их»). Нам также нужно экранировать /, если мы используем /.../ (но не new RegExp). При передаче строки в new RegExp нужно удваивать обратную косую черту: \\\\\\\\ для экранирования специальных символов, потому что строковые кавычки «съедят» одну черту.',\r\n      },\r\n      {\r\n        'Зачем нужны группы? Как с ними работать?':\r\n          'Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа». У такого выделения есть два эффекта: Позволяет поместить часть совпадения в отдельный массив. Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу. Скобочные группы нумеруются слева направо. Поисковой движок запоминает содержимое, которое соответствует каждой скобочной группе, и позволяет получить его в результате. Метод str.match(regexp), если у регулярного выражения regexp нет флага g, ищет первое совпадение и возвращает его в виде массива: На позиции 0 будет всё совпадение целиком. На позиции 1 – содержимое первой скобочной группы. На позиции 2 – содержимое второй скобочной группы. …и так далее… Круглые скобки группируют вместе часть регулярного выражения, так что квантификатор применяется к ним в целом. Скобочные группы нумеруются слева направо. Также им можно дать имя с помощью (?<name>...). Часть совпадения, соответствующую скобочной группе, мы можем получить в результатах поиска. Метод str.match возвращает скобочные группы только без флага g. Метод str.matchAll возвращает скобочные группы всегда. Если скобка не имеет имени, то содержимое группы будет по своему номеру в массиве-результате, если имеет, то также в свойстве groups. Содержимое скобочной группы можно также использовать при замене str.replace(regexp, replacement): по номеру $n или по имени $<имя>. Можно исключить скобочную группу из запоминания, добавив в её начало ?:. Это используется, если необходимо применить квантификатор ко всей группе, но не запоминать их содержимое в отдельном элементе массива-результата. Также мы не можем ссылаться на такие скобки в строке замены.',\r\n      },\r\n      {\r\n        'Можно ли создавать вложенные группы?':\r\n          'Скобки могут быть и вложенными. Например, при поиске тега в <span class=\"my\"> нас может интересовать: Содержимое тега целиком: span class=\"my\". Название тега: span. Атрибуты тега: class=\"my\". Заключим их в скобки в шаблоне: <(([a-z]+)s*([^>]*))>.В действии: let str = \"<span class=\"my\">\"; let regexp = /<(([a-z]+)s*([^>]*))>/; let result = str.match(regexp); alert(result[0]); // <span class=\"my\"> alert(result[1]); // span class=\"my\" alert(result[2]); // span alert(result[3]); // class=\"my\" По нулевому индексу в result всегда идёт полное совпадение. Затем следуют группы, нумеруемые слева направо, по открывающим скобкам. Группа, открывающая скобка которой идёт первой, получает первый индекс в результате – result[1]. Там находится всё содержимое тега. Затем в result[2] идёт группа, образованная второй открывающей скобкой ([a-z]+) – имя тега, далее в result[3] будет остальное содержимое тега: ([^>]*). Даже если скобочная группа необязательна (например, стоит квантификатор (...)?), соответствующий элемент массива result существует и равен undefined. Например, рассмотрим регулярное выражение a(z)?(c)?. Оно ищет букву \"a\", за которой идёт необязательная буква \"z\", за которой, в свою очередь, идёт необязательная буква \"c\".',\r\n      },\r\n      {\r\n        'Что означают $1, $2 и т.д. в текстовых редакторах в поле замены, если поиск поддерживает регулярные выражения?':\r\n          'Круглые скобки указывают порядок обработки шаблона, а также выступают в качестве помеченного(tagged) выражения, которое можно использовать в выраженияхпоиска и замены. Результаты поиска с помощью регулярного выражения временно сохраняются и могут быть использованы в выражении заменыдля построения нового выражения. В выражениизамены (replace) вы можете включить символ\"$0\", который будет заменен подстрокой, найденной регулярным выражением в результате поиска. Итак, если выражение поиска(search) \"a(bcd)e\" находит совпадение подстроки, то выражение замены(replace) \"123-$0-123\" заменит совпадающий текст на строку \"123-abcde-123\". Точно так же вы можете использовать в выражении заменыспецсимволы \"$1\", \"$2\", \"$3\" и т.д. Эти символы будут заменены только результатамипомеченных(tagged) выражений - вместо полных совпадающих подстрок. Число, следующее за символом \"$\", показывает, на какое помеченное выражение вы ссылаетесь (если регулярное выражение содержит более одного помеченного выражения). Например, если вы используете выражениепоиска\"(123)(456)\" и выражение замены\"a-$2-b-$1\", то совпадающая подстрока будет заменена на \"a-456-b-123\", а выражениезамены \"a-$0-b\" будет заменено на \"a-123456-b\".',\r\n      },\r\n      {\r\n        'Как сделать незапоминающуюся группу (группу, вхождение которой не будет возвращено при матчинге строки на регулярное выражение)?':\r\n          'При поиске всех совпадений (флаг g) метод match не возвращает скобочные группы. Например, попробуем найти все теги в строке: let str = \"<h1> <h2>\"; let tags = str.match(/<(.*?)>/g); alert( tags ); // <h1>,<h2> Результат – массив совпадений, но без деталей о каждом. Но на практике скобочные группы тоже часто нужны. Для того, чтобы их получать, мы можем использовать метод str.matchAll(regexp). Он был добавлен в язык JavaScript гораздо позже чем str.match, как его «новая и улучшенная» версия. Он, как и str.match(regexp), ищет совпадения, но у него есть три отличия: Он возвращает не массив, а перебираемый объект. При поиске с флагом g, он возвращает каждое совпадение в виде массива со скобочными группами. Если совпадений нет, он возвращает не null, а просто пустой перебираемый объект.',\r\n      },\r\n      {\r\n        'Как использовать значение группы в самом регулярном выражении?':\r\n          'Как сказал Тим Пицкер, ECMAScript 2018 вводит именованные группы захвата в регулярные выражения JavaScript. Но что я не нашел в приведенных выше ответах, так это как использовать именованную захваченную группу в самом регулярном выражении. Вы можете использовать захваченное с именем группы с этим синтаксисом: k<name>. например var regexObj = /(?<year>d{4})-(?<day>d{2})-(?<month>d{2}) year is k<year>/ и, как сказал Форивин, вы можете использовать захваченную группу в результате объекта следующим образом: let result = regexObj.exec(\"2019-28-06 year is 2019\"); // result.groups.year === \"2019\"; // result.groups.month === \"06\"; // result.groups.day === \"28\";',\r\n      },\r\n      {\r\n        'Решить задачи: Написать регулярное выражение по переводу Function Expression в Function Declaration. Написать регулярное выражение по переводу Function Declaration в Function Expression. Написать регулярное выражение для поиска всех команд Телеграма в сообщении (примеры: /help, /start, /active_orders, /order123). Учесть, что команд в подстроке может быть несколько.':\r\n          '',\r\n      },\r\n      {\r\n        'Что такое Promise? Для чего он нужен?':\r\n          'Обещания (promises) в JavaScript – это новый инструмент для работы с отложенными или асинхронными вычислениями, добавленный в ECMAScript 2015 (6-я версия ECMA-262).',\r\n      },\r\n      {\r\n        'Как создать Promise? В чем разница при создании промисов с помощью конструктора и с помощью фабрики?':\r\n          'Синтаксис создания Promise: let promise = new Promise(function(resolve, reject) { // функция-исполнитель (executor) // \"певец\" }); Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.',\r\n      },\r\n      {\r\n        'Методы then и catch Что делают? Что такое promise chaining? Что могут возвращать их коллбэки и как это повлияет на состояние промиса, возвращаемого данным then или catch?':\r\n          'Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then, .catch и .finally. then Наиболее важный и фундаментальный метод – .then. Синтаксис: promise.then( function(result) { /* обработает успешное выполнение */ }, function(error) { /* обработает ошибку */ } ); Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат. Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку. catch Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое: let promise = new Promise((resolve, reject) => { setTimeout(() => reject(new Error(\"Ошибка!\")), 1000); }); // .catch(f) это тоже самое, что promise.then(null, f) promise.catch(alert); // выведет \"Error: Ошибка!\" спустя одну секунду Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f). finally По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally. Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой. finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата. Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше https://learn.javascript.ru/promise-chaining ',\r\n      },\r\n      {\r\n        'В чем отличие then(resolveHandler).catch(rejectHandler) и then(resolveHandler, rejectHandler)?':\r\n          'promise.then(f1).catch(f2); Против: promise.then(f1, f2); Разница в том, что если ошибка произо��дёт в f1, то она будет обработана в .catch в этом примере: promise .then(f1) .catch(f2); …но не в этом: promise .then(f1, f2); Ошибка передаётся по цепочке, но во втором примере нет продолжения цепочки после f1. Другими словами, .then передаёт результат или ошибку следующему блоку .then/catch. Так как в первом примере в цепочке далее имеется блок catch, а во втором – нет, то ошибка в нём останется необработанной.',\r\n      },\r\n      {\r\n        'Можно ли отменить выполнение промиса?':\r\n          'Промисы не имеют встроенного механизма отмены. Из-за этого разработчики придумывают различные хаки, которые порождают некоторые проблемы. Дополнительный метод .cancel() Помимо того, что метод .cancel() делает промис нестандартным, нарушается еще один из главных принципов — только функция, которая создала промис, может изменять его состояние. Отсутствие очистки после отмены Некоторые используют Promise.race() в качестве механизма отмены. Однако, в этом случае у функции, создающей промис, нет возможности узнать, что произошла отмена и нужно освободить некоторые ресурсы.',\r\n      },\r\n      {\r\n        'Рассказать про методы: Promise.resolve, Promise.reject,  Promise.all, Promise.race':\r\n          'Метод Promise.resolve(value) возвращает Promise выполненый с переданным значением. Если переданное значение является thenable - обьект (т.е. имеет метод \"then\" method), возвращаемое обещание будет следовать thenable - обьекту, принимая свое состояние; в ином случае возвращаемое обещание будет выполнено с переданным значением.СинтаксисPromise.resolve(value);Promise.resolve(promise);Promise.resolve(thenable); Метод Promise.reject(reason) возвращает объект Promise, который был отклонен по указанной причине. Синтаксис Promise.reject(reason); Метод Promise.race(iterable) возвращает выполненное или отклоненное обещание, в зависимости от того, с каким результатом завершится первое из переданных обещаний, со значением или причиной отклонения этого обещания.Синтакс Promise.race(iterable); Параметры iterable Итерируемый объект, такой как (Array). Смотри iterable. Возвращаемое значение Выполненный или отклоненный Promise в зависимости от результата первого завершенного из переданных в итерируемом объекте обещаний. Общее описание Метод Promise.all(iterable) возвращает обещание, которое выполнится тогда, когда будут выполнены все обещания, переданные в виде перечисляемого аргумента, или отклонено любое из переданных обещаний. Синтаксис Promise.all(iterable); Параметры iterable Перечисляемый объект, например, массив (Array). Смотрите iterable. Возвращаемое значение Promise, который будет выполнен когда будут выполнены все обещания, переданные в виде перечисляемого аргумента, или отклонен, если будет отклонено хоть одно из переданных обещаний.',\r\n      },\r\n      {\r\n        'В чем преимущества и недостатки коллбэков и промисов?':\r\n          'Мы можем писать сколько угодно зенов, в каждом что-то делать с данными. Если в любом месте вылетит ошибка, она будет нормально обработана в кэтче. Код при этом линейный, без дикой вложенности. С коллбэками вам нужно на каждом этапе отслеживать ошибки и возвращать их. Легко потеряться, что откуда всплыло или где пропало. Альтернатива обработки ошибок — трай/кэтч. Но это не работает на асинхронном коде. Async/Await 101 Для тех, кто еще не слышал об Async/Await ранее, приведено быстрое введение: Async/await — это новый способ написания асинхронного кода. Ранее его альтернативами были коллбэки и промисы. Async/await — это лишь синтаксический сахар, покрывающий промисы. Он не может быть использован вместе с коллбэками. Async/await, как и промисы, является неблокирующей функцией. Async/await заставляет асинхронный код выглядить и вести себя более, как синхронный код. Именно в этом заключается вся сила.',\r\n      },\r\n      {\r\n        'Какие значение и состояние будут у следующего промиса и почему:const promise = new Promise((resolve, reject) => {resolve(0);reject(1);resolve(2);});':\r\n          '',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Testing: [\r\n      { 'Что такое граничные условия? Зачем их тестировать?': '' },\r\n      { 'Что такое heisenbug? Какие есть способы их дебаггинга?': '' },\r\n      { 'Что такое fixture?': '' },\r\n      {\r\n        'Что такое покрытие кода тестами? Какие есть инструменты для его анализа?':\r\n          '',\r\n      },\r\n      {\r\n        'Чем юнит-тесты отличаются от интеграционных тестов? Почему интеграционные сложнее писать и поддерживать?':\r\n          '',\r\n      },\r\n      {\r\n        'Зачем обращать внимание на закономерности при отказе тестов? В чём может помочь анализ того, какая именно комбинация тестов отвалилась?':\r\n          '',\r\n      },\r\n      {\r\n        'Как тесты помогают в проектировании? Почему тестируемость модуля является отличным индикатором \"чистоты кода\"?':\r\n          '',\r\n      },\r\n      { 'Как тесты помогают при рефакторинге?': '' },\r\n      { 'В чём преимущества правила одной концепции на один unit-тест?': '' },\r\n      { 'В чём преимущества изолированных друг от друга тестов?': '' },\r\n      {\r\n        'Как найти баланс между количеством тестов и покрытием кода? Какие проблемы могут быть из-за излишнего количества юнит-тестов?':\r\n          '',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    GIT: [\r\n      {\r\n        'Рассказать про объектную модель (blob, tree, commit, tag) и .pack файлы.':\r\n          'SHA Вся информация требуемая чтобы представить историю проекта хранится в особым образом организованных файлах. Все файлы хранят ссылаются друг на друга с помощью 40-значного \"имени объекта\" и это имя выглядит так: 6ff87c4664981e4397625791c8ea3bbb5f2279a3 Вы увидите эти 40-значные строки повсюду в Git. В каждом случае имя вычисляется как SHA1 значение содержимого объекта. SHA1 хэш это криптографическая хэш-функция. Для нас это значит то, что практически нереально найти два разных объекта с одинаковым именем. Это дает огромную выгоду; такую как: Git может быстро определить идентичны ли два объекта или нет, просто сравнивая их имена. Так как имена объектов вычисляются одинаково во всех репозиториях, то объекты с одинаковым содержимым в двух репозиториях всегда будут хранится под одинаковыми именами. Git может находить ошибки когда читает объект, для этого нужно просто сравнить хэш значение содержимого объекта с его именем. Объекты Каждый объект состоит из трех частей - тип, размер , содержимое. Размер это просто объем содержимого, а содержимое зависит от типа объекта. Существуют 4 разных типа объекта: \"блоб\", \"дерево\", \"коммит\", и \"таг\". \"блоб\" используется чтобы хранить содержимое файла - обычно это просто файл. \"дерево\" это что то вроде директории - оно ссылается на группу других деревьев и/или блобов (т.е. файлов и директорий) \"коммит\" указывает на отдельное дерево, от по сути отмечает дерево фиксируя в истории каким образом оно выглядет в момент выполнения коммита. Он содержит метаинфомацию фиксируя момент времени и автора изменений внесенных с последднего коммита, указатель на предыдущий коммит, и т.д. \"таг\" это способ маркировать некоторым образом определенный комит. Обычно это используется чтобы маркировать(по сути дать какое либо легко запоминающеся имя) определенные комиты как специфические, чтобы впоследствии было легче их найти. Почти все в Git построено вокруг манипуляций этой простой структурой состоящей из четырех различных типов объектов. Это что-то вроде своеобразной файловой-системы надстроенной над файловой-системой компьютера. Первоначальный формат для сохранения объектов в Git называется “рыхлым” форматом (loose format). Однако, время от времени Git упаковывает несколько таких объектов в один pack-файл для сохранения места на диске и повышения эффективности. Это происходит, когда “рыхлых” объектов становится слишком много, а также при ручном вызове git gc или отправке изменений на удалённый сервер.',\r\n      },\r\n      {\r\n        'Что такое \"The Three Trees\" (The HEAD, The Index, The Working Directory)?':\r\n          '',\r\n      },\r\n      {\r\n        'Как производить отмену изменений? Где какой способ стоит применять? Рассказать в этом контексте про команды: checkout, reset, revert, Как сделать реверт merge-коммита? Как узнать родителей merge-коммита? clean, rm':\r\n          '',\r\n      },\r\n      {\r\n        'Как можно изменить историю коммитов? Где какой способ стоит применять? Рассказать в этом контексте про команды: commit с флагом --amend, cherry-pick, fitler-branch, rebase- Что такое интерактивный режим ребейза? Что он позволяет делать? Какие есть опасности при использовании ребейза? Что делают, как пользоваться, и когда бывают полезны команды: stash, reflog, bisect':\r\n          '',\r\n      },\r\n      { 'Как отменить merge commit?': '' },\r\n      {\r\n        'Что такое HEAD и detached HEAD? Что значат HEAD^, HEAD~, HEAD@{1}?':\r\n          'В этой статье пойдет речь про отсоединенное состояние указателя HEAD. Надо понимать что названия веток в Git - это указатели на коммиты. Имя ветки, допустим master, указывает на последний коммит в ветке master. Существует так же множество других указателей и один из них HEAD. Это очень важный указатель. И сейчас указатель ветки master и указатель HEAD указывают на последний коммит С4 в ветке master.  Оба указателя master и HEAD указывают на коммит С4 (efaaf18). Теперь передвинем указатель HEAD на коммит C2 командой $ git checkout 7bbbd68 Вот мы и получили отсоединенный указатель HEAD. То есть команда git checkout 7bbbd68 просто перенесла указатель HEAD на коммит C2 (7bbbbd68). И вместе с этим вернула в рабочем каталоге состояние файлов этого коммита. То есть мы откатились назад по истории коммитов. И Git порекомендовал нам создать новую ветку, а так же сообщил хэш коммита на который сейчас указывает HEAD. Состояние HEAD detached означает что HEAD указывает не на вершину какой либо ветки, а просто на какой-то коммит. Посмотреть историю перемещения головы можно командой git reflog. На скрине мы так же посмотрели состояние Git и он нам (аж красным) сообщил, что башка отсоединена на коммит 7bbbd68. HEAD всегда должен указывать на вершину какой-либо ветки. Это очень важно. И вот почему. Указатель HEAD по существу указывает на тот коммит, после которого будет сделан следующий коммит. И если в состоянии перемещенного HEAD мы сейчас сделаем еще один коммит, то у нас будет шанс потерять его, не в смысле что он будет не доступен, а что если мы не будем помнить хэш этого коммита, то мы ни когда не сможем на него переключится. Давайте сделаем коммит и посмотрим что будет. Изменим файлик и посмотрим статус Из лога коммитов видно что сейчас HEAD указывает на коммит С5 (84b361c), но на этот коммит не указывает ни какая ветка, верней сказать ни какой указатель ветки. Мы по прежнему находимся в состоянии detached HEAD, о чем нам все время напоминает Git. Еще раз напомню что это означает что HEAD указывает не на вершину какой-либо ветки, а просто на коммит. В нашем случае на коммит С5 (84b361c). Выйти из состояния detached HEAD очень легко, для этого надо переключится на какую-либо ветку или создать новую ветку. Давайте переключимся на ветку master командой git checkout masterПри переключении на ветку master, Git заботливо нас предупредил, что мы оставляем 1 commit, который не присоединен ни к какой ветке. Сообщил нам имя этого коммита – С5 и его хэш – 84b361c. И посоветовал, что возможно уже самое время создать новую ветку командой: git branch new_branch_name 84b361c Поскольку если мы сейчас не создадим ветку (указатель) на этом коммите, то мы можем его потерять. В Примере оригинального плаката: $ git reflog 97df263 HEAD@{0}: commit: I just made my first change to this file. Yay! 4333289 HEAD@{1}: clone: from https://github.com/tswicegood/mysite HEAD@{n} просто означает предыдущую позицию n-th HEAD : HEAD@{0} означает 0-th предшествующее положение HEAD . Другими словами, текущая позиция HEAD, поэтому HEAD@{0} фактически совпадает с HEAD . HEAD@{1} означает 1-ю предшествующую позицию HEAD . HEAD@{2} означает 2-ю предшествующую позицию HEAD, и так далее. В более общем плане синтаксис <reference>@{n} сокращенно означает \" предыдущее положение n-th reference/branch\",, как я заявляю в своем ответе на то, что означает “at” @ sign/symbol/character в Git? . Таким образом, вы можете использовать этот синтаксис с любым reference/branch, например: master@{1} - это 1-я предшествующая позиция ветви master . origin/master@{1} -это 1-я предшествующая позиция ветви дистанционного слежения origin/master . HEAD -это синоним самой последней фиксации в текущей ветке, какой бы она ни была. HEAD^ (или HEAD^1 ) означает первого родителя HEAD . Фиксация слияния имеет несколько родителей, поэтому HEAD^2 ссылается на второго непосредственного родителя HEAD , который был вовлечен в слияние, создавшее HEAD . HEAD~1 -это то же самое, что и HEAD~ . В этом случае он является синонимом HEAD^ . Чтобы увидеть разницу, подумайте, что HEAD~2 является прародителем HEAD . Использование ~ восходит к поколениям. Если вы находитесь в ветке master , то HEAD относится к мастеру. Если вы находитесь на ветке topic/foo , то она ссылается на эту ветку, пока вы на ней находитесь. Дело имеет значение с git. MASTER^ или MASTER~1 , вероятно, приведет к ошибкам формы fatal: ambiguous argument \"MASTER~1\": unknown revision or path not in the working tree. Но master^ и master~1 имеют смысл. ',\r\n      },\r\n      {\r\n        'Что такое Git flow, какие знаете примеры?':\r\n          'Gitflow является методологией работы с Git. Это значит, она определяет, какие ветки нужно создать и как производить их слияние.Вместо использования одной ветки master, в этой модели используется две ветки для записи истории проекта. В ветке master хранится официальная история релиза, а ветка develop служит в качестве интеграционной ветки для новых функций. Также, удобно тегировать все коммиты в ветке master номером версии.Каждая новая функциональность должна разрабатываться в отдельной ветке, которую можно отправлять в центральный репозиторий для создания резервной копии/для совместной работы команды. Ветки функций создаются не на основе master, a на основе develop. Когда работа над новой функциональностью завершена, она вливается назад в develop. Новый код не должен отправляться напрямую в master. Когда в ветку develop уже слито достаточно нового кода для релиза (или подходит установленная дата предрелиза), от ветки develop создается ветка release. Создание данной ветки означает начало следующего цикла релиза, в ходе которой новая функциональность уже не добавляется, а производится только отладка багов, создание документации и решение других задач, связанных с релизом.Ветки hotfix используются для быстрого внесения исправлений в рабочую версию кода. Ветки hotfix очень похожи на ветки release и feature, за исключением того, что они созданы от master, а не от develop. Это единственная ветка, которая должна быть создана непосредственно от master. Как только исправление завершено, ветка hotfix должна быть объединена как с master, так и с develop (или с веткой текущего релиза), а master должен быть помечен обновленным номером версии. Ключевые идеи, которые нужно запомнить о Gitflow: Данная модель отлично подходит для организации рабочего процесса на основе релизов. Gitflow предлагает создание отдельной ветки для исправлений ошибок в продуктовой среде. Последовательность работы при использовании модели Gitflow: Из master создается ветка develop. Из develop создаются ветки feature. Когда разработка новой функциональности завершена, она объединяется с веткой develop. Из develop создается ветка release. Когда ветка релиза готова, она объединяется с develop и master. Если в master обнаружена проблема, из нее создается ветка hotfix. Как только исправление на ветке hotfix завершено, она объединяется с develop и master.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    CSS: [\r\n      {\r\n        'Что такое гриды? Когда они могут быть полезны?':\r\n          'CSS Grid скоро станет неотъемлемой частью набора инструментов любого фронт-энд разработчика. И если вы один из них, то вам придется учить CSS Grid — который уже точно станет неоспоримым умением для любой позиции в фронтэнд разработке. CSS Grid это новая модель для создания шаблонов, оптимизированная для создания двумерных макетов. Она идеально подходит для: шаблонов сайтов, форм, галерей и всего, что требует точного и отзывчивого позиционирования. Позволяет нам создавать продвинутые шаблоны за малую долю времени от того, которое бы вы потратили на них с флотами и с гораздо меньшим количеством кода.',\r\n      },\r\n      {\r\n        'Что такое грид-контейнер и грид-элемент?':\r\n          'Grid шаблон работает по системе сеток. Grid это набор пересекающихся горизонтальных и вертикальных линий, которые создают размерность и позиционируют систему координат для контента в самом grid-контейнере. Чтобы создать Grid разметку, вам просто нужно выставить элементу display: grid. Этот шаг автоматически сделает всех прямых потомков этого элемента — grid элементами. После этого вы можете смело использовать разнообразные grid свойства для выравнивания размеров и позиционирования элементов должным образом. Обычно первым шагом является определение того, сколько колонок и рядов есть в гриде. Вот код, который создаёт его: #grid { display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; grid-gap: 2vw; }',\r\n      },\r\n      {\r\n        'Как задать количество и размеры строк (колонок)? Какие можно использовать единицы для того, чтобы задать размеры строк (колонок)?  Как задать несколько строк (колонок) одинакового размера? Как задать минимальный и максимальный размер строки (колонки)?':\r\n          'display: grid Превращает элемент в grid контейнер. Это все, что нужно для того, что создать грид. Теперь у нас есть грид-контейнер и грид-элементы. Значения гридов создают блочный контейнер. Вы так же можете использовать display: inline-grid, что создать строчный грид-контейнер. Или же вы можете использовать display: subgrid, чтобы создать подсетку, это значение используется на самих grid элементах. grid-template-rows: 1fr 1fr 1fr Выстраивает ряды в гриде. Каждое значение представляет размер ряда. В этом случае все значения равны 1fr. grid-template-columns: 1fr 1fr 1fr Тоже самое, что и выше, только определяет колонки в гридах. Вы можете использовать функцию repeat() для повторяющихся объявлений значения размера элемента. Для примера, вместо того, чтобы делать это: grid-template-rows: 1fr 1fr 1fr 1fr 1fr; Мы можем сделать так: grid-template-rows: repeat(5, 1fr); В шаблоне созданном на гридах есть такие значения, как auto-fill и auto-fit, которые позволяют вам создавать грид с множеством треков определенного размера, которые будут помещаться в указанном контейнере. Это говорит о том, что грид является адаптивным, то есть в нем элементы меняют свои позиции с тем, как вы меняете размер окна браузера. Код отвечающий именно за это: grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); В нем колонкам выдается минимальный размер в 150px и максимум по оставшемуся месту. Такие треки будут повторяться столько раз, сколько нужно для того, чтобы уложиться в заданный контейнер. Repeat() функция повторяет определение трека количество раз, заданное первым параметром. Использование auto-fill заставит треки повторяться такое количество раз, пока они не заполнят контейнер. Размер этих треков указан во втором параметре. В нашем случае, мы используем minmax(150px, 1fr), чтобы указать то, что минимальный размер столбца равен 150px, а максимальный 1fr. auto-fit работает практически также, как и auto-fill. Разница тут только в том, что auto-fit стягивает все пустые треки в конце размещения, в то время как auto-fill нет. Лучший способ тут, это демонстрация со сравнением. Использование двух маленьких грид элементов тут поможет показать всю концепцию работы. Auto-fill оставляет пустые треки в конце по указанным размерам, а auto-fit растягивает пустой трек, что ведёт к заполнению треков растянутыми элементами для заполнения пространства.',\r\n      },\r\n      {\r\n        'Как задать отступы между строками и колонками?':\r\n          'grid-gap: 2vw Выставляет разрыв. То есть пробелы между грид элементами. Тут мы используем vw единицу, которая относительна ширине viewport, но также мы можем использовать 10px, 1em и т. д. Grid-gap свойство это сокращение для grid-row-gap и grid-column-gap свойств.grid-gap: 2vw Выставляет разрыв. То есть пробелы между грид элементами. Тут мы используем vw единицу, которая относительна ширине viewport, но также мы можем использовать 10px, 1em и т. д. Grid-gap свойство это сокращение для grid-row-gap и grid-column-gap свойств. вот релевантный код для трехколоночного шаблона, для широких вьюпоротов. grid-template-areas: \"header header header\" \"nav article ads\" \"footer footer footer\"; А вот соответствующий код для мобильной версии: grid-template-areas: \"header\" \"article\" \"ads\" \"nav\" \"footer\"; Таким образом, все дело состоит в переназначении значений в свойстве grid-template-areas.',\r\n      },\r\n      {\r\n        'Размещение элементов внутри сетки Что такое grid line (далее: линия)? Что такое grid area (далее: область)? Как можно неявно задать имена для областей при именовании линий (и наоборот, имена линий при именовании областей)? Как размещать грид-элементы внутри сетки с помощью имен линий? Как размещать грид-элементы внутри сетки с помощью имен областей? Как при этом оставлять пустые клетки, не занимаемые ни какими элементами?':\r\n          'Давайте ближе посмотрим на наш код. HTML разметка выглядит таким образом: <body> <header id=\"pageHeader\">Header</header> <article id=\"mainArticle\">Article</article> <nav id=\"mainNav\">Nav</nav> <div id=\"siteAds\">Ads</div> <footer id=\"pageFooter\">Footer</footer> </body> Итак, мы сделаем <body> грид-контейнером, таким образом все другие элементы станут грид-элементами. А теперь давайте посмотрим на ASCII-графику, о которой мы говорили прежде. grid-template-areas: \"header header header\" \"nav article ads\" \"footer footer footer\";  Теперь мы можем назначить каждую из этих грид-областей каждому элементу: #pageHeader { grid-area: header; } #pageFooter { grid-area: footer; } #mainArticle { grid-area: article; } #mainNav { grid-area: nav; } #siteAds { grid-area: ads; } Свойство grid-area это сокращение свойства, которое позволяет вам размещать грид-элементы в гриде. В нашем случае, мы просто отсылаемся к названиям, которые мы уже предварительно указали в grid-template-areas. Следующий код выдает размеры строкам и колонкам: grid-template-rows: 60px 1fr 60px; grid-template-columns: 20% 1fr 15%; Первая и третья строки — обе в 60px высотой, а вторая строка забирает все оставшееся место. Первый столбец равен 20%, а третий 15%. Второй же забирает все оставшееся место.',\r\n      },\r\n      {\r\n        'Что такое explicit и implicit grid? Как задавать размеры для \"неявно созданных\" строк и колонок? Что делает свойство grid-auto-flow?':\r\n          'Явный грид — это грид, который вы определяете в grid-template-rows, grid-template-colums и в grid-template-areas.   Тем не менее, вы все еще можете иметь элементы, которые не умещаются в вашу «явно» указанную сетку. Для примера, вы определили грид который может уместить только шесть элементов, но сам контейнер на самом деле состоит из девяти элементов. Только шесть элементов будут умещаться в явный грид и три останутся. И вот уже начинаются неявные гриды. Неявные гриды автоматически генерируются самим грид-контейнером всякий раз когда грид-элементы располагаются за пределами явного грида. Контейнер генерирует неявные грид треки, добавляя неявные строки в грид. Эти строки вместе с явными гридами и формируют как таковые неявные. В этом примере мы явно определяем две строки и две колонки, что уместит в себя четыре грид элемента. Тем не менее, тут присутствует шесть грид элементов, таким образом был создан неявный грид, для того, чтобы уместить два дополнительный элемента. Высота строки на неявных гридах должна выставляться с помощью свойства grid-auto-rows.  Явный грид использует grid-template-rows и grid-template-columns Неявный грид использует grid-auto-rows и grid-auto-columns.  grid-auto-flow Это свойство позволяет указывать, что нужно использовать для авто-размещения элементов, строки или колонки. Другими словами, вы можете указать как будет расти неявный грид — в виде строк или колонок. Изначальное значение тут — row, что объясняет то, почему на примере выше были добавлены дополнительные строки, вместо колонок. Но если вы предпочитаете использовать колонки, то вы можете использовать это: grid-auto-flow: column; У grid-auto-flow также есть опциональное значение dense, которое может помочь в создании компактного грида и предостеречь от больших пробелов между грид-элементами в случае непоследовательных размеров всех грид-элементов в контейнере. Грид-линии — это горизонтальные и вертикальные линии в гриде. Каждая строка и колонка имеет грид-линию с каждой своей стороны. У каждой грид линии есть числовой индекс, к которому вы можете ссылаться во время расстановки грид элементов. Вы также можете проименовать грид линии для облегчения обращения к ним. Это можно делать выставляя свойства grid-template-rows и grid-template-columns, например как тут: #grid { display: grid; /* Выставляем имена строк и треки */ grid-template-rows: [row1-start] 50px [row2-start] 1fr [row3-start] 80px [row3-end];',\r\n      },\r\n\r\n      {\r\n        'Можно ли задать грид-элементу display: grid? Как это будет работать?':\r\n          'Чтобы создать такой вложенный грид, всё, что вам нужно сделать — это применить display: grid (или display: inline-grid) к грид элементу и он сам станет гридом. Вы также можете использовать display: subgrid для создания подгрида. Большинство грид свойств не наследуются, что означает то, что ваш вложенный грид не будет наследовать значения своего родительского грида. Это позволяет вам вносить изменения в родительский грид, без непреднамеренного влияния на вложенный грид. CSS Grid модуль может задавать значениеsubgrid для свойства display. Тем не менее, не все браузеры его ещё поддерживают. Хотя, это значение должно оказаться довольно полезным. Subgrid это вложенный грид, но с display: subgrid. Это делает его особенным типом грид-контейнера, который участвует в выставлении размера грида родительского грид контейнера. Другими словами, контент подгрида влияет на размер родительского грида, позволяя контенту расставляться по двум гридам.',\r\n      },\r\n      {\r\n        'Какие есть свойства гридов для выравнивания?':\r\n          'Есть три коротких свойства, которые можно использовать вместо длинных свойств для размещения гридов, упомянутых в примерах выше. Вот куда они все помещаются. grid-area — это свойство является сокращением для для: ---grid-column — это свойство является сокращением для: -----grid-column-start — указывает какая колоночная линия грид элемента стартовая и на сколько треков тянется. -----grid-column-end — указывает то, на каких колоночных линиях заканчивается грид элемент и на сколько треков тянется. ---grid-row — это свойство является сокращением для: -----grid-row-start — указывает с какой строчной линии начинается грид элемент и на сколько треков он тянется. -----grid-row-end — указывает какая строчная линия будет последней для элемента и насколько треков она будет тянуться. Вы также можете использовать grid-auto-flow свойство, которое упоминалось в главе перед этой. Оно указывает как автоматически размещенные grid элементы должны помещаться в гриде. В основном, большинство свойств выравнивания работает также на грид элементах, как и на других элементах. Но также есть некоторые свойства выравнивания, которые применяются только для гридов и флексов. Свойство align-items указывает стандартное значение align-self для всех грид элементов участвующих в грид контейнере в контексте форматирования оного. align-items: center; Align-self свойство Это свойство выравнивает элемент внутри блока контейнера вдоль блочной/колоночной/поперечной осей. Свойство justify-items Это свойство указывает стандартное значение для justify-self значения всех грид элементов в грид контейнере. Свойство justify-self Это свойство может использоваться для выравнивания индивидуальных грид элементов вдоль строчной/линейной/главной осей. Свойство justify-content выравнивает контент грид контейнера плоностью вдоль главной оси. Его можно применять для выравнивания всего грида в грид контейнере, в том случае, если грид трек забирает меньше места, чем его грид контейнер. Это может случиться, если вы выставили размер трека в абсолютной величине, например в пикселях, в то время как грид контейнер берет больше места, чем все треки вместе.Свойство align-content Это свойство схоже с justify-content, кроме того, что это свойство выравнивает вдоль поперечной/блочной осей. Свойство place-content Это свойство является сокращением для justify-content и align-content. place-content: center end; Свойство place-items Это свойство является сокращением для justify-items и align-items. Свойство place-self Это свойство является сокращением для justify-self и align-self. ',\r\n      },\r\n      {\r\n        'Как работает наложение элементов в гридах?':\r\n          'Наложение Grid элементов Используя шаблоны CSS на гридах, представляется возможным накладывать грид элементы друг на друга посредством пересечения грид областей, отрицательных внешних отступов и других техник позиционирования. Когда происходит наложение, элементы накладываются друг на друга в заданном порядке или в соответствии с z-index. Простой порядок Если вы намеренно не использовали z-index для какого-либо грид элемента, то любые накладыающиеся друг на друга элементы будут расположены основываясь на простой расстановке элементов в документе. Да, именно так. Они будут располагаться в том порядке, в котором они располагаются в разметке.  можете использовать свойство order, для того, чтобы расставить элементы так как вам нужно.Так же можно использовать свойство z-index чтобы раскладывать элементы.  Если у грид элементов был сменен порядок как на z-index, так и на order, то в порядке наложения z-index играет решающую роль. Это позволяет вам менять порядок элементов без потери контроля над наложением.',\r\n      },\r\n      {\r\n        'Что такое progressive jpeg?':\r\n          'Progressive JPEG – это JPEG-изображение в прогрессивном формате. Прогрессивный формат изображения позволяет браузеру загружать не количественно, а качественно. Другими словами – загружать изображение постепенно, постоянно отображая это изображение с различным качеством от 0 до 100 процентов.  Разница между последовательным и прогрессивным JPEG может быть незаметна на компьютерах. На компьютерах с очень хорошим интернетом (больше 100 Мбит/с) браузер загружает изображение настолько быстро, что изображение прогружается моментально в полном объёме. Тоже самое может происходить с маленькими изображениями. Если же соединение слабое (обычно это мобильные сети, к примеру 3G), или изображение имеет большой размер, то разница между последовательным и прогрессивным форматом будет “налицо”. Естественно, если весь земной шар будет покрыт мобильным интернетом пятого поколения, разница между обычным JPEG и прогрессивным уже мало кому будет заметна, но пока его нет, следует использовать его, чтобы делать всё пространство интернета капельку лучше.',\r\n      },\r\n      {\r\n        'Когда стоит использовать тег img, а когда background-image?':\r\n          'Различие состоит в том, что картинки несущие смысловую нагрузку или же каким-либо образом относящиеся к содержанию страницы следует вставлять тегом img (картинки в тексте, баннеры, картинки слайдера, аватарки и тд). Все остальное (просто элементы оформления: различного рода разделители, маркеры, фоны и тд.) следует вставлять в дизайн используя background-image. В чем преимущества данного подхода? В первую очередь таким образом мы очищаем код страницы, что значительно улучшает его читабельность, упрощает понимание документа поисковым роботам, ускоряет загрузку страницы за счет все того же уменьшения документа, в общем крайне положительно сказывается на SEO оптимизации страницы. Используя img для вывода картинок несущих на себе смысловую нагрузку мы даем возможность поисковикам прочитать альты этих картинок и лучше понять что они из себя представляют, есть возможность получения дополнительного трафика на сайт из сервисов поиска по картинкам, получаем лучшую уникализацию контента (поисковики любят текст разбавленный картинками, поскольку это обычно улучшает поведенческие факторы посетителей ресурса). Различные рекламные сервисы, счетчики и CMS для вывода своего содержимого и аватарок посетителей используют картинки, что абсолютно нормально и логично, поскольку данные элементы по логике вещей относятся не к оформлению страницы, а к ее содержимому. Нюансы из практики При печати страницы сайта теги img печатаются, а background-ы нет. Все, что желательно к индексации поисковиками выводим картинками, все что хотим скрыть- фонами. Браузеры разработанные для людей с ограниченными возможностями читают альты картинок, потому если изображение несет важный смысл, оно обязательно должно быть оформлено html тегом. Некоторые старые браузеры не поддерживают свойство background-size и для создания масштабируемого фона в них используется тег, а не свойство фона. Img с анимацией меньше нагружает браузеры. Для замены текста изображением лучше использовать background-image (к примеру, если нужно вывести заголовки красивыми картинками). Используя свойство фона мы можем вывести на странице только часть изображения. Вытекающая из предыдущего пункта фишка- background-image дает возможность использовать метод спрайтов (за счет того, что все иконки подгружаются с 1 картинки уменьшается количество обращений к серверу при загрузке страницы, что положительно сказывается на скорости) для ускорения загрузки сайта. Картинку спрятанную в фон сайта сложнее выкачать. Хотя как по мне для защиты своих уникальных изображений лучше использовать свои подписи на них, это хоть заставит плагиатщиков повозиться с приведением ее в порядок или же использовать прочие способы защиты уникального контента от копирования. все связанное с оформлением сайта должно быть помещено в css, а все связанное с его структурой и смысловым наполнением в html.',\r\n      },\r\n      {\r\n        'Различие экранов Что такое DPI и PPI? Что значит фраза: \"экран с высокой плотностью пикселей\"? Что такое device-pixel-ratio? Как масштабировать графику на экранах с повышенной плотностью пикселей (например, на retina дисплеях)?':\r\n          'Термины Dots Per Inch (DPI) и Pixels Per Inch (PPI) используются для определения разрешения изображения. Эти термины означают не одно и то же, и между этими двумя терминами есть существенные различия: DPI относится к количеству точек, содержащихся в одном дюйме изображения, распечатанного принтером на бумаге. PPI относится к количеству пикселей, содержащихся в одном дюйме изображения, отображенного на мониторе компьютера. И PPI и DPI – это единицы измерения, используемые для определения разрешения изображения, отображенного на экране (PPI) или распечатанного на бумаге (DPI). Если вы разделите размер изображения (общее количество пикселей цифрового изображения) на выходное разрешение, вы можете определить размер изображения, отображенного на экране или напечатанного на бумаге. Пример: изображение 3000x2000 пикселей, распечатанное с выходным разрешением 300 dpi будет иметь размер отпечатка (ширина) 10 дюймов (3000 пикселей / 300dpi). Плотность пикселей — это количество пикселей, вмещающееся в определенном физическом размере (обычно, в дюйме). Для совместимости между разными устройствами дизайнеры должны выпускать графику для обычных дисплеев и для Retina-дисплеев. Но тут возникла еще одна проблема: теперь дизайнер не может сказать, что какой-то элемент должен быть, например, 44 пикселя в высоту, потому что на другом устройстве этот же элемент должен быть в два раза выше. Решением стали пункты (points), или pt. Один пункт соответствует одному пикселю на экранах до поколения Retina и двум пикселям на экранах с Retina. Теперь, если дизайнеру говорят, что высота какого-либо элемента — 44 пикселя, он может адаптировать этот размер под любой коэффициент плотности пикселей — 1х, 2х или 3х в случае с iPhone 6 Plus. devicePixelRatio - свойство глобального объекта window (доступно только для чтения). Оно содержит отношение разрешения дисплея текущего устройства в физических пикселях к разрешению в логических (CSS) пикселях. Также это значение можно интерпретировать как отношение размера одного физического пикселя к размеру одного логического (CSS) пикселя. Не существует событий или поддержки обратных вызовов при изменении этого свойства (например, когда пользователь перетащил окно с одного дисплея на другой, имеющих различную плотность пикселей). https://vc.ru/design/19864-pixels-in-mobile-design',\r\n      },\r\n      {\r\n        'Как работает calc()? Какие параметры принимает? Какие операции допустимы? В каких единицах измерения можно задавать значения параметров?':\r\n          'calc() - это функция CSS, которая даёт возможность расчитать значения свойств CSS во время их определения. Она может быть использована везде, где применимы <length>, <frequency>, <angle>, <time>, <number>, или <integer>.  Функция calc() принимает в качестве параметра математическое выражение, результат вычисления которого можно использовать как значение CSS свойства. Выражение может включать операторы +, -, *, / с использованием стандартных правил приоритета операторов: + Сложение - Вычитание. * Умножение. По крайней мере хоть один из сомножителей должен быть <number>. / Деление. Делитель должен быть  <number>. Операнды в expression могут быть различными выражениями <length>. Если пожелаете, то можете использовать разные единицы измерения для каждого из операндов. Вы также можете использовать скобки, чтобы указать порядок вычисления. width: calc(100% - 80px); width: calc(100% / 6);',\r\n      },\r\n      {\r\n        'Как реализовать треугольник на чистом CSS?':\r\n          'Напрямую сделать треугольник средствами CSS нельзя, поэтому доступны два метода, позволяющих его добавить — через border и transform. Использование border Хотя границы, создаваемые через свойство border, напрямую не имеют отношения к треугольникам, именно border используется для этого наиболее часто. Если задать нулевую ширину и высоту элемента, а также установить достаточно толстую границу, то мы увидим набор из четырёх треугольников (рис. 2). Для наглядности границы на всех сторонах установлены разного цвета. Оставляя только нужную границу, а остальные делая прозрачными, мы получим треугольник нужного цвета. С помощью трансформации мы можем повернуть квадратный элемент на 45º и получить из него ромб. Это ещё не треугольник как таковой, поэтому нужную нам выступающую часть оставляем на виду, а остальное прячем за другим элементом http://htmlbook.ru/blog/treugolniki-cherez-css',\r\n      },\r\n      {\r\n        'Как работает @import? Почему не стоит использовать @import для загрузки стилей в документ? <!-- Почему не стоит так делать? --> <style>  @import url(\"a.css\"); </style>':\r\n          'Правило @import позволяет импортировать содержимое CSS-файла в текущую стилевую таблицу. @import не разрешается вставлять после любых объявлений кроме @charset или другого @import. Предположим, что мы используем четыре отдельных CSS-файла: один для разметки, второй для шрифтов и третий для картинок. Четвертым будет основной файл, в котором указаны ссылки на все остальные файлы. В самом верху основного файла (так как правила импорта должны размещаться над всем остальным содержимым) добавьте следующий код CSS import: @import url(\"/styles/layout.css\"); @import url(\"/styles/type.css\"); @import url(\"/styles/images.css\"); Уже после этих правил можно добавлять любой CSS-код для оформления страниц. При загрузке страницы сначала все отдельные файлы будут подгружены в основной CSS, а уже после этого файл загрузится в HTML-страницу. Таким образом у вас будет более простой доступ к отдельным сегментам стилизации.  Используем @import в медиа-запросах Разделение основного CSS-файла может пригодиться при адаптации сайта под мобильные устройства, где для разных разрешений и размеров экрана применяются различные стили. Главная проблема заключается в том, что подключения CSS import расположены в самом верху страницы, поэтому медиа-запросы будут загружены после стилей. При разработке адаптивных дизайнов важно учитывать производительность сайта. Рекомендуется не разделять CSS адаптивного сайта и использовать @import для их загрузки на ресурс.  <style> @import url(\"/styles/default.css\"); </style> Данный код импортирует CSS для использования на HTML-странице. Это позволяет редактировать все ее стили при помощи отдельного файла. Недостаток такого подхода заключается в отсутствии параллельной загрузки. То есть, страница не начнет загружаться до тех пор, пока браузер не загрузит файл CSS полностью. Это негативно скажется на скорости загрузки сайта и общей производительности.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Security: [\r\n      {\r\n        'Что такое SOP (Same-origin policy)? Зачем нужен? Как можно обойти ограничения SOP?':\r\n          'Политика одинакового источника (same-origin policy) определяет как документ или скрипт, загруженный из одного источника (origin), может взаимодействовать с ресурсом из другого источника. Это помогает изолировать потенциально вредоносные документы, снижая количество возможных векторов атак. Два URL имеют «одинаковый источник» в том случае, если они имеют совпадающие протокол, домен и порт. Политика «Одинакового источника» говорит, что: если у нас есть ссылка на другой объект window, например, на всплывающее окно, созданное с помощью window.open или на window из <iframe> и у этого окна тот же источник, то к нему будет полный доступ. в противном случае, если у него другой источник, мы не сможем обращаться к его переменным, объекту document и так далее. Единственное исключение – объект location: его можно изменять (таким образом перенаправляя пользователя). Но нельзя читать location (нельзя узнать, где находится пользователь, чтобы не было никаких утечек информации). Интерфейс postMessage позволяет окнам общаться между собой независимо от их происхождения. Это способ обойти политику «Одинакового источника». Он позволяет обмениваться информацией, скажем john-smith.com и gmail.com, но только в том случае, если оба сайта согласны и вызывают соответствующие JavaScript-функции. Это делает общение безопасным для пользователя. Интерфейс имеет две части. postMessage Окно, которое хочет отправить сообщение, должно вызвать метод postMessage окна получателя. Другими словами, если мы хотим отправить сообщение в окно win, тогда нам следует вызвать win.postMessage(data, targetOrigin). Аргументы: data Данные для отправки. Может быть любым объектом, данные клонируются с использованием «алгоритма структурированного клонирования». IE поддерживает только строки, поэтому мы должны использовать метод JSON.stringify на сложных объектах, чтобы поддержать этот браузер. targetOrigin Определяет источник для окна-получателя, только окно с данного источника имеет право получить сообщение. Указание targetOrigin является мерой безопасности. Как мы помним, если окно (получатель) происходит из другого источника, мы из окна-отправителя не можем прочитать его location. Таким образом, мы не можем быть уверены, какой сайт открыт в заданном окне прямо сейчас: пользователь мог перейти куда-то, окно-отправитель не может это знать. Если указать targetOrigin, то мы можем быть уверены, что окно получит данные только в том случае, если в нём правильный сайт. Особенно это важно, если данные конфиденциальные. onmessage Чтобы получать сообщения, окно-получатель должно иметь обработчик события message (сообщение). Оно срабатывает, когда был вызван метод postMessage (и проверка targetOrigin пройдена успешно). Объект события имеет специфичные свойства: data Данные из postMessage. origin Источник отправителя, например, http://javascript.info. source Ссылка на окно-отправитель. Можно сразу отправить что-то в ответ, вызвав source.postMessage(...). Чтобы добавить обработчик, следует использовать метод addEventListener, короткий синтаксис window.onmessage не работает.  Итого Чтобы вызвать метод или получить содержимое из другого окна, нам во-первых необходимо иметь ссылку на него. Для всплывающих окон (попапов) доступны ссылки в обе стороны: При открытии окна: window.open открывает новое окно и возвращает ссылку на него, Изнутри открытого окна: window.opener – ссылка на открывающее окно. Для ифреймов мы можем иметь доступ к родителям/потомкам, используя: window.frames – коллекция объектов window вложенных ифреймов, window.parent, window.top – это ссылки на родительское окно и окно самого верхнего уровня, iframe.contentWindow – это объект window внутри тега <iframe>. Если окна имеют одинаковый источник (протокол, домен, порт), то они могут делать друг с другом всё, что угодно. В противном случае возможны только следующие действия: Изменение свойства location другого окна (доступ только на запись). Отправить туда сообщение. Исключения: Окна, которые имеют общий домен второго уровня: a.site.com и b.site.com. Установка свойства document.domain=\"site.com\" в обоих окнах переведёт их в состояние «Одинакового источника». Если у ифрейма установлен атрибут sandbox, это принудительно переведёт окна в состояние «разных источников», если не установить в атрибут значение allow-same-origin. Это можно использовать для запуска ненадёжного кода в ифрейме с того же сайта. Метод postMessage позволяет общаться двум окнам с любыми источниками: Отправитель вызывает targetWin.postMessage(data, targetOrigin). Если targetOrigin не \"*\", тогда браузер проверяет имеет ли targetWin источник targetOrigin. Если это так, тогда targetWin вызывает событие message со специальными свойствами: origin – источник окна отправителя (например, http://my.site.com) source – ссылка на окно отправитель. data – данные, может быть объектом везде, кроме IE (в IE только строки). В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.',\r\n      },\r\n      {\r\n        'Что такое CORS (Cross-origin resource sharing)? Зачем нужен?':\r\n          'Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом. В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки. Этот cтандарт сross-origin обмена используется для разрешения кросс-сайтовых HTTP запросов для: Вызова XMLHttpRequest или Fetch APIs в кросс-сайт манере, как описано выше. Web Fonts (для кросс-доменного использования шрифтов в @font-face в рамках CSS), чтобы серверы могли разворачивать TrueType шрифты, которые могут быть загружены только кросс-сайт и использованы web-сайтами, которым это разрешено. WebGL текстуры. Фреймы с изображениями/видео, добавленными в канвас с помощью drawImage. Стили (для CSSOM доступа). Скрипты (для  отключенных исключений). ',\r\n      },\r\n      {\r\n        'Preflight request Что такое? Зачем нужен? Какие запросы его требуют? Что он в себе содержит? Как на него отвечает сервер?':\r\n          'Простые запросы — это: Запросы: GET,POST Тип содержимого следующего: text/plain application/x-www-form-urlencoded multipart/form-data  Любой заголовок, который не разрешен для простых запросов, требует предварительного запроса (preflight request). Этот механизм позволяет веб-серверам решать, хотят ли они разрешить фактический запрос. Браузер устанавливает заголовки Access-Control-Request-Headers и Access-Control-Request-Method, чтобы сообщить серверу, какой запрос ожидать, и сервер должен ответить соответствующими заголовками. Если запрос может оказать влияние на пользовательские данные, то простого запроса недостаточно. Вместо этого, предполентый CORS запрос отправляется в перед отправкой необходимого запроса, чтобы гарантировать безопасность отправки запроса. Предполетные запросы необходимы в тех случаях, когда любой HTTP метод, отличный от GET, POST, HEAD или если тип содержимого POST запроса отличен от application/x-www-form-urlencoded, multipart/form-data или text/plain. Также, если запрос содержит любые собственные заголовки, то необходим предполетный запрос. https://spring-projects.ru/understanding/cors/',\r\n      },\r\n      {\r\n        'Какие бывают Access-control-* заголовки? Зачем они нужны?':\r\n          'Access-Control-Allow-Methods это заголовок ответа, который определяет метод или методы доступа к ресурсам preflight request.  Заголовок ответа Access-Control-Allow-Origin показывает, может ли ответ сервера быть доступен коду, отправляющему запрос с данного источника origin. Заголовок ответа Access-Control-Allow-Headers используется в ответ на preflight request, чтобы указать, какие заголовки HTTP могут использоваться во время фактического запроса. The simple headers, Accept, Accept-Language, Content-Language, Content-Type (но только с MIME-типом, найденым в этом значении (исключая параметры), либо application/x-www-form-urlencoded, multipart/form-data или text/plain), всегда доступны и не должны быть перечислены в этом заголовке. Этот заголовок обязателен, если запрос содержит заголовок Access-Control-Request-Headers.',\r\n      },\r\n      {\r\n        'Что такое JSONP? Зачем он нужен?':\r\n          'JSONP или «JSON with padding» (JSON с набивкой) — это дополнение к базовому формату JSON. Он предоставляет способ запросить данные с сервера, находящегося в другом домене — операцию, запрещённую в типичных веб-браузерах из-за политики ограничения домена. Скажите, что вы находитесь на сайте example.com, и хотите сделать запрос на домен example.net. Для этого вам необходимо пересечь границы домена, no-no в большинстве браузеров. Один элемент, который обходит это ограничение, - это теги <script>. Когда вы используете тег скрипта, ограничение домена игнорируется, но при нормальных обстоятельствах вы ничего не можете сделать с результатами, скрипт просто получает оценку. Введите JSONP. Когда вы делаете свой запрос на сервер, который включен JSONP, вы передаете специальный параметр, который немного сообщает серверу о вашей странице. Таким образом, сервер может красиво завершать свой ответ так, как может обрабатывать ваша страница. Например, скажем, сервер ожидает параметр \"обратный вызов\", чтобы включить его возможности JSONP. Тогда ваш запрос будет выглядеть так: http://www.example.net/sample.aspx?callback=mycallback Без JSONP это может вернуть некоторый базовый объект JavaScript, например: { foo: \"bar\" } Однако с JSONP, когда сервер получает параметр \"обратный вызов\", он немного уменьшает результат, возвращая что-то вроде этого: mycallback({ foo: \"bar\" }); Как вы можете видеть, теперь он будет вызывать указанный вами метод. Итак, на вашей странице вы определяете функцию обратного вызова: mycallback = function(data){ alert(data.foo); }; И теперь, когда скрипт будет загружен, он будет оценен, и ваша функция будет выполнена. Voila, междоменные запросы! Также стоит отметить одну серьезную проблему с JSONP: вы теряете много контроля над запросом. Например, нет \"хорошего\" способа вернуть коды отказа. В результате вы в конечном итоге используете таймеры для отслеживания запроса и т.д., Что всегда немного подозрительно. Предложение для JSONRequest - отличное решение для разрешения междоменного скриптинга, поддержания безопасности и обеспечения надлежащего контроля над запросом.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    DOM: [\r\n      {\r\n        'Работа с системой координат Где начинается система координат в DOM? Рассказать про координаты относительно окна/документа/экрана. Когда какие могут применяются? Как получить размеры видимой части окна? Как получить координаты определенного элемента? Как программно прокрутить документ до нужного элемента?':\r\n          'Чтобы передвигать элементы по экрану, нам следует познакомиться с системами координат. Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат: Относительно окна браузера – как position:fixed, отсчёт идёт от верхнего левого угла окна. мы будем обозначать эти координаты как clientX/clientY, причина выбора таких имён будет ясна позже, когда мы изучим свойства событий. Относительно документа – как position:absolute на уровне документа, отсчёт идёт от верхнего левого угла документа. мы будем обозначать эти координаты как pageX/pageY. Когда страница полностью прокручена в самое начало, то верхний левый угол окна совпадает с левым верхним углом документа, при этом обе этих системы координат тоже совпадают. Но если происходит прокрутка, то координаты элементов в контексте окна меняются, так как они двигаются, но в то же время их координаты относительно документа остаются такими же. Любая точка на странице имеет координаты: Относительно окна браузера – elem.getBoundingClientRect(). Относительно документа – elem.getBoundingClientRect() плюс текущая прокрутка страницы. Координаты в контексте окна подходят для использования с position:fixed, а координаты относительно документа – для использования с position:absolute. Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между absolute и fixed. Чтобы получить ширину/высоту окна, можно взять свойства clientWidth/clientHeight из document.documentElement. К сожалению, готовой функции для получения координат элемента относительно страницы нет. Но её можно легко написать самим. Эти две системы координат жёстко связаны: pageY = clientY + текущая вертикальная прокрутка. Наша функция getCoords(elem) будет брать результат elem.getBoundingClientRect() и прибавлять текущую прокрутку документа. Результат getCoords: объект с координатами {left: .., top: ..} function getCoords(elem) { // кроме IE8- var box = elem.getBoundingClientRect(); return { top: box.top + pageYOffset, left: box.left + pageXOffset }; } Прокрутка: scrollTo, scrollBy, scrollIntoView Обычные элементы можно прокручивать, изменяя scrollTop/scrollLeft. Мы можем сделать то же самое для страницы в целом, используя document.documentElement.scrollTop/Left (кроме основанных на старом WebKit (Safari), где, как сказано выше, document.body.scrollTop/Left). Есть и другие способы, в которых подобных несовместимостей нет: специальные методы window.scrollBy(x,y) и window.scrollTo(pageX,pageY). Метод scrollBy(x,y) прокручивает страницу относительно её текущего положения. Например, scrollBy(0,10) прокручивает страницу на 10px вниз. Метод scrollTo(pageX,pageY) прокручивает страницу на абсолютные координаты (pageX,pageY). То есть, чтобы левый-верхний угол видимой части страницы имел данные координаты относительно левого верхнего угла документа. Это всё равно, что поставить scrollLeft/scrollTop. Для прокрутки в самое начало мы можем использовать scrollTo(0,0). scrollIntoView Для полноты картины давайте рассмотрим ещё один метод: elem.scrollIntoView(top). Вызов elem.scrollIntoView(top) прокручивает страницу, чтобы elem оказался вверху. У него есть один аргумент: если top=true (по умолчанию), то страница будет прокручена, чтобы elem появился в верхней части окна. Верхний край элемента совмещён с верхней частью окна. если top=false, то страница будет прокручена, чтобы elem появился внизу. Нижний край элемента будет совмещён с нижним краем окна. Размеры: Ширина/высота видимой части документа (ширина/высота области содержимого): document.documentElement.clientWidth/Height Ширина/высота всего документа с прокрученной частью: let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight ); Прокрутка: Прокрутку окна можно получить так: window.pageYOffset/pageXOffset. Изменить текущую прокрутку: window.scrollTo(pageX,pageY) – абсолютные координаты, window.scrollBy(x,y) – прокрутка относительно текущего места, elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).',\r\n      },\r\n      {\r\n        'Что такое event bubbling и event capturing?':\r\n          'Принцип всплытия очень простой. Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом: Клик по внутреннему <p> вызовет обработчик onclick: Сначала на самом <p>. Потом на внешнем <div>. Затем на внешнем <form>. И так далее вверх по цепочке до самого document. event.target Всегда можно узнать, на каком конкретно элементе произошло событие. Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target. Отличия от this (=event.currentTarget): event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик. Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри –- он всплывёт до элемента <form>, на котором сработает обработчик. При этом внутри обработчикаform.onclick: this (=event.currentTarget) всегда будет элемент <form>, так как обработчик сработал на ней. event.target будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик. Прекращение всплытия Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути. Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для этого нужно вызвать метод event.stopPropagation(). Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной. Стандарт DOM Events описывает 3 фазы прохода события: Фаза погружения (capturing phase) – событие сначала идёт сверху вниз. Фаза цели (target phase) – событие достигло целевого(исходного) элемента. Фаза всплытия (bubbling stage) – событие начинает всплывать. Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас. Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах. При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target). Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}. Далее обработчики вызываются на целевом элементе. Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false. Каждый обработчик имеет доступ к свойствам события event: event.target – самый глубокий элемент, на котором произошло событие. event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик) event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3). Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей. В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия.',\r\n      },\r\n      {\r\n        'Что такое делегирование DOM событий? Как этим пользоваться?':\r\n          'Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование. Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.  В этой таблице всего 9 ячеек, но могло бы быть и 99, и даже 9999, не важно. Наша задача – реализовать подсветку ячейки <td> при клике. Вместо того, чтобы назначать обработчик onclick для каждой ячейки <td> (их может быть очень много) – мы повесим «единый» обработчик на элемент <table>. Он будет использовать event.target, чтобы получить элемент, на котором произошло событие, и подсветить его.  Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого. Алгоритм: Вешаем обработчик на контейнер. В обработчике проверяем исходный элемент event.target. Если событие произошло внутри нужного нам элемента, то обрабатываем его. Зачем использовать: Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики. Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных. Конечно, у делегирования событий есть свои ограничения: Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать event.stopPropagation(). Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.',\r\n      },\r\n      {\r\n        'Как происходит процесс поиска элементов с помощью методов getElementsBy*, querySelector и т.д? Какие методы быстрее и почему? Какие у них есть особенности?':\r\n          'Есть 6 основных методов поиска элементов в DOM: Метод\tИщет по...\tИщет внутри элемента?\tВозвращает живую коллекцию? querySelector\tCSS-selector\t✔\t- querySelectorAll\tCSS-selector\t✔\t- getElementById\tid\t-\t- getElementsByName\tname\t-\t✔ getElementsByTagName\ttag or ' *\r\n          '\t✔\t✔ getElementsByClassName\tclass\t✔\t✔ Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll, но и методы getElementBy* могут быть полезны в отдельных случаях, а также встречаются в старом коде. Кроме того: Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS-селектору. Метод elem.closest(css) ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск. И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком: elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB. getElementsBy* Существуют также другие методы поиска элементов по тегу, классу и так далее. На данный момент, они скорее исторические, так как querySelector более чем эффективен. Здесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде. elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав \"*\" вместо тега, можно получить всех потомков. elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс. document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко используется. Все методы \"getElementsBy*\" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении. В приведённом ниже примере есть два скрипта. Первый создаёт ссылку на коллекцию <div>. На этот момент её длина равна 1. Второй скрипт запускается после того, как браузер встречает ещё один <div>, теперь её длина – 2.',\r\n      },\r\n      {\r\n        'Для чего используются свойства innerHTML/outerHTML? Каковы нюансы их использования?':\r\n          'innerHTML: содержимое элемента Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки. Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице. Будьте внимательны: «innerHTML+=» осуществляет перезапись Мы можем добавить HTML к элементу, используя elem.innerHTML+=\"ещё html\". Другими словами, innerHTML+= делает следующее: Старое содержимое удаляется. На его место становится новое значение innerHTML (с добавленной строкой). outerHTML: HTML элемента целиком Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент. Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте. использование outerHTML не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код. То есть, при div.outerHTML=... произошло следующее: div был удалён из документа. Вместо него был вставлен другой HTML <p>Новый элемент</p>. В div осталось старое значение. Новый HTML не сохранён ни в какой переменной. Здесь легко сделать ошибку: заменить div.outerHTML, а потом продолжить работать с div, как будто там новое содержимое. Но это не так. Подобное верно для innerHTML, но не для outerHTML. Мы можем писать в elem.outerHTML, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.',\r\n      },\r\n      {\r\n        'В чем отличия между innerHTML и innerText?':\r\n          'В отличие от innerText, однако, innerHTML позволяет работать с форматированным текстом HTML и не выполняет автоматическое кодирование и декодирование текста. Другими словами, innerText извлекает и устанавливает содержимое тега в виде простого текста, тогда как innerHTML извлекает и устанавливает содержимое в формате HTML. Node.innerText - это свойство, позволяющее задавать или получать текстовое содержимое элемента и его потомков. В качестве геттера, свойство приближается к тексту, который пользователь получит, если он выделит содержимое элемента курсором, затем копирует его в буфер обмена. Свойство интерфейса Element innerHTML устанавливает или получает HTML или XML разметку дочерних элементов.',\r\n      },\r\n      {\r\n        'Можно ли использовать DOM API языками программирования отличными от JS?':\r\n          'DOM спроектирован таким образом, чтобы быть независимым от любого конкретного языка программирования, обеспечивая структурное представление документа согласно единому и последовательному API. Хотя мы всецело сфокусированы на JavaScript в этой справочной документации, реализация DOM может быть построена для любого языка, как в следующем примере на Python',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    API: [\r\n      {\r\n        'Объяснить отличия и основные особенности следующих видов API: REST API, JSON API, JSON RPC, GraphQL':\r\n          'Аббревиатура API означает Application Programming Interface (программный интерфейс приложения). Это, как следует из названия, интерфейс, с помощью которого взаимодействуют стороны обмена.',\r\n      },\r\n      {\r\n        'REST API':\r\n          'REST расшифровывается как REpresentational State Transfer. Это был термин, первоначально введен Роем Филдингом (Roy Fielding), который также был одним из создателей протокола HTTP. Отличительной особенностью сервисов REST является то, что они позволяют наилучшим образом использовать протокол HTTP. HTTP обеспечивает базовый уровень для создания веб-сервисов. Поэтому важно понимать HTTP. Вот несколько ключевых абстракций. Ресурс Ресурс — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие: Конкретный пользователь Конкретная задача Список задач URI ресурса Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например: Создать пользователя: POST /users Удалить пользователя: DELETE /users/1 Получить всех пользователей: GET /users Получить одного пользователя: GET /users/1 REST и Ресурсы Важно отметить, что с REST вам нужно думать о приложении с точки зрения ресурсов: Определите, какие ресурсы вы хотите открыть для внешнего мира Используйте глаголы, уже определенные протоколом HTTP, для выполнения операций с этими ресурсами. Вот как обычно реализуется служба REST: Формат обмена данными: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML Транспорт: всегда HTTP. REST полностью построен на основе HTTP. Определение сервиса: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger. REST фокусируется на ресурсах и на том, насколько эффективно вы выполняете операции с ними, используя HTTP. Особенность REST в том, что сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции.',\r\n      },\r\n      {\r\n        'JSON API':\r\n          'JSON api - контракт о том что данные с сервера будут приходить в JSON формате. Данные могут приходить как ответы к REST запросам. А так же JSON api может быть реализован поверх других транспортов (websocket, webrtc). REST не исключает, но и не ограничивается JSON api.',\r\n      },\r\n      {\r\n        'JSON RPC':\r\n          'Суть подхода достаточно примитивна Запрос включает в себя 4 поля: jsonrpc — всегда будет “2.0”, указывает версию протокола. method — название метода (функции), который нужно вызвать. params — опциональное поле, нагрузка к вызову (аргументы функции). id — опциональное поле, уникальный идентификатор вызова. Если вы хотите получить значение от вызванной функции, то вы должны сгенерировать id на стороне клиента и при ответе вы сможете понять, на какой именно вызов пришел ответ, сопоставив id ответа. Если вы не отправили id, то это означает, что ответ вас не интересует и от сервера вы ничего не получите. Такой вызов называется нотификацией. Ответ может иметь следующие поля: jsonrpc — всегда будет “2.0”, указывает версию протокола. result — тело ответа (возвращаемое значение функции). id — уникальный идентификатор ответа. Он нужен для того, чтобы клиент мог сопоставить, на какой запрос он получил ответ. error — в случае ошибки вместо result, вы получите поле error, содержащее в себе code (код ответа: по протоколу их может быть шесть) и message (человекопонятное описание ошибки).Вишенка на торте — это Batch-запрос! Это означает, что мы можем слепить несколько отдельных ajax запросов в один и отдать его серверу в виде массива запросов. А при получении по заданным id мы поймем, на какой запрос получили ответ.',\r\n      },\r\n      {\r\n        GraphQL:\r\n          'GraphQL — язык запросов с открытым исходным кодом, разработанный Facebook. Он создавался как более эффективная альтернатива REST для разработки и использования программных интерфейсов приложений. GraphQL обладает множеством достоинств, например: Вы получаете информацию именно в том объёме, в котором запрашиваете. В отличие от REST, ответ на запрос не будет содержать ненужных данных. Вам будет необходима всего одна конечная точка, никаких дополнительных версий для единственного API. GraphQL — сильно типизированный язык, что позволяет предварительно оценить корректность запроса в рамках системы типов этого синтаксиса, до исполнения. Это позволяет разрабатывать более мощные API. Для создания схем в GraphQL используется собственный язык Schema Definition Language (SDL). SDL обладает интуитивно понятным синтаксисом и универсален для любой используемой технологии.  Типы — одна из основных особенностей GraphQL. Это кастомные объекты, которые определяют, как будет выглядеть API. Например, при разработке программного интерфейса для приложения, взаимодействующего с соцсетями, в API стоит объявить типы Posts, Users, Likes, Groups. В типах есть поля, возвращающие определённые разновидности данных. Например, при создании типа User, в него стоит включить поля name, email, и age. Поля типов могут быть любыми и всегда возвращают данные в формате Int, Float, String, Boolean, ID, List of Object Types, или Custom Objects Types. В GraphQL изменения — способ модифицировать данные на сервере и получить обработанную информацию. Этот процесс можно рассматривать как аналогичный концепции CUD (Create, Update, Delete) в стандарте REST. В двух словах, GraphQL это синтаксис, который описывает как запрашивать данные, и, в основном, используется клиентом для загрузки данных с сервера. GraphQL имеет три основные характеристики: Позволяет клиенту точно указать, какие данные ему нужны. Облегчает агрегацию данных из нескольких источников. Использует систему типов для описания данных. Facebook придумал концептуально простое решение: вместо того, чтобы иметь множество \"глупых\" endpoint, лучше иметь один \"умный\" endpoint, который будет способен работать со сложными запросами и придавать данным такую форму, какую запрашивает клиент. GraphQL поначалу может показаться сложным, потому что это технология, которая затрагивает многие области современной разработки. Но уделив время чтобы понять основные концепции, я думаю вы поймёте что многое из этого имеет смысл.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Literatura: [\r\n      { 'Изучить книгу С. Макконнелла \"Совершенный код\".': '' },\r\n      {\r\n        'Изучить книгу \"Принцип пирамиды Минто\" (можно только саммари с smartreading.ru).':\r\n          '',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    React: [\r\n      {\r\n        'Reconciliation Что такое? Какую функцию выполняет? Каким образом reconciliation алгоритм использует тип элемента (что происходит, если тип изменился, не изменился и т.д.)?':\r\n          'React реализует эвристический алгоритм O(n), который основывается на двух предположениях: Два элемента с разными типами произведут разные деревья. Разработчик может указать, какие дочерние элементы могут оставаться стабильными между разными рендерами с помощью пропа key. При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов. Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают componentWillUnmount(). При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают componentWillMount(), а затем componentDidMount(). Любое состояние, связанное со старым деревом, теряется. Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится. При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. Сравнивая эти элементы, React знает, что нужно модифицировать только className у лежащего в основе DOM-узла. Обновляя style, React также знает, что нужно обновлять только изменившиеся свойства. Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает componentWillReceiveProps() и componentWillUpdate() на базовом экземпляре. Далее вызывается метод render() и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты. По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие.',\r\n      },\r\n      {\r\n        'Атрибут key Зачем нужен? Почему лучше не использовать индекс элемента массива в качестве значения? Когда этим правилом можно пренебречь? Должно ли значение атрибута key быть уникальными для всего отрисованного дерева (по аналогии с html-атрибутом id)? Имеется список из нескольких элементов:<ul> {list.map((text, i) => (<li key={i}>{text} <input /> </li>))}</ul>Предположим, что в каждом инпуте содержится какой-то текст. Если добавить в начало list еще один элемент, то какой из инпутов окажется пустым и почему?':\r\n          'Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально. В крайнем случае вы можете передать индекс элемента массива в качестве ключа. Это работает хорошо в случае, если элементы никогда не меняют порядок. Перестановки элементов вызывают замедление. Важно помнить, что алгоритм согласования — это деталь реализации. React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов функции render для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он применит различия только следуя правилам, которые были обозначены в предыдущих разделах. React полагается на эвристику, следовательно, если предположения, на которых она основана, не соблюдены, пострадает производительность. Алгоритм не будет пытаться сопоставить поддеревья компонентов разных типов. Если вы заметите за собой, что пытаетесь чередовать компоненты разных типов с очень схожим выводом, то желательно сделать их компонентами одного типа. На практике мы не выявили с этим проблем. Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью Math.random()) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов.',\r\n      },\r\n      {\r\n        'Pure Components Что такое? Зачем нужны? Чем отличаются от обычных компонент? Какой есть аналог для функциональных компонент? Когда их стоит, а когда не стоит использовать?':\r\n          'При работе с обычным компонентом, вы меняете его состояние, а соответственно вызываете ре-рендер, использую встроенную функцию setState. При этом, повторная отрисовка происходит в любом случае. Для, того, что бы это контролировать, вы можете использовать упомянутый выше shouldComponentUpdate, и прописать там сою логику обработки нового state и новых props. Этот метод принимает два аргумента: nextProps и nextState, которые вы можете сравнить с актуальными пропсами и стейтом, и описать логику, в каком случае нужно вызывать обновление компонента, а dкаком нет. shouldComponentUpdate(nextProps, nextState) { return nextState.update !== this.state.update; } В React.Component данный метод всегда возвращает true, если только вы сами, в ручную, не опишите необходимые проверки. Из-за этого, любой вызов setState, или получение новых props, будут вызывать ре-рендер.  При работе с React.PureComponent ситуация другая. Он выполняет “неглубокую” проверку в shouldComponentUpdate (это уже реализовано “из коробки”), и, если данные были изменены, то только тогда срабатывает обновление. Проверка в “чистом” компоненте выглядит следующим образом: shouldComponentUpdate(nextProps, nextState) { return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state); } Поскольку проверка “поверхностная”, то и полного сравнения объектов не происходит, сравниваются лишь ссылки на них. Это значит, что если вы, например, не передадите новые пропсы, а просто измените старые “напрямую”, то PureComponent выдаст false в shouldComponentUpdate, и никакого обновления не произойдёт.',\r\n      },\r\n      {\r\n        'Какие ограничения накладываются на пропсы при использовании Pure Component?Почему использование Pure Component таким образом не приносит никакой пользы (укажите на конкретные проблемные места):':\r\n          'Это решается с помощью иммутабельности данных. Проще говоря, не изменяйте то, что есть, а создавайте новое на основе старого. В ES6 есть всё необходимое для этого, вспомните про тот же spread оператор, а также про разные методы массивов, вроде map, filter, reduce. Ещё одна проблема с PureComponent заключается в том, что он может блокировать обновления и всех потомков, если shouldComponentUpdate вернул false. Поэтому использовать его, в качестве родительского компонента не стоит. Лучше юзайте обычный Component для каких-то containers-компонентов, а Pure для presentational-компонентов.',\r\n      },\r\n      {\r\n        'Performance Что такое windowing или virtualizing списков? Всегда ли происходит перерисовка DOM-элемента, если shouldComponentUpdate вернул true?':\r\n          'Если ваше приложение рендерит длинные списки данных (сотни или тысячи строк), мы рекомендуем использовать метод известный как «оконный доступ». Этот метод рендерит только небольшое подмножество строк в данный момент времени и может значительно сократить время, необходимое для повторного рендера компонентов, а также количество создаваемых DOM-узлов. react-window и react-virtualized — это популярные библиотеки для оконного доступа. Они предоставляют несколько повторно используемых компонентов для отображения списков, сеток и табличных данных. Если вы хотите использовать что-то более специфическое для вашего конкретного случая, то вы можете создать собственный компонент с оконным доступом. React создаёт и поддерживает внутреннее представление отображаемого пользовательского интерфейса. Оно также включает React-элементы возвращаемые из ваших компонентов. Это представление позволяет React избегать создания DOM-узлов и не обращаться к текущим без необходимости, поскольку эти операции могут быть медленнее, чем операции с JavaScript-объектами. Иногда его называют «виртуальный DOM», но в React Native это работает точно так же. Когда изменяются пропсы или состояние компонента, React решает нужно ли обновление DOM, сравнивая возвращённый элемент с ранее отрендеренным. Если они не равны, React обновит DOM. Несмотря на то, что React обновляет только изменённые DOM-узлы, повторный рендеринг всё же занимает некоторое время. В большинстве случаев это не проблема, но если замедление заметно, то вы можете всё ускорить, переопределив метод жизненного цикла shouldComponentUpdate, который вызывается перед началом процесса ререндеринга. Реализация этой функции по умолчанию возвращает true, указывая React выполнить обновление: shouldComponentUpdate(nextProps, nextState) { return true; } Если вы знаете ситуации, в которых ваш компонент не нуждается в обновлении, вы можете вернуть false из shouldComponentUpdate, чтобы пропустить весь процесс рендеринга, включая вызов render() и так далее ниже по иерархии. В большинстве случаев вместо того, чтобы писать shouldComponentUpdate() вручную, вы можете наследоваться от React.PureComponent. Это эквивалентно реализации shouldComponentUpdate() с поверхностным сравнением текущих и предыдущих пропсов и состояния. https://ru.reactjs.org/docs/optimizing-performance.html',\r\n      },\r\n      {\r\n        'Synthetic Events Что такое и зачем нужны?':\r\n          'Ваши обработчики событий получают экземпляр SyntheticEvent, это кроссбраузерная обёртка над нативным экземпляром события. У неё такой же интерфейс, как и у нативного события, включая методы stopPropagation() и preventDefault(). Эта обёртка помогает событиям работать одинаково во всех браузерах. Если вам всё-таки нужно получить нативное браузерное событие, обратитесь к атрибуту nativeEvent. Вот перечень атрибутов объекта SyntheticEvent: boolean bubbles boolean cancelable DOMEventTarget currentTarget boolean defaultPrevented number eventPhase boolean isTrusted DOMEvent nativeEvent void preventDefault() boolean isDefaultPrevented() void stopPropagation() boolean isPropagationStopped() void persist() DOMEventTarget target number timeStamp string type События SyntheticEvent содержатся в пуле. Это означает, что объект SyntheticEvent будет повторно использован, а все его свойства будут очищены после вызова обработчика события. Это необходимо из соображений производительности. Именно поэтому нельзя использовать синтетические события асинхронно. React нормализует события так, чтобы они содержали одинаковые свойства во всех браузерах. Обработчики ниже вызываются на фазе всплытия (bubbling). А чтобы зарегистрировать событие на фазе перехвата (capture), просто добавьте Capture к имени события; например, вместо использования onClick используйте onClickCapture, чтобы обработать событие на фазе перехвата. События буфера обмена Композиционные события События клавиатуры События фокуса События формы Общие события События мыши События курсора События выбора Сенсорные события События UI События колёсика мыши События медиа-элементов События изображений События анимаций События переходов Другие события',\r\n      },\r\n      {\r\n        'Пусть на какое-то событие на <input /> назначено 2 обработчика: один через атрибут on..., а другой через addEventListener. В чем разница между добавлением обработчиков первым и вторым способом?В каком порядке могут выполняться обработчики? От чего это зависит? Может ли один из обработчиков отменить выполнение второго обработчика?Какие проблемы могут возникнуть из-за использования обработчика, навешанного через addEventListener?':\r\n          'При использовании React обычно не нужно вызывать addEventListener, чтобы добавить обработчики в DOM-элемент после его создания. Вместо этого добавьте обработчик сразу после того, как элемент отрендерился. В компоненте, определённом с помощью ES6-класса, в качестве обработчика события обычно выступает один из методов класса.',\r\n      },\r\n      {\r\n        'Что будет выведено на экран при клике на кнопку и почему class Component extends React.Component { componentDidMount() { document.addEventListener(\"click\", this.handleDocumentClick); } render() { return <button onClick={this.handleButtonClick}>Click me</button>; } handleButtonClick(e) { e.stopPropagation(); alert(\"click button\"); } handleDocumentClick() { alert(\"click document\"); } }?':\r\n          'Будет выведено 2 сообщения-алерта, сначала клик-баттон(который мы привязываем в рендер функции), а потом клик документ(который мы привязываем в компонентДидМоунт)',\r\n      },\r\n      {\r\n        'Context. Что такое Context object? Как его создать? Из чего он состоит?Какими способами можно получить доступ к Context в компоненте?Как обновить Context из глубоко вложенной компоненты (т.е. пробрасывать коллбэк в таком случае - очень неудобное решение)?Можно ли вкладывать провайдеры одного и того же Context друг в друга? Из какого провайдера при этом будут браться данные?Что произойдет, если значение в Context-е изменится, а между Provider и подписчиком находится Pure Component?':\r\n          'В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, этот способ может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.  React.createContext const MyContext = React.createContext(defaultValue); Создание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов. Аргумент defaultValue используется только в том случае, если для компонента нет подходящего Provider выше в дереве. Это может быть полезно для тестирования компонентов в изоляции без необходимости оборачивать их. Обратите внимание: если передать undefined как значение Provider, компоненты, использующие этот контекст, не будут использовать defaultValue.  Context.Provider <MyContext.Provider value={/* некоторое значение */}> Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения. Принимает проп value, который будет передан во все компоненты, использующие этот контекст и являющиеся потомками этого Provider компонента. Один Provider может быть связан с несколькими компонентами, потребляющими контекст. Так же Provider компоненты могут быть вложены друг в друга, переопределяя значение контекста глубже в дереве. Все потребители, которые являются потомками Provider, будут повторно рендериться, как только проп value у Provider изменится. Потребитель (включая .contextType и useContext) перерендерится при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью shouldComponentUpdate. Изменения определяются с помощью сравнения нового и старого значения, используя алгоритм, аналогичный Object.is. class MyClass extends React.Component { componentDidMount() { let value = this.context; /* выполнить побочный эффект на этапе монтирования, используя значение MyContext */ } componentDidUpdate() { let value = this.context; /* ... */ } componentWillUnmount() { let value = this.context; /* ... */ } render() { let value = this.context; /* отрендерить что-то, используя значение MyContext */ } } MyClass.contextType = MyContext; В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе. <MyContext.Consumer> {value => /* отрендерить что-то, используя значение контекста */} </MyContext.Consumer> Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext(). Объекту Context можно задать строковое свойство displayName. React DevTools использует это свойство при отображении контекста. Довольно часто необходимо изменить контекст из компонента, который находится где-то глубоко в дереве компонентов. В этом случае вы можете добавить в контекст функцию, которая позволит потребителям изменить значение этого контекста: theme-context.js // Убедитесь, что форма значения по умолчанию, // передаваемого в createContext, совпадает с формой объекта, // которую ожидают потребители контекста. export const ThemeContext = React.createContext({ theme: themes.dark, toggleTheme: () => {}, }); Чтобы последующие рендеры (связанные с контекстом) были быстрыми, React делает каждого потребителя контекста отдельным компонентом в дереве.Контекст использует сравнение по ссылкам, чтобы определить, когда запускать последующий рендер. Из-за этого существуют некоторые подводные камни, например, случайные повторные рендеры потребителей, при перерендере родителя Provider-компонента.',\r\n      },\r\n      {\r\n        'Higher-Order Components Может ли HOC оборачивать несколько компонент разом? Зачем делать функцию, которая возвращает функцию высшего порядка, создающую HOC? Как это помогает сделать HOC композабельным? Какие проблемы могут возникать, если HOC не будет прокидывать входящие props дальше в потомка? Как обрабатывать displayName при создании HOC? Какие проблемы могут возникать, если каждый раз билдить HOC в самом render? Какие проблемы могут возникать, если HOC не будет копировать все статичные методы потомка? Как HOC влияет на forwarded ref?':\r\n          'Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов. Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. const EnhancedComponent = higherOrderComponent(WrappedComponent); Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay. Традиционные компоненты подразумевают многократное использование, но не позволяют с лёгкостью решить некоторые проблемы. Рассмотрим пример CommentList, который получает список комментариев из внешнего источника данных и отображает их.  Разница между CommentList и BlogPost в том, что они вызывают разные методы DataSource и рендерят разный вывод. Однако в большинстве своём они похожи: Оба компонента подписываются на оповещения от DataSource при монтировании. Оба меняют внутреннее состояние при изменении DataSource. Оба отписываются от DataSource при размонтировании. Можете представить, что в больших приложениях связка «подписаться на DataSource, затем вызвать setState» повторяется очень часто. Было бы здорово абстрагировать эту функциональность и использовать её в других компонентах. Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные: const CommentListWithSubscription = withSubscription( CommentList, (DataSource) => DataSource.getComments() ); const BlogPostWithSubscription = withSubscription( BlogPost, (DataSource, props) => DataSource.getBlogPost(props.id) ); Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы. Когда CommentListWithSubscription и BlogPostWithSubscription рендерятся, они передают в CommentList и BlogPost обновлённые данные DataSource через проп data Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Не мутируйте оборачиваемый компонент. Используйте композицию. Не все HOC выглядят одинаково. Некоторые принимают всего лишь один аргумент — оборачиваемый компонент: const NavbarWithRouter = withRouter(Navbar); Обычно HOC принимают несколько аргументов. В данном примере из Relay, мы используем объект конфигурации с описанием данных для компонента: const CommentWithRelay = Relay.createContainer(Comment, config); Самый распространённый способ вызова HOC выглядит так: // `connect` из React Redux const ConnectedComment = connect(commentSelector, commentActions)(CommentList); Удивлены? Давайте разберём эту строку по частям. // Вызов функции connect возвращает другую функцию const enhance = connect(commentListSelector, commentListActions); // Эта функция и есть HOC. Она возвращает компонент, подключённый к хранилищу Redux const ConnectedComment = enhance(CommentList); Другими словами, connect — это функция высшего порядка, которая возвращает компонент высшего порядка! Такая форма может показаться запутанной и ненужной, но есть и преимущества. Вызов connect возвращает HOC с подписью Component => Component. Функции с одинаковым типом результата и единственного аргумента легко совмещаются в композиции. Самый распространённый способ — это обернуть имя оборачиваемого компонента. Например, если вы назвали компонент высшего порядка withSubscription, а имя оборачиваемого компонента было CommentList, то отображаемое имя будет WithSubscription(CommentList): function withSubscription(WrappedComponent) { class WithSubscription extends React.Component {/* ... */} WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`; return WithSubscription; } function getDisplayName(WrappedComponent) { return WrappedComponent.displayName || WrappedComponent.name || \"Component\"; }  Алгоритм сравнения React (известный как согласование или reconciliation) использует тождественность компонентов чтобы определить нужно ли обновить существующее поддерево, или убрать и монтировать вместо него новое. Если компонент, полученный из render, идентичен (===) компоненту из предыдущего рендера, то React рекурсивно продолжит сравнивать поддерево. Если компоненты не равны, React полностью удалит и заменит старое поддерево. Обычно нас это не беспокоит. Однако, важно учитывать что мы не можем применять компоненты высшего порядка внутри рендер-метода компонента: render() { // Мы создаём новую версию EnhancedComponent при каждом рендере // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // Мы каждый раз размонтируем и монтируем целиком всё поддерево! return <EnhancedComponent />; } Проблема не только в производительности. Повторное монтирование компонента обнуляет его состояние, а также состояние его дочерних компонентов. Иногда бывает полезно определить статические методы компонента. Например, статический метод getFragment библиотеки Relay позволяет составить композицию из фрагментов данных GraphQL. Когда мы применяем HOC, то заворачиваем оригинальный компонент в контейнер. Поэтому у нового компонента не будет статических методов оригинального компонента. // Определим статический метод WrappedComponent.staticMethod = function() {/*...*/} // Теперь применим HOC const EnhancedComponent = enhance(WrappedComponent); // У расширенного компонента нет статических методов typeof EnhancedComponent.staticMethod === \"undefined\" // true Скопируйте недостающие методы в контейнер: function enhance(WrappedComponent) { class Enhance extends React.Component {/*...*/} // Мы должны точно знать какие методы копировать :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance; } К сожалению, вы должны точно знать какие методы копировать. Вы можете воспользоваться hoist-non-react-statics, чтобы автоматически скопировать не связанные с React статические методы По соглашению компоненты высшего порядка передают оборачиваемому компоненту все пропсы, кроме рефов. ref на самом деле не проп, как, например, key, и поэтому иначе обрабатывается React. Реф элемента, созданного компонентом из HOC, будет указывать на экземпляр ближайшего в иерархии контейнера, а не на оборачиваемый компонент. Вы можете решить эту проблему с помощью API-метода React.forwardRef',\r\n      },\r\n      {\r\n        'Объяснить почему следующий подход может служить альтернативой HOC-ам? Когда таким образом заменить HOC не получится? render() {return (<WithUser>{user => (<span>{user.name}</span>)}</WithUser>)}':\r\n          'Термин «рендер-проп» относится к возможности компонентов React разделять код между собой с помощью пропа, значение которого является функцией. Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера. <DataProvider render={data => ( <h1>Привет, {data.target}</h1> )}/> Такой подход, в частности, применяется в библиотеках React Router, Downshift и Formik.',\r\n      },\r\n      {\r\n        'Что такое Render Prop? Где и как может использоваться такой приём?':\r\n          'Термин «рендер-проп» относится к возможности компонентов React разделять код между собой с помощью пропа, значение которого является функцией. Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера. <DataProvider render={data => ( <h1>Привет, {data.target}</h1> )}/> Такой подход, в частности, применяется в библиотеках React Router, Downshift и Formik. Компоненты — это основа повторного использования кода в React. Однако бывает неочевидно, как сделать, чтобы одни компоненты разделяли своё инкапсулированное состояние или поведение с другими компонентами, заинтересованными в таком же состоянии или поведении.  Иными словами, рендер-проп — функция, которая сообщает компоненту что необходимо рендерить. Эта техника позволяет сделать легко портируемым поведение, которое мы хотим повторно использовать. Для этого следует отрендерить компонент <Mouse> с помощью рендер-пропа, который сообщит, где отрендерить курсор с текущим положением (x, y). Один интересный момент касательно рендер-пропсов заключается в том, что вы можете реализовать большинство компонентов высшего порядка (HOC), используя обычный компонент вместе с рендер-пропом. Например, если для вас предпочтительней HOC withMouse вместо компонента <Mouse>, вы можете создать обычный компонент <Mouse> вместе с рендер-пропом: // Если вам действительно необходим HOC по некоторым причинам, вы можете просто // создать обычный компонент с рендер-пропом! function withMouse(Component) { return class extends React.Component { render() { return ( <Mouse render={mouse => ( <Component {...this.props} mouse={mouse} /> )}/> ); } } } Таким образом, рендер-пропы позволяют реализовать любой из описанных выше паттернов. Важно запомнить, что из названия паттерна «рендер-проп» вовсе не следует, что для его использования вы должны обязательно называть проп render. На самом деле, любой проп, который используется компонентом и является функцией рендеринга, технически является и «рендер-пропом». Несмотря на то, что в вышеприведённых примерах мы используем render, мы можем также легко использовать проп children! <Mouse children={mouse => ( <p>Текущее положение курсора мыши: {mouse.x}, {mouse.y}</p> )}/> И запомните, проп children не обязательно именовать в списке «атрибутов» вашего JSX-элемента. Вместо этого, вы можете поместить его прямо внутрь элемента! <Mouse> {mouse => ( <p>Текущее положение курсора мыши: {mouse.x}, {mouse.y}</p> )} </Mouse>  Будьте осторожны при использовании рендер-проп вместе с React.PureComponent Использование рендер-пропа может свести на нет преимущество, которое даёт React.PureComponent, если вы создаёте функцию внутри метода render. Это связано с тем, что поверхностное сравнение пропсов всегда будет возвращать false для новых пропсов и каждый render будет генерировать новое значение для рендер-пропа. Что мы получаем при использовании render props? Переиспользование логики — отделяя отображение от логики, нам не нужно подгонять логику под каждый компонент или визуальное представление. Чистый и хорошо читаемый JSX. Улучшается структура и функциональная составляющая наших React приложений. Вы тоже беспокоитесь о работе ваших React приложений? Открыты вакансии! * Помните, что render props является паттерном и может быть реализован несколькими способами — только вы должны выбирать, что использовать с вашем случае.',\r\n      },\r\n      {\r\n        'Как работают Provider и connect из react-redux (включая назначение mapStateToProps и работу механизма подписок)?':\r\n          'Redux — это библиотека, предназначенная для создания контейнеров, используемых для хранения состояния приложения. Она предлагает разработчику понятные инструменты для управления состоянием, которые ведут себя предсказуемо. Данная библиотека подходит как для приложений, написанных на чистом JavaScript, так и для проектов, при разработке которых использовались какие-нибудь фреймворки. Redux отличается маленькими размерами, но при этом позволяет писать надёжные приложения, работающие в различных средах.  Пакет react-redux предоставляет привязки React для контейнера состояния Redux, чрезвычайно упрощая подключение React-приложения к хранилищу Redux. Это позволяет разделять компоненты React-приложения, основываясь на их связи с хранилищем. А именно, речь идёт о следующих видах компонентов: Презентационные компоненты. Они отвечают лишь за внешний вид приложения и не осведомлены о состоянии Redux. Они получают данные через свойства и могут вызывать коллбэки, которые также передаются им через свойства. Компоненты-контейнеры. Они ответственны за работу внутренних механизмов приложения и взаимодействуют с состоянием Redux. Их часто создают с использованием react-redux, они могут осуществлять диспетчеризацию действий Redux. Кроме того, они подписываются на изменения состояния. Пакет react-redux обладает очень простым интерфейсом. В частности, самое интересное в этом интерфейсе сводится к следующему: <Provider store> — позволяет создавать обёртку для React-приложения и делать состояние Redux доступным для всех компонентов-контейнеров в его иерархии. connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) — позволяет создавать компоненты высшего порядка. Это нужно для создания компонентов-контейнеров на основе базовых компонентов React. Если вам, в React-компоненте, нужно получать данные из хранилища, или требуется диспетчеризовать действия, или нужно делать и то и другое, вы можете преобразовать обычный компонент в компонент-контейнер, обернув его в компонент высшего порядка, возвращаемый функцией connect() из react-redux. Вот как это выглядит: import React from \"react\"; import { connect } from \"react-redux\"; import Profile from \"./components/Profile\"; function ProfileContainer(props) { return ( props.loggedIn ? <Profile profile={props.profile} /> : <div>Please login to view profile.</div> ) } const mapStateToProps = function(state) { return { profile: state.user.profile, loggedIn: state.auth.loggedIn } } export default connect(mapStateToProps)(ProfileContainer); Вы можете создать компонент-контейнер самостоятельно и вручную подписать компонент на хранилище Redux, используя команду store.subscribe(). Однако использование функции connect() означает применение некоторых улучшений и оптимизаций производительности, которые, вы, возможно, не сможете задействовать при использовании других механизмов. Функция connect(), кроме того, даёт разработчику дополнительную гибкость, позволяя настраивать компоненты-контейнеры на получение динамических свойств, основываясь на свойствах, первоначально им переданных. Это оказывается очень кстати для получения выборок из состояния, основываясь на свойствах, или для привязки генераторов действий к конкретной переменной из свойств. Если ваше React-приложение использует несколько хранилищ Redux, то connect() позволяет легко указывать конкретное хранилище, к которому должен быть подключён компонент-контейнер. Функция connect(), предоставляемая пакетом react-redux, может принимать до четырёх аргументов, каждый из которых является необязательным. После вызова функции connect() возвращается компонент высшего порядка, который можно использовать для оборачивания любого компонента React. Так как функция возвращает компонент высшего порядка, её нужно вызвать повторно, передав базовый компонент React, для того, чтобы конвертировать его в компонент-контейнер: const ContainerComponent = connect()(BaseComponent); Вот сигнатура функции connect(): connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])  ',\r\n      },\r\n      {\r\n        'mapStateToProps?':\r\n          'Аргумент mapStateToProps является функцией, которая возвращает либо обычный объект, либо другую функцию. Передача этого аргумента connect() приводит к подписке компонента-контейнера на обновления хранилища Redux. Это означает, что функция mapStateToProps будет вызываться каждый раз, когда состояние хранилища изменяется. Если вам слежение за обновлениями состояния не интересно, передайте connect() в качестве значения этого аргумента undefined или null. Функция mapStateToProps объявляется с двумя параметрами, второй из которых является необязательным. Первый параметр представляет собой текущее состояние хранилища Redux. Второй параметр, если его передают, представляет собой объект свойств, переданных компоненту: const mapStateToProps = function(state) { return { profile: state.user.profile, loggedIn: state.auth.loggedIn } } export default connect(mapStateToProps)(ProfileComponent); Если из mapStateToProps будет возвращён обычный объект, то возвращённый объект stateProps объединяется со свойствами компонента. Получить доступ к этим свойствам в компоненте можно так: function ProfileComponent(props) { return ( props.loggedIn ? <Profile profile={props.profile} /> : <div>Please login to view profile.</div> ) } Если же mapStateToProps возвращает функцию, то эта функция используется как mapStateToProps для каждого экземпляра компонента. Это может пригодиться для улучшения производительности рендеринга и для мемоизации. Если вы не используете собственную реализацию mapDispatchToProps, представленную объектом или функцией, будет использована стандартная реализация, при применении которой осуществляется внедрение метода хранилища dispatch() в качестве свойства для компонента. Пользоваться этим свойством в компоненте можно так: import React from \"react\"; import { connect } from \"react-redux\"; import { updateComment, deleteComment } from \"./actions\"; function Comment(props) { const { id, content } = props.comment; // Вызов действий через props.dispatch() const editComment = () => props.dispatch(updateComment(id, content)); const removeComment = () => props.dispatch(deleteComment(id)); return ( <div> <p>{ content }</p> <button type=\"button\" onClick={editComment}>Edit Comment</button> <button type=\"button\" onClick={removeComment}>Remove Comment</button> </div> ) } export default connect()(Comment); Если в качестве аргумента mapDispatchToProps используется объект, то каждая функция в объекте будет воспринята в качестве генератора действий Redux и обёрнута в вызов метода хранилища dispatch(), что позволит вызывать его напрямую. Получившийся в результате объект с генераторами действий, dispatchProps, будет объединён со свойствами компонента. При использовании в качестве аргумента mapDispatchToProps функции программист должен самостоятельно позаботиться о возврате объекта dispatchProps, который осуществляет привязку генераторов действий с использованием метода хранилища dispatch(). Эта функция принимает, в качестве первого параметра, метод хранилища dispatch(). Как и в случае с mapStateToProps, функция также может принимать необязательный второй параметр ownProps, который описывает маппинг с исходными свойствами, переданными компоненту. Если эта функция возвращает другую функцию, то возвращённая функция используется в роли mapDispatchToProps, что может быть полезным для целей повышения производительности рендеринга и мемоизации. Вспомогательная функция bindActionCreators() из Redux может быть использована внутри этой функции для осуществления привязки генераторов действий к методу хранилища dispatch(). В следующем примере показано использование, в роли mapDispatchToProps, функции. Здесь же продемонстрирована работа со вспомогательной функцией bindActionCreators(), применяемой для привязки генераторов действий для работы с комментариями к props.actions компонента React: import React from \"react\"; import { connect } from \"react-redux\"; import { bindActionCreators } from \"redux\"; import * as commentActions from \"./actions\"; function Comment(props) { const { id, content } = props.comment; const { updateComment, deleteComment } = props.actions; // Вызов действий из props.actions const editComment = () => updateComment(id, content); const removeComment = () => deleteComment(id); return ( <div> <p>{ content }</p> <button type=\"button\" onClick={editComment}>Edit Comment</button> <button type=\"button\" onClick={removeComment}>Remove Comment</button> </div> ) } const mapDispatchToProps = (dispatch) => { return { actions: bindActionCreators(commentActions, dispatch) } } export default connect(null, mapDispatchToProps)(Comment);',\r\n      },\r\n      {\r\n        'mapDispatchToProps?':\r\n          'Аргумент mapDispatchToProps может быть либо объектом, либо функцией, которая возвращает либо обычный объект, либо другую функцию. Для того чтобы лучше проиллюстрировать работу mapDispatchToProps, нам понадобятся генераторы действий. Предположим, у нас имеются следующие генераторы: export const writeComment = (comment) => ({ comment, type: \"WRITE_COMMENT\" }); export const updateComment = (id, comment) => ({ id, comment, type: \"UPDATE_COMMENT\" }); export const deleteComment = (id) => ({ id, type: \"DELETE_COMMENT\" }); Теперь рассмотрим различные варианты использования mapDispatchToProps.',\r\n      },\r\n      {\r\n        'mergeProps?':\r\n          'Если функции connect() передаётся аргумент mergeProps, то он представляет собой функцию, которая принимает следующие три параметра: stateProps — объект свойств, возвращённый из вызова mapStateToProps(). dispatchProps — объект свойств с генераторами действий из mapDispatchToProps(). ownProps — исходные свойства, полученные компонентом. Эта функция возвращает простой объект со свойствами, который будет передан заключённому в обёртку компоненту. Это полезно для осуществления условного маппинга части состояния хранилища Redux или генераторов действий на основе свойств. Если connect() не передают эту функцию, то используется её стандартная реализация: const mergeProps = (stateProps, dispatchProps, ownProps) => { return Object.assign({}, ownProps, stateProps, dispatchProps) }  https://habr.com/ru/company/ruvds/blog/423157/',\r\n      },\r\n    ],\r\n  },\r\n];\r\nexport default Junior03;\r\n","const Middle01 = [\r\n  {\r\n    OOP: [\r\n      {\r\n        'Что такое ООП?':\r\n          'Объектно-ориентированное программирование (в дальнейшем ООП) — парадигма программирования, в которой основными концепциями являются понятия объектов и классов.',\r\n      },\r\n      {\r\n        'Что такое класс?':\r\n          'Класс — это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию. Класс — это шаблон кода, по которому создаётся какой-то объект. Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов). С точки зрения структуры программы, класс является сложным типом данных.',\r\n      },\r\n      {\r\n        'Что такое объект?':\r\n          'Объект — это сущность, экземпляр класса, которой можно посылать сообщения и которая может на них реагировать, используя свои данные. Данные объекта скрыты от остальной программы. Сокрытие данных называется инкапсуляцией. Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Говоря простым языком, объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе. В данном примере, если класс – это некоторый абстрактный автомобиль из «мира идей», то объект – это конкретный автомобиль, стоящий у вас под окнами.',\r\n      },\r\n      {\r\n        'Что такое иерархия классов?':\r\n          'Наследование — это механизм создания нового класса на основе уже существующего. При этом к существующему классу могут быть добавлены новые элементы (данные и функции), либо существующие функции могут быть изменены. Основное назначение механизма наследования — повторное использование кодов, так как большинство используемых типов данных являются вариантами друг друга, и писать для каждого свой класс нецелесообразно. Объекты разных классов и сами классы могут находиться в отношении наследования, при котором формируется иерархия объектов, соответствующая заранее предусмотренной иерархии классов.  Иерархия классов позволяет определять новые классы на основе уже имеющихся. Имеющиеся классы обычно называют базовыми(иногда порождающими), а новые классы, формируемые на основе базовых, – производными (порожденными, классами-потомками или наследниками). Производные классы «получают наследство» – данные и методы своих базовых классов, и могут пополняться собственными компонентами (данными и собственными методами). Наследуемые компоненты не перемещаются в производный класс, а остаются в базовых классах. Сообщение, обработку которого не могут выполнить методы производного класса, автоматически передается в базовый класс. Если для обработки сообщения нужны данные, отсутствующие в производном классе, то их пытаются отыскать автоматически в базовом классе.',\r\n      },\r\n      {\r\n        'Что такое статический метод? Является ли класс только из статических методов классом по ООП?':\r\n          'Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса. Например, метод для сравнения двух статей Article.compare(article1, article2) или фабричный метод Article.createTodays(). В объявлении класса они помечаются ключевым словом static. Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.',\r\n      },\r\n      {\r\n        'Что такое абстрактный класс и абстрактный метод?':\r\n          'Особенность абстрактных классов в том, что их можно использовать только как родительский класс, то есть вы не можете создать объект. Для их объявления используется ключевое слово abstract.',\r\n      },\r\n      {\r\n        'Какие есть особенности у каждого из основных типов отношений между классами: композиции, агрегирования, наследования, ассоциации?':\r\n          'В объектно-ориентированных языках программирования существует три способа организации взаимодействия между классами. Наследование — это когда класс-наследник имеет все поля и методы родительского класса, и, как правило, добавляет какой-то новый функционал или/и поля. Наследование описывается словом «является». Легковой автомобиль является автомобилем. Вполне естественно, если он будет его наследником. Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. Вполне естественно, что он не будет являться наследником двигателя (хотя такая архитектура тоже возможна в некоторых ситуациях). Выделяют два частных случая ассоциации: композицию и агрегацию. Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля. class Engine { int power; public Engine(int p) { power = p; } } class Car { string model = \"Porshe\"; Engine engine; public Car() { this.engine = new Engine(360); } } Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра. ``` class Engine { int power; public Engine(int p) { power = p; } } class Car { string model = \"Porshe\"; Engine engine; public Car(Engine someEngine) { this.engine = someEngine; } } Engine goodEngine = new Engine(360); Car porshe = new Car(goodEngine); ``` Между двумя классами/объектами существует разные типы отношений. Самым базовым типом отношений является ассоциация (association), это означает, что два класса как-то связаны между собой, и мы пока не знаем точно, в чем эта связь выражена и собираемся уточнить ее в будущем. Обычно это отношение используется на ранних этапах дизайна, чтобы показать, что зависимость между классами существует, и двигаться дальше. Более точным типом отношений является отношение открытого наследования (отношение «является», IS A Relationship), которое говорит, что все, что справедливо для базового класса справедливо и для его наследника. Именно с его помощью мы получаем полиморфное поведение, абстрагируемся от конкретной реализации классов, имея дело лишь с абстракциями (интерфейсами или базовыми классами) и не обращаем внимание на детали реализации. Во-первых, далеко не все отношения между классами определяются отношением «является», а во-вторых, наследование является самой сильной связью между двумя классами, которую невозможно разорвать во время исполнения (это отношение является статическим и, в строготипизированных языках определяется во время компиляции). В этом случае нам на помощь приходит другая пара отношений: композиция (composition) и агрегация (aggregation). Оба они моделируют отношение «является частью» (HAS-A Relationship) и обычно выражаются в том, что класс целого содержит поля (или свойства) своих составных частей. Грань между ними достаточно тонкая, но важная, особенно в контексте управления зависимостями. Разница между композицией и агрегацией заключается в том, что в случае композиции целое явно контролирует время жизни своей составной части (часть не существует без целого), а в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано Существует несколько достаточно объективных критериев для определения связности дизайна по диаграмме классов: большие иерархии наследования (глубокие или широкие иерархии), и повсеместное использование композиции, а не агрегации скорее всего говорит о сильно связанном дизайне. Большое количество наследования говорит о том, что проектировщики забыли о старом добром совете Банды Четырех, который сводится к тому, что следует предпочесть агрегацию наследованию, поскольку первая дает большую гибкость и динамичность во время исполнения. Обилие же композиции говорит о нарушении Принципа Инверсии Зависимостей, сформулированном Бобом Мартином, которую сейчас можно выразить в терминах агрегации и композиции: предпочитайте агрегацию вместо композиции, поскольку первая стимулирует использование абстракций, а не конкретных классов. Самый простой способ понять эти термины это использовать аналогию из реального мира. Представим себе что у нас есть класс комната и есть два других класса мебель и стена. Мы можем сказать что у комнаты будет какая та мебель и какие то стены. То есть объект комната может использоваться объекты стены и мебель по мере необходимости. Но есть разница в отношения комната — стены и комната — мебель. Разница в том что стены никогда не выйдут из объекта комната. Стены не могут существовать вне комнаты. То есть стена всегда будет создаваться внутри объекта комната. Такая связь называется композиция. И эта связь будет жесткой. Зато мебель очень легко представить за пределами комнаты. Один экземпляр мебели может принадлежать с начало одной комнате потом другой. Такая связь называется ассоциацией или агрегацией. Ассоциация это такой тип при котором объекты будут ссылаться друг на друга. При этом они остаются полностью независимыми друг от друга. Агрегация это тип отношений когда один объект является частью другого. Агрегация образует слабую связь между объектами. Все зависимые классы инициализируются вне основного объекта.Композиция это тип отношений при котором один объект может принадлежать только другому объекту и никому другому. При композиции образуется сильная связь между объектами. При таком типе отношений основной объект полностью обеспечивает жизненный цикл объектов от которых он зависит. Используем еще один пример из реальной жизни. Возьмем машину и двигатель. Машина и двигатель конечно могут существовать друг без друга, но суть не в этом. А в том что при конкретной реализации рабочей машины, один двигатель может принадлежать только одной машине, поэтому для такой связи логично использовать композицию.',\r\n      },\r\n      {\r\n        'Чем композиция отличается от наследования?':\r\n          'Композиция или наследование: что выбрать? В ситуации, когда вроде бы подходит и то и другое, взгляните на дизайн в двух плоскостях: Структура и механическое исполнение бизнес-объектов. Что они обозначают по смыслу и как взаимодействуют. Пока наследование остается внутри одной плоскости, все нормально. Но если иерархия проходит через две плоскости сразу, это плохой симптом. Например, у вас есть один объект внутри другого. Внутренний объект реализует значительную часть поведения внешнего. У внешнего объекта куча прокси-методов, которые тупо пробрасывают параметры во внутренний объект и возвращают от него результат. В этом случае посмотрите, а не стоит ли унаследоваться от внутреннего объекта, хотя бы частично. Разумеется, никакие инструкции не заменят голову на плечах. Когда строишь объектную модель, вообще полезно думать. Но если вам хочется конкретных правил, то пожалуйста. Наследуем, если: Оба класса из одной предметной области Наследник является корректным подтипом (в терминах LSP — прим. пер.) предка Код предка необходим либо хорошо подходит для наследника Наследник в основном добавляет логику Иногда все эти условия выполняются одновременно: в случае моделирования высокоуровневой логики из предметной области при разработке библиотек и расширений для них при дифференциальном программировании (автор снова использует термин \"differential programming\", очевидно, понимая под ним нечто, отличное от DDP — прим. пер.) Если это не ваш случай, то и наследование вам, скорее всего, будет нужно не часто.  Итак, какие же преимущества есть у композиции перед наследованием? 1. Нет конфликта имён, возможного при наследовании. 2. Возможность смены агрегируемого объекта в runtime. 3. Полная замена агрегируемого объекта в классах, производных от класса, включающего агрегируемый объект. В последних двух случаях очень желательно, чтобы сменяемые агрегируемые объекты имели общий интерфейс. А в третьем – чтобы метод, возвращающий такой объект, был виртуальным. 4. Агрегируемое поведение (алгоритм) может включать в себя другие объекты. Что в частности позволяет переиспользовать посредством агрегации другое поведение. 5. При агрегации есть возможность скрыть определённую часть реализации, а также исходные параметры, необходимые поведению, посредством передачи их через конструктор (при наследовании поведению придётся запрашивать их через методы/свойства собственного интерфейса). 1. Итак, если нам необходима возможность смены поведения извне, то композиция, по сравнению с наследованием, имеет принципиально другой тип отношений между объектом поведения и объектом, его использующим. Если при наследовании от абстрактного поведения мы имеем отношение 1:1, то при агрегации и возможности установки поведения извне мы получаем отношение 1:many. Т.е. один и тот же объект поведения может использоваться несколькими объектами-владельцами. Это порождает проблемы с общим для нескольких таких объектов-владельцев состоянием поведения. 2. Агрегация (и это, пожалуй, главный нюанс) отличается от наследования в первую очередь тем, что агрегируемый объект не является объектом-владельцем и не содержит информации о нём. Нередки ситуации, когда коду, взаимодействующему с поведением, необходим и сам объект-владелец (например, для получения информации о том, какими ещё поведениями он обладает). 3. Ну и последний минус — это конечно же производительность. Если объектов-владельцев достаточно много, то создание и уничтожение вместо одного объекта двух или более может не остаться незамеченным. Композиция-это просто когда класс состоит из других классов; или, говоря по-другому, экземпляр объекта имеет ссылки на экземпляры других объектов. Наследование - это когда класс наследует методы и свойства от другого класса.',\r\n      },\r\n      {\r\n        'Что такое полиморфизм? Для чего он используется?':\r\n          'Термин “полиморфизм” обозначает семейство различных механизмов, позволяющих использовать один и тот же участок программы с различными типами в различных контекстах. Параметрический полиморфизм, который позволяет описывать вычисления в общем виде, абстрагируясь от того, какие типы будут использованы.  Специальный полиморфизм. Согласно статье Кристофера Стрейчи в этом виде полиморфизма не существует единого и общего способа определения типа результата по типу аргументов. В нем происходит диспетчеризация (перенаправление) к одной или нескольким функциям для конкретного типа аргумента.  Но не смотря на такое разбитие, смысл первоначального деления Кристофером Стрейчи на две большие группы, так и не поменялся: Универсально полиморфные функции работают на неограниченном количестве типов, причем функция будет выполняться для любого типа аргументов. Специально полиморфные функции работают с конечным набором конкретных типов, не связанных между собой, где для каждого типа аргументов реализуется свой способ вычислений. в динамически типизированных языках применение параметрического полиморфизма не имеет смысла, так как у переменных нет статически объявляемых типов. Перегрузка — это разновидность специального полиморфизма. Такой вид полиморфизма позволяет объявлять функции с одним и тем же именем, но с разными типами аргументов и их количеством (арностью). Говоря другими словами, у функции может быть несколько сигнатур. В определении перегрузки было сказано, что компилятор занимается тем, что решает, какой вариант функции использовать в зависимости от типов аргументов. Однако этим может заниматься разработчик, например, в JavaScript Существует два подхода к классификации того, на основе чего может быть реализована системы подтипизации: реализация на включениях (inclusive), в которой любое значение типа A представляет такое же значение, но типа B, если А — подтип B. Например, в ОО языках подтипирование основано, как правило, на включениях (inclusive). реализация на приведении (coercive), где любое значение типа A может автоматически быть сконвертировано в значение типа B. Отношения подтипов, которые связывают целые числа и числа с плавающей точкой, обычно основаны на приведениях (coercive). Полиморфизм включений — это универсальный вид полиморфизма (согласно статье Лука Карделли и Питера Вегнера). В этом виде полиморфизма функции или операторы могут содержать один или множество аргументов, типы которых имеют подтипы. В самом общем смысле, тип — это множество значений, поэтому классы в ООП можно рассматривать как тип, потому что они порождают множество значений. Полиморфизм включений в объектно-ориентированных языках отражает принцип подстановки Барбары Лисков (вспомните принципы SOLID), о чем она подробно написала в 1987 году в своей статье Data Abstraction and Hierarchy. Или наоборот: принцип гарантирует полиморфизм включений. Принцип Барбары Лисков звучит так: Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. Утиная типизация присуща динамически типизированным языкам. Это неявная типизация, в которой типы не определяются на уровне синтаксиса. С точки зрения утиной типизации, если два объекта имеют одинаковое поведение, то они относятся к одному типу. Приведение типов — это специальный вид полиморфизма. Полиморфизм в программировании — это возможность использования одного и того же кода с разными типами аргументов и переменных. Практическая польза в полиморфизме для разработчика — частичное сокращение бойлерплейт кода. Существует две основные категории полиморфизма: универсальный и специальный, где последний работает на ограниченном множестве типов. В каждой категории есть свои подвиды, и у каждого подвида есть свои особенности. Например, если вы читаете данные из файла, то, очевидно, в классе, реализующем файловый поток, будет присутствовать метод похожий на следующий: byte[] readBytes( int n ); Предположим теперь, что вам необходимо считывать те же данные из сокета. В классе, реализующем сокет, также будет присутствовать метод readBytes. Достаточно заменить в вашей системе объект одного класса на объект другого класса, и результат будет достигнут. При этом логика системы может быть реализована независимо от того, будут ли данные прочитаны из файла или получены по сети. Таким образом, мы абстрагируемся от конкретной специализации получения данных и работаем на уровне интерфейса. Единственное требование при этом – чтобы каждый используемый объект имел метод readBytes. ',\r\n      },\r\n      {\r\n        'Что такое инкапсуляция? Какие проблемы решаются с ее помощью?':\r\n          ' Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя. Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсулируется в классе.',\r\n      },\r\n      {\r\n        'Что такое состояние программы? Как оно влияет на программу?':\r\n          'Три состояния программы Делайте дизайн для обычного, пустого, и ошибочного состояния страницы. Для каждого экрана вы должны рассмотреть три состояния: Обычное Экран, который люди видят каждый день при работе с приложением, заполненным данными. Пустое Экран, который люди видят при первом запуске, и ещё не успели ввести данные. Ошибка! Экран, который люди видят, когда что-то идёт не так. Обычное состояние — это элементарно :) Это экран, где вы проводите бОльшую часть вашего времени. Но не забывайте инвестировать время и в другие состояния (читайте следующие эссе, чтобы узнать больше об этом).',\r\n      },\r\n      {\r\n        'Что такое сайд-эффекты?Надо ли бороться с сайд-эффектами при проектировании в парадигме ООП? Являются ли мутации сайд-эффектом?':\r\n          'Считается, что у функции есть сайд эффекты если она модифицирует что-то за пределами своей области видимости. Это может быть изменение переменной, пользовательский ввод, запрос к api, запись данных на диск, лог в консоль и т.д. Сайд эффекты — действительно мощный инструмент, но с большой силой приходит большая ответственность. Сайд эффекты, по возможности, должны быть устранены или хотя бы инкапсулированы так, чтобы мы могли их контролировать. Функции с сайд эффектами тяжелее читать и тестировать, избегайте их всегда, когда это возможно. К счастью, в рамках данной статьи, мы не будем беспокоиться о побочных эффектах. Сайд-эффект — это не первоклассный обьект Что это значит? Первоклассный объект (first-class object) — это сущность в языке программирования, которую: можно сохранить в переменной или структурах данных; можно передать в функцию как аргумент; можно вернуть из функции как результат. Проще говоря, первоклассный объект можно легко представить в виде некоторого значения. Очевидно, что для сайд-эффектов это не так. Сайд-эффекты зависят от/влияют на внешнее окружение Это довольно очевидное свойство. Для того, чтобы корректно выполнить некоторый сайд-эффект, нам необходимо корректное окружение: для HTTP запроса нужна рабочая сеть, для запроса к DOM необходим сформированный DOM и так далее. Сайд-эффекты лишают функции ссылочной прозрачности Ссылочная прозрачность (referential transparency) — свойство функции, благодаря которому можно всегда и везде вместо результата работы функции подставить её вызов. Сайд-эффекты изменяют свойства кода, в котором используются, до самой вершины стека вызовов Функция с сайд-эффектом внутри сама становится в некотором смысле сайд-эффектом. Что такое fetch? Это функция, которая внутри себя содержит сайд-эффекты, или это целиком сайд-эффект? А если завернуть её в дополнительную обёртку? Для нас важно то, что использование сайд-эффектов внутри других функций приводит к приобретению этими функциями всех свойств сайд-эффектов. На самом деле, скорее всего, последние два свойства вытекают из первого — но это только догадка, и поэтому я решил вынести их в отдельные пункты. Код с сайд-эффектами сложен для анализа (как человеком, так и машиной) Это оказывает влияние на: машинный анализ (IDE не сможет подсказать нам, правильно ли мы используем ту или иную функцию); анализ человеком (зачастую код-ревью просто не работает, потому что правки кода в одном месте влияют на другую часть системы). Также в случае кода с сайд-эффектами значительно усложняется рефакторинг. К примеру, удаление неиспользующегося кода Код с сайд-эффектами сложно переиспользовать. Cайд-эффекты сложно тестировать.  Так как функции с сайд-эффектами зависят от внешнего мира и влияют на него неявно, то, соотвественно, чтобы корректно протестировать такую функцию, необходимо: полностью смоделировать весь окружающий мир (сетевые запросы, состояние DOM, состояние файловой системы) в виде некоторого значения до вызова функции; вызвать функцию; проверить состояние значения, моделирующего весь внешний мир. Очевидно, что сделать это полностью корректно, скорее всего, невозможно, так как количество типов сайд-эффектов в JS не ограничено. Cайд-эффекты непредсказуемы и не воспроизводимы Cайд-эффекты не типизируются Для кода с сайд-эффектами сложно применить тестирование, основанное на проверке свойств Тестирование, основанное на проверке свойств, или генеративное тестирование, или property-based тестирование — техника, позволяющая описывать свойства какой-то программной сущности (функции, к примеру) и проверять её при помощи генерации входных параметров. Если мы не контролируем ПО, то оно начинает контролировать нас (разработчиков). В результате всего вышесказанного у нас получается код, который: нельзя полноценно протестировать, да и, чтобы протестировать хоть как-то, нужно приложить много усилий — из-за этого мы пишем недостаточно тестов. Проверьте свое покрытие кода с сайд-эффектами и кода, работающего только с данными — скорее всего, во втором случае цифра будет намного выше; нельзя полноценно типизировать, потому что значительную часть фронтенд-кода занимают функции типа handleClick(): void, dispatch(): void, setState(): void; нельзя верифицировать или попробовать доказать его свойства при помощи property-based тестов — у большей его части просто нет каких-либо предсказуемых свойств; неудобен для работы в интерактивной среде (REPL), потому что там не получится работать с DOM-элементами или безопасно послать HTTP-запрос; практически не поддается рефакторингу, так как сайд-эффекты создают неявные зависимости; непредсказуем — невозможно создать надёжные инструменты воспроизведения поведения приложения. Обычно не является проблемой по результатам мониторинга понять, что произошо. Но вот почему так произошло — может быть совершенно неясно, так как части приложения влияют друг на друга неявно; очень тяжело переиспользуется. Иногда без внесения правок в исходники нельзя переиспользовать то или иное решение. Поэтому наученные горьким опытом разработчики зачастую стремятся не переиспользовать крупные части своего приложения (не говоря уже о больших и сложных сторонних компонентах), так как не ясно, возможно ли будет избавиться от некоторых нежелательных действий, если они вдруг станут не нужны.',\r\n      },\r\n      {\r\n        'Что такое принципы SOLID? Что означает каждая буква из акронима?':\r\n          'Вот как расшифровывается акроним SOLID: S: Single Responsibility Principle (Принцип единственной ответственности). O: Open-Closed Principle (Принцип открытости-закрытости). L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков). I: Interface Segregation Principle (Принцип разделения интерфейса). D: Dependency Inversion Principle (Принцип инверсии зависимостей). Принцип единственной ответственности - Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.  Проектируя классы, мы должны стремиться к тому, чтобы объединять родственные компоненты, то есть такие, изменения в которых происходят по одним и тем же причинам. Нам следует стараться разделять компоненты, изменения в которых вызывают различные причины. Принцип открытости-закрытости - Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации. это означает, что такие сущности могут позволять менять свое поведение без изменения их исходного кода. Это особенно значимо в производственной среде, когда изменения в исходном коде потребуют проведение пересмотра кода, модульного тестирования и других подобных процедур, чтобы получить право на использования его в программном продукте. Код, подчиняющийся данному принципу, не изменяется при расширении и поэтому не требует таких трудозатрат. Принцип подстановки Барбары Лисков - Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов. Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается. требований, сформулированных Стивом Фентоном. Они заключаются в том, что методы, принимающие или возвращающие значения с типом некоего суперкласса (Animal в нашем случае) должны также принимать и возвращать значения, типами которых являются его подклассы (Pigeon).  Принцип разделения интерфейса Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют. Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов. Принцип разделения интерфейса предостерегает нас от создания интерфейсов, подобных Shape из нашего примера. Клиенты (у нас это классы Circle, Square и Rectangle) не должны реализовывать методы, которые им не нужно использовать. Кроме того, этот принцип указывает на то, что интерфейс должен решать лишь какую-то одну задачу (в этом он похож на принцип единственной ответственности), поэтому всё, что выходит за рамки этой задачи, должно быть вынесено в другой интерфейс или интерфейсы. Принцип инверсии зависимостей Объектом зависимости должна быть абстракция, а не что-то конкретное. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    FunctionPrg: [\r\n      {\r\n        'Изучить книгу Functional-Light JavaScript от Kyle Simpson (1-9 главы включительно).':\r\n          'https://github.com/fxzhukov/Functional-Light-JS-RU Если говорить простыми словами, то функциональное программирование — это способ программировать, при котором вы можете передавать функции в качестве параметров другим функциям, а также возвращать их как значения. В функциональном программировании мы думаем и пишем код с точки зрения функций.',\r\n      },\r\n      {\r\n        'Что такое арность? Как получить арность функции в JS?':\r\n          'Arity (арность) Количество аргументов функции. От слов унарный, бинарный, тернарный (unary, binary, ternary) и так далее. Это необычное слово, потому что состоит из двух суффиксов: \"-ary\" и \"-ity.\". Сложение, к примеру, принимает два аргумента, поэтому это бинарная функция, или функция, у которой арность равна двум. Иногда используют термин \"диадный\" (dyadic), если предпочитают греческие корни вместо латинских. Функция, которая принимает произвольное количество аргументов называется, соответственно, вариативной (variadic). Но бинарная функция может принимать два и только два аргумента, без учета каррирования или частичного применения.  арность функции - const p = (...arg) => { console.log(arg.length); }; p(1,4,6,8,9,5);',\r\n      },\r\n      {\r\n        'Что такое first-class citizen? Что в JS является таковым?':\r\n          'В языках программирования существует понятие \"объекты первого рода (или класса)\". Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и присвоены переменным (или константам). К таким элементам относятся любые данные, например числа, строки, массивы или логические значения. Обратите внимание, что сама переменная (или константа) под это понятие не попадает, объектом первого рода считаются те данные, которые лежат в переменной (или константе). Если язык программирования имеет функции первого класса, то значит они трактуются как объекты, то есть могут быть переданы другим функциям и их можно вернуть из функций. Так же их можно присваивать переменным. /* функция не имеет имени и находится в правой части команды присваивания переменной.*/ var dog = function(num) { for (var i = 0; i < num; i++) { alert(\"Woof\"); } }; dog(3); //Эту функцию можно вызвать через переменную dog. Такое использование ключевого слова function — внутри команды, как в команде присваивания, — называется функциональным выражением. В отличие от объявления, эта функция не имеет имени. Кроме того, результатом этого выражения является значение, которое затем присваивается переменной dog. Что это за значение? Мы присваиваем его переменной dog, а затем вызываем через эту переменную, значит, это есть ссылка на функцию.',\r\n      },\r\n      {\r\n        'Какие последствия от того, что в JS функции — тоже first-class citizen?':\r\n          'Функции первого класса Вы, наверное, слышали, что JavaScript относится к функциям, как к объектам первого класса. Это выражение всего лишь означает, что в JavaScript функции имеют тот же статус, что и объекты: обладают типом Object; их можно задавать как значение переменной; их можно передавать и возвращать по ссылке, как любые другие переменные. Это нативное свойство дает JavaScript особые возможности в функциональном программировании. Так как функции являются объектами, язык поддерживает естественный подход к функциональному программированию. На самом деле, этот подход так естественен, что держу пари, вы наверняка использовали его и не задумывались об этом.',\r\n      },\r\n      {\r\n        'Что такое функция высшего порядка?':\r\n          'Такие функции оперируют другими функциями, принимая их в качестве аргументов или возвращая их. Проще говоря, функции высшего порядка ― это такие функции, которые принимают функцию в качестве аргумента или возвращают функцию в качестве вывода. Например, эти функции высшего порядка встроены в язык: Array.prototype.map, Array.prototype.filter и Array.prototype.reduce . Array.prototype.map Метод map() создаёт новый массив, вызывая callback-функцию, указанную в качестве аргумента, для каждого элемента входного массива. Метод map() берёт каждое возвращённое значение от callback-функции и создаёт новый массив, используя эти значения. Callback-функция, отправленная в метод map(), принимает 3 аргумента: element, index, и array.',\r\n      },\r\n      {\r\n        'Control flow Что такое? Как влияет на сложность кода? Какие есть особенности control flow в программах, написанных в функциональной парадигме?':\r\n          'Что значит абстрагирование потока управления или «control flow», как выражаются наши заморские друзья? В случае, когда никто не выпендривается, потоком занимаются управляющие конструкции. Иногда этих управляющих конструкций недостаточно и мы дописываем свои, абстрагирующие нужное нам поведение программы. Это просто в языках вроде lisp, ruby или perl, но и в других языках это возможно, например, с помощью функций высшего порядка. Абстракции Начнём с начала. Что нужно сделать, чтобы построить новую абстракцию? Выделить какой-то кусок функциональности или поведения. Дать ему имя. Реализовать его. Спрятать реализацию за выбранным именем.',\r\n      },\r\n      {\r\n        'Частичное применение функций и каррирование Когда может быть полезным частичное применение функций?  Когда может быть полезным каррирование? В чем их отличия? Каково их влияние на арность функций?':\r\n          'Каррирование – это трансформация, которая превращает вызов f(a, b, c) в f(a)(b)(c). Каррирование или карринг (currying) в функциональном программирование — это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму замыканий, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат. Говоря о каррировании, можно сказать, что это процесс превращения функции с несколькими аргументами в функцию с меньшей арностью. Арность — это количество аргументов функции. Частичное применение— этот термин описывает преобразование функции с несколькими аргументами в функцию, которая принимает меньшее количество аргументов, при этом значения для опущенных аргументов задаются заранее. Этот прием вполне адекватен своему названию: он \"частично применяет\" некоторые аргументы функции, возвращая функцию с сигнатурой, которая состоит из остающихся аргументов. При частичном применении функцию преобразуют в другую функцию, обладающую меньшим числом аргументов (меньшей арностью). Некоторые аргументы такой функции оказываются зафиксированными (для них задаются значения по умолчанию).',\r\n      },\r\n      {\r\n        'Композиция функций Что такое? Для чего используется? Что такое pipe? Как реализовать функцию compose?':\r\n          'Композиция - создание сложной функциональности за счет объединения более простых функций. В некотором смысле, композиция - это вложение функций, каждая из которых передает свой результат в качестве входных данных для другой функции. Но вместо того, чтобы создавать неразборчивое количество вложений, мы создадим функцию более высокого порядка - compose(), которая принимает все функции, которые мы хотим объединить, и возвращает нам новую функцию для использования. Композиция - это сердце и душа функционального программирования. Например, у нас есть функция a, которая принимает x и возвращает х + 2. Также есть функция b, которая также принимает x и возвращает х * 3:  омпозиция - это акт объединения этих функций, в следствии которого выходные данные одной функции становятся входными данными следующей. Мы можем увидеть это, вложив их вместе. Начнем с нашей функции a, вложим в неё нашу функцию b и передадим ей значение (аргумент) 5. В консоле мы увидим 17, что имеет смысл, так как 5 * 3 = 15, а 15 - входное значение для функции a, 15 + 2 = 17. const a = x => x + 2; const b = x => x * 3; console.log(a(b(5))); // 17 . Так что мы создадим несколько новых функций карри, которые сможем использовать для создания композиции. Давай начнем с функции upperCase. Она возьмет строку и вернет её в верхнем регистре. Далее мы сделаем функцию exclaim, которая возьмет строку и добавит восклицательный знак. И функцию repeat, которая возьмет строку и утроит её, добавив пробел между ними.   const upperCase = str => str.toUpperCase(); const exclaim = str => `${str}!`; const repeat = str => `${str} `.repeat(3); console.log( repeat(exclaim(upperCase(\"I love coding\"))) // I LOVE CODING! I LOVE CODING! I LOVE CODING! Так как этот вызов становится очень длинным и трудным для чтения, мы создадим функцию высшего порядка, которая будет принимать любое количество функций в качестве аргументов, и создать из них композицию. Например, мы создадим функцию compose, которая получит любое количество функций в качестве аргументов. Для этого мы будем использовать оператор rest.  const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x); Первым аргументом функции reduceRight являются аккумулятор и текущий элемент. Элемент является нашей функцией. С каждой итерацией мы возвращаем результат вызова накопленного значения текущей функции. Второй аргумент для reduceRight - это наше начальное значение, которым является наш x. Теперь мы можем использовать эту функцию, чтобы легко создавать новые композиции. Давай создадим функцию withСompose, которая будет составлять наши функции upperCase, exclaim, и repeat. Порядок аргументов нашей функции compose идет справа налево или снизу вверх. const upperCase = str => str.toUpperCase(); const exclaim = str => `${str}!`; const repeat = str => `${str} `.repeat(3); const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x); const withСompose = compose( repeat, exclaim, upperCase ); console.log(withСompose(\"I love coding\"));  В заключение стоит добавить, что в некоторых библиотеках, можно найти другой способ создания композиций - pipe. Функция pipe, которая аналогична compose, но порядок аргументов обратный. pipe также принимает любое количество функций и начальное значение, но на этот раз вызывает reduce. Таким образом, чтобы сделать функцию withСompose с pipe, мы просто меняем порядок аргументов. const upperCase = str => str.toUpperCase(); const exclaim = str => `${str}!`; const repeat = str => `${str} `.repeat(3); const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x); const withСompose2 = pipe( upperCase, exclaim, repeat ); console.log(withСompose2(\"I love coding\")); // I LOVE CODING! I LOVE CODING! I LOVE CODING! Хоть функция pipe и существует, всё же чаще используется функция compose, применяемая в функциональных языках, поскольку она следует математической модели композиции. Упорядочивая аргументы функций особым образом, мы позволяем нашим функциям: извлечь выгоду из частичного применения; улучшить возможность повторного использования и использовать их в композиции.',\r\n      },\r\n      {\r\n        'Point-free style  Что такое? Какие может дать преимущества? Какие могут быть недостатки?':\r\n          'Point-Free Style (бесточечная нотация) Написание функций в таком виде, что определение не явно указывает на количество используемых аргументов. Такой стиль обычно требует каррирования или другой функции высокого порядка (или в целом — неявного программирования). // Given const map = (fn) => (list) => list.map(fn) const add = (a) => (b) => a + b // Then // Not points-free - `numbers` is an explicit argument const incrementAll = (numbers) => map(add(1))(numbers) // Points-free - The list is an implicit argument const incrementAll2 = map(add(1)) Функция incrementAll определяет и использует параметр numbers, так что она не использует бесточечную нотацию. incrementAll2 просто комбинирует функции и значения, не упоминая аргументов. Она использует бесточечную нотацию. Определения с бесточечной нотацией выглядят как обычные присваивания без function или =>. Точечный стиль рассматривается некоторыми авторами как предельный функциональный стиль программирования. Проще говоря, функция типа t1 -> t2 описывает преобразование одного элемента типа t1 в другой элемент типа t2 . Идея заключается в том , что функции \"pointful\" (написанные с использованием явных переменных) подчеркивают элементы (когда вы пишете \\\\x -> ... x ..., вы описываете то, что происходит с элементом x), а функции \"point-free\" (выраженные без использования переменных) подчеркивают само преобразование , как композицию более простых преобразований. Сторонники стиля без точек утверждают, что преобразования действительно должны быть центральным понятием, и что указательная нотация, хотя и проста в использовании, отвлекает нас от этого благородного идеала. Точечное функциональное программирование доступно уже очень давно. Это уже было известно логикам, которые изучали комбинаторную логику со времени основополагающей работы Мозеса Шенфинкеля в 1924 году, и послужило основой для первого исследования того, что станет выводом типа ML Роберта Фейса и Haskell Карри в 1950-х годах. Идея построения функций из экспрессивного набора базовых комбинаторов очень привлекательна и была применена в различных областях, таких как языки манипулирования массивами , производные от APL, или библиотеки парсеров-комбинаторов, такие как Haskell Parsec . Заметным сторонником точечного программирования является Джон Бэкус . В своей речи 1978 года \"можно ли освободить Программирование от стиля фон Неймана ?\",- написал он: Выражение lambda (с его правилами подстановки) способно определение всех возможных вычислимых функций всех возможных типов и о любом количестве аргументов. Эта свобода и власть имеет свои особенности. недостатки, а также его очевидные преимущества. Он является аналогом к силе неограниченного контроля высказываний в обычном языки: с неограниченной свободой приходит хаос. Если один постоянно изобретает новые комбинирующие формы, чтобы соответствовать случаю, как один может в исчислении lambda, один не будет знакомиться с стиль или полезные свойства немногих комбинирующих форм, которые адекватны для всех целей. Так же как и структурированное Программирование избегает многих управляющих операторов, чтобы получить программы с более простыми структура, лучшие свойства и единообразные методы для понимание их поведения, поэтому функциональное программирование избегает выражение lambda, подстановка и множественная функция типы. Таким образом, он достигает программ, построенных с помощью знакомых функциональные формы с известными полезными свойствами. Эти программы являются настолько структурированы, что их поведение часто можно понять и понять. доказано механическим использованием алгебраических методов, подобных этим используется при решении задач средней школы по алгебре.',\r\n      },\r\n      {\r\n        'Что такое сайд эффекты? Чем они вредны и чем полезны?':\r\n          'Считается, что у функции есть сайд эффекты если она модифицирует что-то за пределами своей области видимости. Это может быть изменение переменной, пользовательский ввод, запрос к api, запись данных на диск, лог в консоль и т.д. Сайд эффекты — действительно мощный инструмент, но с большой силой приходит большая ответственность. Сайд эффекты, по возможности, должны быть устранены или хотя бы инкапсулированы так, чтобы мы могли их контролировать. Функции с сайд эффектами тяжелее читать и тестировать, избегайте их всегда, когда это возможно. ',\r\n      },\r\n      {\r\n        'Что такое чистые функции? Что такое \"грязные функции\"? В чем преимущества одних над другими?':\r\n          'Чистые функции — строительные блоки в функциональном программировании. Их обожают за простоту и тестируемость. Функция должна удовлетворять двум условиям, чтобы считаться «чистой»: — Каждый раз функция возвращает одинаковый результат, когда она вызывается с тем же набором аргументов — Нет побочных эффектов Функция чистая, если не имеет побочных эффектов и каждый раз возвращает одинаковый результат, когда она вызывается с тем же набором аргументов. Побочные эффекты включают: меняющийся вход, HTTP-вызовы, запись на диск, вывод на экран. Вы можете безопасно клонировать, а затем менять входные параметры. Просто оставьте оригинал без изменений. Синтаксис распространения (… syntax) — это самый простой способ клонирования объектов и массивов. Грязная функция - let x = 2; const add = (y) => { x += y; }; add(4); // x === 6 (the first time) Нечистые функции = непостоянные результаты. Пример ничего не возвращает. Он полагается на общее состояние для выполнения своей работы путем увеличения переменной за пределами своей области. Эта модель кошмар для разработчиков. Разделяемое состояние вводит зависимость от времени. Вы получаете разные результаты в зависимости от того, когда вы вызвали функцию. В первый раз результат 6, в следующий раз 10 и так далее. Что лучше? В каком случае вы получите меньше багов, которые появляются только при определенных условиях? В каком случае с большей вероятностью вы преуспеете в многопоточной среде, где временные зависимости могут сломать систему? Определенно в чистых.',\r\n      },\r\n      {\r\n        'Может ли из чистой функции произойти вызов \"грязной\"? Если да, то что это значит?':\r\n          'Если чистая функция вызыает грязную, то она по сути сама является грязной, потому что имеет сайд эффект',\r\n      },\r\n      {\r\n        'Как ограничивать влияние \"грязных функций\" на систему? У вас есть приложение, в котором обязательно должны быть определенные сайд-эффекты (например, клиентское приложение должно отправлять HTTP-запросы, показывать время и отрисовывать интерфейс). Как вы спроектируете такое приложение в функциональной парадигме, чтобы по максимуму ограничить распространение сайд-эффектов?':\r\n          'Мы не можем избавиться от сайд-эффектов совсем или даже уменьшить их число — нельзя вдруг начать делать меньше HTTP запросов или меньше работать с DOM. Сайд-эффекты — взаимодействие с внешним миром — это вообще самая главная часть нашего приложения. Если приложение не делает их, значит, скорее всего, оно вообще ничего не делает. Но мы можем полностью отделить логику нашего приложения от сайд-эффектов. Всё наше приложение станет полностью чистой функцией — будет явно принимать все входящие воздействия и явно возвращать выходные. А сайд-эффекты будут исполняться отдельно от основного приложения. Существует минимум 3 способа сделать это, и все они основаны на теоретических основах Computer Science, разработанных около 40 лет назад. Все эти способы объединяет то, что они созданы для абстракции control-flow программы. Control-flow — это скелет нашей программы, её базис, поэтому эти способы возникают при решении большей части проблем в Computer Science — не только при решении проблемы сайд-эффектов',\r\n      },\r\n      {\r\n        'Что такое идемпотентность? В чем разница между программной и математической идемпотентностью?':\r\n          'Идемпоте́нтность (лат. idem — тот же самый + potens — способный) — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом. С точки зрения RESTful-сервиса, операция (или вызов сервиса) идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно при одном и том же результате, работая как \"сеттер\" в языке программирования. Другими словами, создание большого количества идентичных запросов имеет такой же эффект, как и один запрос. Заметьте, что в то время, как идемпотентные операции производят один и тот же результат на сервере (побочные эффекты), ответ сам по себе может не быть тем же самым (например, состояние ресурса может измениться между запросами).Некоторые HTTP-методы (например: HEAD, GET, OPTIONS и TRACE) определены как безопасные, это означает, что они предназначены только для получения информации и не должны изменять состояние сервера. Другими словами, они не должны иметь побочных эффектов, за исключением безобидных эффектов, таких как: логирование, кеширование, показ баннерной рекламы или увеличение веб-счетчика. https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Idempotent',\r\n      },\r\n      {\r\n        'Что такое ссылочная прозрачность? Является ли ссылочная прозрачность выражения вызова функции достаточным признаком чистоты этой функции?':\r\n          'Ссылочная прозрачность (referential transparency) — свойство функции, благодаря которому можно всегда и везде вместо результата работы функции подставить её вызов. То есть вместо var result = sum(list); return [result, result]; можно спокойно написать return [sum(list), sum(list)];. Ссылочная прозрачность — свойство, при котором замена выражения на вычисленный результат этого выражения не изменяет желаемых свойств программы Это значит что если у нас где-то написано var x = foo() то мы всегда можем заменить это на var x = result_of_foo и поведение программы не поменяется. Именно это и является главным требованием чистоты. Никаких других требований (вроде неизменяемости) ФП не накладывает. Единственный момент тут — философский, что считать \"поведением программы\".',\r\n      },\r\n      {\r\n        'Immutability Что такое? Являются ли объекты, содержащиеся в переменных, объявленных с помощью const, иммутабельными? Какие преимущества имеют иммутабельные структуры данных? Что такое structural sharing и какие проблемы решает?':\r\n          ' Мутация — это изменение существующих данных или структуры, которая их в себе хранит. Иммутабельность же, в свою очередь, предполагает создание копии существующих данных или структуры, когда необходимы изменения, и добавление этих изменений туда. Иммутабельность предполагает, что после создания данные или структура, которая их содержит, не могут быть изменены. На практике существует два типа мутаций (изменений) — видимые и невидимые. Видимые мутации — это мутации, изменяющие данные или структуру, содержащую эти данные, способом, который контролируется внешним наблюдателем через API. Невидимые мутации не могут контролироваться через API (хорошим примером являются кэширующие структуры данных). В некотором смысле невидимые изменения могут рассматриваться как сайд-эффекты (side-effects) (мы рассмотрим этот аспект и его значение чуть позже). В контексте функционального программирования обычно запрещены оба вида модификаций: не только данные являются иммутабельными по умолчанию, но и структуры данных не могут быть изменены после создания. Плюсы иммутабельности, обьекты можно сравнивать по ссылке, можо уходить от сайд-эффектов. Объекты в Js объяленные через const не иммутабельны, поскольку передаются по ссылке и с их ключами можно делать что угодно преимущества: блокировка для многопоточности больше не является проблемой: если данные не изменяются, нет необходимости в какой-либо блокировке, чтобы синхронизировать разные потоки; хранение (persistence) — ещё один ключевой концепт, который мы рассмотрим позже, становится проще; копирование возможно за константное время, потому что этот процесс становится лишь вопросом создания новой ссылки на уже существующий экземпляр структуры данных; в некоторых случаях сравнение значений может быть оптимизировано: когда среда выполнения или компилятор во время загрузки или компиляции могут быть уверены, что одна переменная равна другой только в том случае, если они обе указывают на один и тот же объект в памяти, глубокое сравнение значений становится сравнением ссылок. Этот процесс известен как интернирование и обычно возможен только для данных, доступных во время компиляции или загрузки. Эту оптимизацию можно выполнить и вручную (в конце статьи в отдельной секции я объясню, как это сделано в React и Angular).',\r\n      },\r\n      {\r\n        'Рекурсия. Что такое? Какие могут быть преимущества и недостатки применения? Что такое оптимизация хвостового вызова? Поддерживается ли она в JS?':\r\n          'Иногда для решении задачи приходится использовать Рекурсию, в которой есть свои плюсы и минусы. Я столкнулся с проблемой переполнения стека. Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»), но они ещё не поддерживаются везде и работают только для простых случаев. Хвостовая рекурсия позволяет оптимизировать вызовы компилятором и уже есть в стандарте ES6, но поддержка браузерами оставляет желать лучшего. Пример хвостовой рекурсивной функции: function sum(number, s = 0){ return number === 0 ? s : sum(number - 1, s + number) } Вот простая реализация JavaScript, которая использует рекурсию: function recsum(x) { if (x===1) { return x; } else { return x + recsum(x-1); } }  Если вы вызвали recsum(5), это то, что интерпретатор JavaScript будет оценивать: recsum(5) 5 + recsum(4) 5 + (4 + recsum(3)) 5 + (4 + (3 + recsum(2))) 5 + (4 + (3 + (2 + recsum(1)))) 5 + (4 + (3 + (2 + 1))) 15 Обратите внимание, что каждый рекурсивный вызов должен завершиться до того, как интерпретатор JavaScript начнет фактически выполнять работу по вычислению суммы. Вот хвостовая рекурсивная версия той же функции: function tailrecsum(x, running_total=0) { if (x===0) { return running_total; } else { return tailrecsum(x-1, running_total+x); } } Вот последовательность событий, которые произошли бы , если бы вы вызвали tailrecsum(5), (который фактически был бы tailrecsum(5, 0), из-за второго аргумента по умолчанию). tailrecsum(5, 0) tailrecsum(4, 5) tailrecsum(3, 9) tailrecsum(2, 12) tailrecsum(1, 14) tailrecsum(0, 15) 15 В хвостовом рекурсивном случае с каждой оценкой рекурсивного вызова running_total обновляется. современные интерпретаторы JavaScript поддерживают оптимизацию хвостового вызова ',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    DataTypesAndStructure: [\r\n      {\r\n        'Что такое тип данных?':\r\n          'Тип данных (тип) — множество значений и операций над этими значениями (IEEE Std 1320.2-1998)[1]. Другие определения: Тип данных — класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены (ISO/IEC/IEEE 24765-2010)[2]. Тип данных — категоризация абстрактного множества возможных значений, характеристик и набор операций для некоторого атрибута (IEEE Std 1320.2-1998)[3]. Тип данных — категоризация аргументов операций над значениями, как правило, охватывающая как поведение, так и представление (ISO/IEC 19500-2:2003)[4]. Тип данных — допустимое множество значений[5]. Тип определяет возможные значения и их смысл, операции, а также способы хранения значений типа. Изучается теорией типов. Неотъемлемой частью большинства языков программирования являются системы типов, использующие типы для обеспечения той или иной степени типобезопасности.',\r\n      },\r\n      {\r\n        'Что такое абстрактный тип данных?':\r\n          'Понятие абстрактного типа данных До сих пор мы сталкивались с конкретными типами данных, которые характеризуются: набором допустимых значений представлением в памяти набором допустимых операций, которые можно выполнять над объектами данного типа Абстрактный тип данных — это тип данных, доступ к которым осуществляется только через некоторый набор действий (операций, команд). Этот набор действий называется интерфейсом абстрактного типа данных. То, как реализован абстрактный тип данных, самим АТД не определяется. Итак, абстрактный тип данных - это интерфейс, набор операций без реализации. Класс является одной из возможных реализацией абстрактного типа данных (АТД). Т.е. класс определяет интерфейс абстрактного типа данных и дает реализацию этого интерфейса (без которой использование АТД невозможно). Деление операций, расположенных в классе, на интерфейс и реализацию очень важно в современном программировании и называется принципом отделения интерфейса от реализации. Он заключается в том, что клиентская программа, пользующаяся классом, использует только его интерфейс (в то время, как его реализация важна только разработчикам класса). Более того, реализацию в классе принято скрывать от клиента специальными конструкциями. Этот принцип называется принципом сокрытия реализации (или защитой доступа).',\r\n      },\r\n      {\r\n        'Что такое структура данных?':\r\n          'это способы хранить и организовывать данные, чтобы эффективней решать различные задачи. Данные можно представить по-разному. В зависимости от того, что это за данные и что вы собираетесь с ними делать, одно представление подойдёт лучше других.',\r\n      },\r\n      {\r\n        'Список. Что такое список? В каких случаях используется? Является ли массив списком? Как выделяется память для элементов?':\r\n          'список или последовательность представляет собой абстрактный тип данных , который представляет собой счетное число упорядоченных значений , где то же значение может иметь место более чем один раз. Экземпляр списка является компьютерным представлением о математической концепции конечной последовательности ; (потенциально) бесконечный аналог списка является потоком . Списки являются основным примером контейнеров , так как они содержат другие значения. Если же значение повторяется несколько раз, в каждом случае рассматривать в качестве отдельного пункта. Список — представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз. Начнём с пустого блока памяти, представленного обычным JavaScript-массивом. Также нам понадобится хранить значение длины списка. Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними. Однако, как мы увидели, для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти.',\r\n      },\r\n      {\r\n        'Связный список. Что такое связный список? Как его элементы хранятся в памяти? В чем его преимущества перед списком? Чем отличается от массива?':\r\n          'Связные списки — распространённая структура данных, зачастую используемая для реализации других структур. Преимущество связного списка — эффективность добавления элементов в начало, середину и конец. Связный список по своей сути похож на граф: вы работаете с вершинами, указывающими на другие вершины. Связный список — одна из базовых структур данных. Ее часто сравнивают с массивом, так как многие другие структуры можно реализовать с помощью либо массива, либо связного списка. У этих двух типов есть преимущества и недостатки. Так устроен связный список Связный список состоит из группы узлов, которые вместе образуют последовательность. Каждый узел содержит две вещи: фактические данные, которые в нем хранятся (это могут быть данные любого типа) и указатель (или ссылку) на следующий узел в последовательности. Также существуют двусвязные списки: в них у каждого узла есть указатель и на следующий, и на предыдущий элемент в списке. Основные операции в связном списке включают добавление, удаление и поиск элемента в списке.',\r\n      },\r\n      {\r\n        'Стек. Что такое стек? Что такое принцип LIFO? Как получить элемент, находящийся в середине стека? Какие примеры использования существуют?':\r\n          'Стек — это базовая структура данных, которая позволяет добавлять или удалять элементы только в её начале. Она похожа на стопку книг: если вы хотите взглянуть на книгу в середине стека, сперва придется убрать лежащие сверху. Стек организован по принципу LIFO (Last In First Out, «последним пришёл — первым вышел») . Это значит, что последний элемент, который вы добавили в стек, первым выйдет из него. Так устроен стек В стеках можно выполнять три операции: добавление элемента (push), удаление элемента (pop) и отображение содержимого стека (pip). Стеки используются в случае, когда требуется вычислить элементы в обратном порядке, а затем перестроить их в прямой порядок. Одним из самых простых примеров может служить изменение порядка символов в строке. При наличии стека символов задание становится очень простым: затолкнуть символы из строки в стек, а затем вытолкнуть их в обратном порядке.',\r\n      },\r\n      {\r\n        'Дерево. Что такое дерево? Что такое лист и узел дерева? Что такое глубина дерева? Что такое двоичные деревья и для чего используются?':\r\n          'Деревья похожи на графы или связные списки, с той разницей, что они «однонаправленые». Это значит, что в них не может существовать циклических ссылок. Дерево — это структура, в которой у каждого узла может быть ноль или более подузлов — «детей»  Если дерево показывает структуру компании. Узлы представляют людей или подразделения, линии — связи и отношения. Дерево — это самый эффективный способ представления и хранения такой информации. Двоичное дерево поиска похоже на дерево из примера выше, но строится по определенным правилам: У каждого узла не более двух детей. Любое значение меньше значения узла становится левым ребенком или ребенком левого ребенка. Любое значение больше или равное значению узла становится правым ребенком или ребенком правого ребенка. Дерево — это структура данных, состоящая из узлов. Ей присущи следующие свойства: Каждое дерево имеет корневой узел (вверху). Корневой узел имеет ноль или более дочерних узлов. Каждый дочерний узел имеет ноль или более дочерних узлов, и так далее. У двоичного дерева поиска есть два дополнительных свойства: Каждый узел имеет до двух дочерних узлов (потомков). Каждый узел меньше своих потомков справа, а его потомки слева меньше его самого. Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой операции пропорционально логарифму общего числа элементов в дереве. Двоичные деревья одна из самых простых структур (по сравнению, например, с другими деревьями). Они обычно реализуют самый базовый и самый естественный способ классификации элементов – делят их по определённому признаку, размещая одну группу в левом поддереве, а другую группу в правом. В поддеревьях рекурсивно поддерживается такой же порядок, за счёт чего узлы дерева упорядочиваются. Двоичное дерево поиска (далее ДДП) – это несбалансированное двоичное дерево, в котором элементы БОЛЬШЕ корневого размещаются справа, а элементы, которые МЕНЬШЕ размещаются слева.',\r\n      },\r\n      {\r\n        'Очередь. Что такое очередь? Что такое принцип FIFO? Как получить предпоследний элемент в очереди? Какие примеры использования существуют?':\r\n          'Эту структуру можно представить как очередь в продуктовом магазине. Первым обслуживают того, кто пришёл в самом начале — всё как в жизни. Так устроена очередь Очередь устроена по принципу FIFO (First In First Out, «первый пришёл — первый вышел»). Это значит, что удалить элемент можно только после того, как были убраны все ранее добавленные элементы. Очередь позволяет выполнять две основных операции: добавлять элементы в конец очереди (enqueue) и удалять первый элемент (dequeue). Очереди часто используются в программах для реализации буфера, в который можно положить элемент для последующей обработки, сохраняя порядок поступления. Например, если база данных поддерживает только одно соединение, можно использовать очередь потоков, которые будут, как ни странно, ждать своей очереди на доступ к БД.',\r\n      },\r\n      {\r\n        'Множество (Set). Что такое множество? Может ли множество содержать одинаковые элементы? Как элементы хранятся в памяти? Какие существуют операции над множествами?':\r\n          'Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз. Его основные методы это: new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set. set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set. set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false. set.has(value) – возвращает true, если значение присутствует в множестве, иначе false. set.clear() – удаляет все имеющиеся значения. set.size – возвращает количество элементов в множестве. Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз. Например, мы ожидаем посетителей, и нам необходимо составить их список. Но повторные визиты не должны приводить к дубликатам. Каждый посетитель должен появиться в списке только один раз. Перебор объекта Set Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя',\r\n      },\r\n      {\r\n        'Словарь (Map). Что такое словарь? В каком формате он хранит данные? Является ли объект словарем? Можно ли итерировать словарь?':\r\n          'Map — это структура, которая хранит данные в парах ключ/значение, где каждый ключ уникален. Иногда её также называют ассоциативным массивом или словарём. Map часто используют для быстрого поиска данных. Она позволяет делать следующие вещи: добавлять пары в коллекцию; удалять пары из коллекции; изменять существующей пары; искать значение, связанное с определенным ключом. Ключами может быть что угодно, например объекты Методы и свойства: new Map() – создаёт коллекцию. map.set(key, value) – записывает по ключу key значение value. map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует. map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false. map.delete(key) – удаляет элемент по ключу key. map.clear() – очищает коллекцию от всех элементов. map.size – возвращает текущее количество элементов. Для перебора коллекции Map есть 3 метода: map.keys() – возвращает итерируемый объект по ключам, map.values() – возвращает итерируемый объект по значениям, map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.',\r\n      },\r\n      {\r\n        'ES6: WeakMap, WeakSet  Что такое WeakMap и WeakSet? В чем отличия от Map и Set? Какие примеры использования существуют?':\r\n          'WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями. WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями. Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции. WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически. частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его. Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.',\r\n      },\r\n      {\r\n        'Каким типом данных, абстрактным типом данных и какой структурой данных является DOM tree?':\r\n          'объектная модель документа (DOM) представляется в виде дерева.HTML-тег содержит другие теги. У нас есть тег заголовка и тег тела. Эти теги содержат определенные элементы. Заголовок имеет мета теги и теги заголовка. Тег тела имеет элементы, которые отображаются в пользовательском интерфейсе, например, h1, a, liи т.д.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    ProjectingPrinciple: [\r\n      {\r\n        'Что такое абстрагирование? Какие есть отличия между абстракцией, инкапсуляцией и скрытием информации?':\r\n          'Абстракция-это процесс (и результат этого процесса) выявления общих сущностных характеристик для совокупности объектов. Можно сказать, что абстракция - это процесс обобщения: все рассматриваемые объекты входят в надсчет объектов, все из которых обладают заданными свойствами (но различны в других отношениях). Инкапсуляция-это процесс включения данных и функций, манипулирующих этими данными, в единый блок, чтобы скрыть внутреннюю реализацию от внешнего мира. Абстракция: \"Один из моментов путаницы в отношении абстракции - это ее использование как процесса и как сущности. Абстракция, как процесс, означает извлечение существенных деталей о предмете или группе предметов, игнорируя при этом несущественные детали. Абстракция как сущность обозначает модель, представление или другое сфокусированное представление для фактического элемента.\" сокрытие информации: - Его интерфейс или определение было выбрано так, чтобы как можно меньше узнать о его внутреннем устройстве.\" — [Парнас, 1972b] \"Абстракция может быть [ ... ] использована как метод определения того, какая информация должна быть скрыта.\" \"Путаница может возникнуть, когда люди не различают между сокрытием информации и техникой (например, абстракцией), которая используется, чтобы помочь определить, какая информация должна быть скрыта.\" Инкапсуляция: \"Это [ ... ] относится к созданию капсулы, в случае концептуального барьера, вокруг некоторой коллекции вещей.\" — [Wirfs-Brock et al, 1990] \"Как процесс, инкапсуляция означает акт помещения одного или нескольких элементов в [ ... ] контейнер. Инкапсуляция, как сущность, относится к пакету или вложению, которое содержит (содержит, заключает) один или несколько элементов.\" \"Если бы инкапсуляция была \"тем же самым, что и сокрытие информации\", то можно было бы утверждать, что \" все, что было инкапсулировано, также было скрыто.\"Это явно не так.\" Вывод: - Абстракция, сокрытие информации и инкапсуляция-это очень разные, но тесно связанные понятия. Можно было бы возразить, что абстракция-это техника, которая помогает нам определить, какая конкретная информация должна быть видимой, а какая-скрытой. Инкапсуляция-это метод упаковки информации таким образом, чтобы скрыть то, что должно быть скрыто, и сделать видимым то, что должно быть видно.\" http://www.tonymarston.co.uk/php-mysql/abstraction.txt ',\r\n      },\r\n      {\r\n        'Что такое Coupling? Как абстрагирование влияет на coupling?':\r\n          'Связанность, сопряжение (coupling)— способ и степень взаимозависимости между программными модулями; сила взаимосвязей между модулями; мера того, насколько взаимозависимы разные подпрограммы или модули. Сильная связанность (High coupling) рассматривается как серьёзный недостаток, поскольку затрудняет понимание логики модулей, их модификацию, автономное тестирование, а также переиспользование по отдельности. Слабая связанность (Low coupling), напротив, является признаком хорошо структурированной и хорошо спроектированной системы, и, когда она комбинируется с сильной связностью(high cohesion), соответствует общим показателям хорошей читаемости и сопровождаемости. Low Coupling — это принцип, который позволяет распределить обязанности между объектами таким образом, чтобы степень связанности между системами оставалась низкой. Степень связанности (coupling) — это мера, определяющая, насколько жестко один элемент связан с другими элементами, либо каким количеством данных о других элементах он обладает. Элемент с низкой степенью связанности (или слабым связыванием) зависит от не очень большого числа других элементов и имеет следующие свойства: Малое число зависимостей между классами (подсистемами). Слабая зависимость одного класса (подсистемы) от изменений в другом классе (подсистеме). Высокая степень повторного использования подсистем. Виды связанности Image for post https://www.javatpoint.com/software-engineering-coupling-and-cohesion Связанность содержимого (content coupling) Один модуль изменяет или полагается на внутренние особенности другого модуля (например, использует локальные данные другого модуля) Изменение работы второго модуля приведет к переписыванию первого Связанность через общее (common coupling) Два модуля работают с общими данными (например, глобальной переменной) Изменение разделяемого ресурса приведет к изменению всех работающих с ним модулей Связанность через внешнее (external coupling) Два модуля используют навязанный извне формат данных, протокол связи и т.д. Обычно возникает из-за внешних сущностей (инструментов, устройств и т.д.) Связанность по управлению (control coupling) Один модуль управляет поведением другого Присутствует передача информации о том, что и как делать Связанность по структурированным данным (data-structured coupling, stamp couplig) Модули используют одну и ту же структуру, но каждый использует только ее части Изменение структуры может привести к изменению модуля, который измененную часть даже не использует Связанность через данных (data coupling) Модули совместно используют данные, например, через параметры Элементарные фрагменты маленькие и только они используются модулями совместно Связанность по сообщениям (message coupling) Модули общаются только через передачу параметров или сообщений Состояние децентрализовано Отсутствие связанности (no coupling) Модули вообще никак не взаимодействуют Закон Деметры Принцип наименьшего знания Image for post Закон Деметры (Law of Demeter, LoD) — набор правил проектирования при разработке программного обеспечения, в частности объектно-ориентированных программ, накладывающий ограничения на взаимодействия объектов (модулей). Обобщенно, закон Деметры является специальным случаем слабой связанности (loose coupling). Правила были предложены в конце 1987 в северо-восточном Университете (Бостон, Массачусетс, США). Говоря упрощённо, каждый программный модуль: должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю. должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами. обращаться только к непосредственным «друзьям». Общее описание правила: Объект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C. Image for post Таким образом, код a.b.Method() нарушает Закон Деметры, а код a.Method() является корректным. Преимущества Преимуществами закона Деметры является то, что код, разработанный с соблюдением данного закона, делает написание тестов более простым, а разработанное программное обеспечение менее сложно при поддержке и имеет большие возможности повторного использования кода. Так как объекты являются менее зависимыми от внутренней структуры других объектов, контейнеры объектов могут быть изменены без модификации вызывающих объектов (клиентов). Недостатки Недостатком закона Деметры является то, что иногда требуется создание большого количества малых методов-адаптеров (делегатов) для передачи вызовов метода к внутренним компонентам. Связанность модулей (coupling), часто называемую зацеплением, характеризует степень независимости модулей. При проектировании систем необходимо стремиться, чтобы модули имели минимальную зависимость друг от друга, т.е. были минимально «сцеплены» между собой (отсюда и термин «сцепление» или связанность). Это требование вытекает из одного из основных принципов системного подхода, требующего минимизации информационных потоков между подсистемами.',\r\n      },\r\n      {\r\n        'Что такое Cohesion? Является ли эта величина обратной величине Coupling?':\r\n          'Связность, или прочность (cohesion) — мера силы взаимосвязанности элементов внутри модуля; способ и степень, в которой задачи, выполняемые некоторым программным модулем, связаны друг с другом. Image for post Cвязность характеризует то, насколько хорошо все методы класса или все фрагменты метода соответствуют главной цели, — иначе говоря, насколько сфокусирован класс. Стив Макконнелл Считается, что объект (подсистема) обладает высокой связностью (High cohesion), если его обязанности хорошо согласованы между собой и он не выполняет огромных объемов работы. Класс с низкой связностью(low cohesion) выполняет много разнородных функций или несвязанных между собой обязанностей. Такие классы создавать нежелательно, поскольку они приводят к возникновению следующих проблем: Трудность понимания Сложность при повторном использовании Сложность поддержки Ненадежность, постоянная подверженность изменениям Классы с низкой степенью связности, как правило, являются слишком «абстрактными» или выполняют обязанности, которые можно легко распределить между другими объектами. Виды связности Image for post https://www.javatpoint.com/software-engineering-coupling-and-cohesion Случайная (coincidental cohesion) Части модуля сгруппированы “от фонаря” Единственное, что их объединяет — сам модуль Логическая (logical cohesion) Части модуля логически относятся к одной проблеме При этом части могут различаться по своей природе Временная (temporal cohesion) Части модуля обычно используются в программе в одно время, рядом Процедурная (procedural cohesion) Части модуля всегда используются в определенном порядке По взаимодействию (communication cohesion) Части модуля работают над одним и теми же данными По последовательности действий (sequential cohesion) Результат работы одной части модуля является исходными данными для другой Функциональная (functional cohesion) Части модуля направлены на решение одной четкой задачи, за которую отвечает модуль В идеале модуль должен выполнять одну единственную функцию и иметь минимальное число «ручек управления». Примером модуля имеющего максимальную связность является модуль проверки орфографии. Если связанность является характеристикой системы, то связность характеризует отдельно взятый модуль.',\r\n      },\r\n      {\r\n        'Separation of concerns. Что это такое? Какие преимущества даёт следование этому принципу? Что подразумевают под горизонтальным и вертикальным separation of concerns? Возможно ли вертикальное разделение без горизонтального и наоборот? Как связан с Single Responsibility Principle и с cohesion?':\r\n          'https://habr.com/ru/post/144611/ В каждом приложении мы имеем дело с несколькими понятиями (concerns). Как минимум три из них как правило четко определены: UI, бизнес логика и база данных. Принцип разделения ответственности тесно связан с принципом единственной обязанности (Single Responsibility Principle, SRP). Вы можете думать о SoC как о SRP примененном не к единственному классу, а к всему приложению. В большистве случаев эти два принципа могут использоваться взаимозаменяемо. В случае с ORM принцип SoC относится к разделению логики предметной (доменной) области и логики сохранения данных в БД. Мы можем утверждать, что код приложения имеет хорошую степень разделения ответственностей если доменные классы в нем не знают о том, как они сохраняются в базе данных. При сохранении различных ответственностей в едином классе, нам приходится коддерживать их консистентность одновременно с каждой операцией в рамках этого класса. Это очень быстро приводит к комбинаторному взрыву. Более того, сложность приложения нарастает гораздо быстрее, чем думают большинство разработчиков. Каждая дополнительная ответственность увеличивает сложность класса на порядок. SoC — это не просто вопрос хорошего или красивого кода. Принцип SoC жизненно важен для поддержания приемлемой скорости разработки. Более того, он важен для успеха вашего проекта. Человек может удерживать в кратковременной памяти не более девяти объектов одновременно. Приложение без четкого разделения ответственностей очень быстро переполняет кратковременную память разработчика из-за огромного количества комбинаций, в которых различные неразделенные понятия могут взаимодействовать друг с другом. Разделение ответственности (separation of concerns, SoC) – программа должны состоять из функциональных блоков, как можно меньше дублирующих функциональность друг друга Применение принципа разделения ответственности при разработке программного обеспечения может дать ряд остаточных преимуществ. Во-первых, отсутствие дублирования и однозначность назначения отдельных компонентов упрощают обслуживание всей системы. Во-вторых, система в целом становится более стабильной как побочный продукт повышенной ремонтопригодности. В-третьих, стратегии, необходимые для обеспечения того, чтобы каждый компонент касался только одного набора связанных обязанностей, часто приводят к естественным точкам расширения. В-четвертых, разделение, возникающее из-за того, что компоненты должны сосредоточиться на одной цели, приводит к компонентам, которые легче повторно использовать в других системах или в разных контекстах внутри одной и той же системы. В-пятых, повышение ремонтопригодности и расширяемости может иметь большое влияние на конкурентоспособность и скорость принятия системы.',\r\n      },\r\n      {\r\n        'Simplicity. Как Рич Хики в своём докладе \"Simple Made Easy\" описывает отличие Simple от Easy? Зачем в первую очередь стоит стремится к простоте, а не к лёгкости? В чём заключается принцип KISS? Как KISS помогает в формировании ментальных моделей? В чём ценность этих моделей? Как участие в разработке требований от бизнеса может помочь следованию KISS? Когда абстрагирование противоречит KISS? Почему наследование может приводить к нарушению KISS? В чём заключается принцип YAGNI? Как он соотносится с принципом KISS?':\r\n          ' https://habr.com/ru/post/144611/ KISS (акроним для «Keep it simple, stupid») — принцип проектирования, принятый в ВМС США в 1960[1][2]. Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.  В проектировании следование принципу KISS выражается в том, что: не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или их использование крайне маловероятно, как правило, большинству пользователей достаточно базового функционала, а усложнение только вредит удобству приложения; не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей, гораздо проще предусмотреть для них отдельный «расширенный» интерфейс (или вовсе отказаться от данного функционала); бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные варианты поведения системы, пользователя и окружающей среды, — во-первых, это просто невозможно, а во-вторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего иррационально с коммерческой точки зрения. В программировании следование принципу KISS можно описать так: не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться; бессмысленно закладывать в проект избыточные функции «про запас», которые может быть когда-нибудь кому-либо понадобятся (тут скорее правильнее подход согласно принципу YAGNI); не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций; декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход (тут KISS перекликается с DRY); абсолютная математическая точность или предельная детализация нужны не всегда — большинство систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном пользователю объёме, а не в максимально возможном объёме. Также KISS имеет много общего c принципом разделения интерфейса из пяти принципов SOLID, сформулированных Робертом Мартином.      YAGNI - Если упрощенно, то следование данному принципу заключается в том, что возможности, которые не описаны в требованиях к системе, просто не должны реализовываться. Это позволяет вести разработку, руководствуясь экономическими критериями — Заказчик не должен оплачивать ненужные ему функции, а разработчики не должны тратить своё оплачиваемое время на реализацию того, что не требуется. Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас не нужен, но, по мнению разработчика, может либо вскоре понадобиться, либо просто будет полезен, хотя в реальности такого очень часто не происходит. Подход к реализации проектов строго по ТЗ верен с нескольких ракурсов. Заказчик не должен платить за то, что ему не надо, а продукт должен быть максимально сопровождаем и его качество не должно страдать от интеграции ненужных функций.',\r\n      },\r\n      {\r\n        'DRY. В чём основная идея принципа DRY? Как принцип связан с Cohesion? Как принцип связан с принципом SRP? Почему этот принцип неразрывно связан с SPOT (Single point of truth)? Какие есть примеры дублирования кода, которые не нарушают DRY? Какие есть примеры копирования кода бизнес-логики, которые также не нарушают DRY? Как следование принципу DRY может привести к нарушению KISS? Как следование принципу DRY может привести к Premature Generalization? Почему при попытке убрать дублирование, когда повторов этого кода ещё мало (до 4-5), мы можем легко ошибиться и выбрать неверный способ рефакторинга? Какая здесь аналогия со статистикой?Как вы объясните фразу \"Duplication is far cheaper than the wrong abstraction.\"?':\r\n          ' https://habr.com/ru/post/144611/ Принцип программирования DRY — don’t repeat yourself / не повторяйте себя Следование принципу программирования «DRY» позволяет добиться высокой сопровождаемости проекта, простоты внесения изменений и качественного тестирования. Если код не дублируется, то для изменения логики достаточно внесения исправлений всего в одном месте и проще тестировать одну (пусть и более сложную) функцию, а не набор из десятков однотипных. Следование принципу DRY всегда приводит к декомпозиции сложных алгоритмов на простые функции. А декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает понимание программного кода. Повторное использование функций, вынесенных из сложных алгоритмов, позволяет сократить время разработки и тестирования новой функциональности. Следование принципу DRY приводит к модульной архитектуре приложения и к чёткому разделению ответственности за бизнес-логику между программными классами. А это — залог сопровождаемой архитектуры. Хотя чаще не DRY приводит к модульности, а уже модульность, в свою очередь, обеспечивает принципиальную возможность соблюдения этого принципа в больших проектах. В рамках одного программного класса (или модуля) следовать DRY и не повторяться обычно достаточно просто. Также не требует титанических усилий делать это в рамках небольших проектов, где все разработчики «владеют» всем кодом системы. А вот в больших проектах ситуация с DRY несколько сложнее — повторы чаще всего появляются из-за отсутствия у разработчиков целостной картины или несогласованности действий в рамках команды. Следовать принципу «don’t repeat yourself» в рамках больших проектов не так просто, как это может показаться на первый взгляд. От разработчиков требуется тщательное планирование архитектуры, а от архитектора или тимлида требуется наличие видения системы в целом и чёткая постановка задач разработчикам. В пректировании DRY тоже имеет место — доступ к конкретному функционалу должен быть доступен в одном месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в произвольных вариациях. Этот подход пересекается с принципом единственной ответственности из пяти принципов SOLID, сформулированных Робертом Мартином.',\r\n      },\r\n      {\r\n        'Что такое Cross-cutting concerns? Что значит coarse-grained и fine-grained ответственность?':\r\n          'Аспектно-ориентированное программирование (АОП) — парадигма программирования, сфокусированная на организации и модульности сквозной функциональности. Кейсы применения — ACL, логирование, обработка ошибок, кэширование. Гранулярность - это степень, в которой система разбита на мелкие части, будь то сама система, ее описание или наблюдение. Это степень, в которой более крупная сущность подразделяется. Например, ярд, разбитый на дюймы, имеет более мелкую детализацию, чем ярд, разбитый на футы. Крупнозернистые системы состоят из меньшего количества более крупных компонентов, чем мелкозернистые системы; грубое описание системы касается больших подкомпонентов, в то время как подробное описание относится к более мелким компонентам, из которых состоят более крупные.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    AsyncInJS: [\r\n      {\r\n        'Что такое асинхронность? Чем она полезна?':\r\n          'В отличие от синхронности, асинхронность это модель поведения. Предположим, что у нас есть две строчки кода, первая за второй. Первая строка это код которому нужно время. Итак, первая строка начинает запуск в фоновом режиме, позволяя второй строке запуститься без ожидания завершения первой строки.',\r\n      },\r\n      { 'Какие в серверной разработке есть альтернативы?': 'Я и не нашел =(' },\r\n      {\r\n        'Какие есть минусы у асинхронного подхода?':\r\n          'Минус ровно один — сложный и запутанный код, который к тому же еще и сложно отлаживать.',\r\n      },\r\n      {\r\n        'Что такое Event Loop?':\r\n          'event loop, или иначе — событийный цикл.  Движок браузера выполняет JavaScript в одном потоке. Он не может поставить обработку события на паузу, переключиться на другое событие, а после — возобновить выполнение первого. Все события обрабатываются последовательно и каждое — до победного конца. Для вышеописанного потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций. Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop. Обработчики назначены, события происходят и попадают в очередь. И обрабатываются в event loop. Вот так схематично (и крайне упрощенно) можно его представить: while (queue.waitForMessage()) { queue.processNextMessage(); } Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.',\r\n      },\r\n      {\r\n        'Что такое Job queue?':\r\n          ' очереди заданий позволяют асинхронно выполнить некоторую задачу, фактически, выполнить функцию с заданными входными параметрами и в установленное время. В зависимости от параметров, задание может выполняться: сразу после добавления в очередь заданий; однократно в установленное время; многократно по расписанию. Очереди заданий позволяют передать выполняемому заданию параметры, отследить и повторно выполнить задания, закончившиеся с ошибкой, установить ограничение на количество одновременно выполняемых заданий. очереди заданий имеют несколько принципиальных отличий от очереди сообщений. Во-первых, в очередь сообщений кладут сообщения (статику), а очереди заданий подразумевают выполнение какой-то работы (вызов функции). Во-вторых, очередь заданий подразумевают наличие какого-то процессора (воркера), который будет выполнять заданную работу. При этом нужен дополнительный функционал. Количество процессоров-воркеров должно прозрачно масштабироваться в случае повышения нагрузки. С другой стороны необходимо ограничивать количество одновременно работающих заданий на одном процессоре-воркере, чтобы сгладить пиковые нагрузки и не допустить отказов в обслуживании. Это показывает что есть необходимость в инструменте, который мог бы запускать асинхронные задания, настраивая различные параметры, так же просто как мы делаем запрос по REST-API (а лучше если еще проще). При помощи очередей сообщений относительно просто реализовать очередь заданий, которые выполняются немедленно после постановки задания в очередь. В ES6 появилась новая концепция, которая называется очередью заданий (Job Queue). Эту конструкцию можно считать слоем, расположенным поверх очереди цикла событий. Вполне возможно, вы с ней сталкивались, когда вам приходилось разбираться с особенностями асинхронного поведения промисов. Сейчас мы опишем это в двух словах, в результате, когда будем говорить об асинхронной разработке с использованием промисов, вы будете понимать, как асинхронные действия планируются и обрабатываются. Представьте себе это так: очередь заданий — это очередь, которая присоединена к концу каждого тика в очереди цикла событий. Некие асинхронные действия, которые могут произойти в течение тика цикла событий не приведут к тому, что новое событие будет добавлено в очередь цикла событий, но вместо этого элемент (то есть — задание) будет добавлен в конец очереди заданий текущего тика. Это означает, что добавляя в очередь команды, которые должны быть выполнены в будущем, вы можете быть уверены в том, в каком порядке они будут выполняться. Задания — это что-то вроде «хака» setTimeout(callback, 0), но реализованные так, что они дают возможность соблюдения последовательности операций, которые выполняются позже, но так скоро, насколько это возможно.',\r\n      },\r\n      {\r\n        'Почему для асинхронных действий не получится использовать try..catch? try {setTimeout(function() { throw new Error(\"Async error!\"); }, 1000); } catch (e) {console.log(e);}':\r\n          'try…catch Самый стандартный способ, его же я обычно рекомендую — использовать конструкцию try...catch. При ожидании вызова, то есть в случае с await,любое отклоненное значение будет выброшено как исключение. Вот пример: class BookModel { fetchAll() { return new Promise((resolve, reject) => { window.setTimeout(() => { reject({\"error\": 400}) }, 1000); }); } } // async/await async getBooksByAuthorWithAwait(authorId) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error);    // { \"error\": 400 } } Error вcatch — это то самое отклоненное значение. После того, как мы поймали исключение, у нас есть несколько способов работы с ним: Обработать исключение и вернуть нормальное значение. (Неиспользование выражения return в блоке catch эквивалентно применениюreturn undefinedкоторое также является нормальным значением.) Выбросить ошибку, если хотите, чтобы функция вызова обработала её. Вы можете либо выбросить простой объект ошибки напрямую, с помощью throw error;, что позволит вам использовать функцию async getBooksByAuthorWithAwait() в цепочке промисов (другими словами, вы все равно можете вызвать её следующим образом — getBooksByAuthorWithAwait().then(...).catch(error => ...)); другой вариант — можно обернуть ошибку с помощью объекта Error например, throw new Error(error), что позволит увидеть полную трассировку стека, когда эта ошибка будет отображаться в консоли. Отклонить ошибку, например, return Promise.reject(error). Это эквивалентно throw error, поэтому не рекомендуется. Преимущества использования try...catch: Простой, традиционный способ. Если у вас есть опыт работы с другими языками, такими как Java или C ++, вам не составит труда понять данную концепцию. Дает возможность поместить несколько вызовов awaitв один блок try...catch для обработки ошибок в одном месте, если обработка ошибок на каждом шаге не требуется. В этом подходе есть и один недостаток. Так как try...catch поймает любое исключение в блоке, то будут выброшены ошибки, которые в обычных случаях промисами не отлавливаются. Для того, чтобы понять эту идею, взгляните на пример: class BookModel { fetchAll() { cb();    // note `cb` is undefined and will result an exception return fetch(\"/books\"); } } try { bookModel.fetchAll(); } catch(error) { console.log(error);  // This will print \"cb is not defined\" } Запустите этот код и вы получите ошибку ReferenceError: cb is not definedв консоли, черного цвета. Ошибка выводилась с помощью console.log(),но не самим JavaScript. Иногда это может быть фатальным: если BookModelзаключен глубоко в ряд вызовов функций, и один из вызовов проглатывает ошибку, тогда будет очень сложно найти неопределенную ошибку, подобную этой. И последний способ вызова ошибок, которым мы поделимся здесь, — продолжить использование .catch(). Вспомните функциональность await: эта функция будет ждать, пока промис завершит свою работу. Также, пожалуйста, помните, что promise.catch()тоже вернет промис! Поэтому мы можем написать обработку ошибок следующим образом: // books === undefined if error happens, // since nothing returned in the catch statement let books = await bookModel.fetchAll() .catch((error) => { console.log(error); }); В этом подходе есть две незначительные проблемы: Это смесь промисов и асинхронных функций. Вы все еще должны понимать, каков механизм работы промисов, чтобы суметь прочитать этот код. Обработка ошибок идет перед основным кодом, что идет вразрез с интуицией.',\r\n      },\r\n      {\r\n        'Что выведет данная конструкция:for (var i = 0; i <= 3; i++){setTimeout(function(){ console.log(i); }, 0);}':\r\n          '3 3 3 Замена вар на лет исправит проблему. И использование самовызыващейся функции for (let i = 0; i <= 3; i++) { (function () { setTimeout(function () { console.log(i); }, 0); })(); }',\r\n      },\r\n      {\r\n        'Что значит цифра 100 в данном случае setTimeout(func, 100)?':\r\n          'через 100 милисекунд сработает функция',\r\n      },\r\n      {\r\n        'Что такое async/await?':\r\n          'специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования. Асинхронные функции Начнём с ключевого слова async. Оно ставится перед функцией, вот так: async function f() { return 1; } У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически. Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис. Синтаксис: // работает только внутри async–функций let value = await promise; Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится. сКлючевое слово async перед объявлением функции: Обязывает её всегда возвращать промис. Позволяет использовать await в теле этой функции. Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего: Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw. Иначе вернётся результат промиса. Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать. Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.',\r\n      },\r\n      {\r\n        'Можно ли провести аналогию генераторов с async/await?':\r\n          'async/await пытается решить одну из главных головных болей языка со времен его появления: это асинхронность. ',\r\n      },\r\n      {\r\n        'Как обрабатывать ошибки в коде, использующем внутри себя await?':\r\n          'необработанные ошибки обёртываются в неудачный (rejected) промис. Но в async-функциях всё ещё можно использовать конструкцию try-catch для синхронной обработки ошибок. async function canRejectOrReturn() { // Ждём секунду await new Promise(res => setTimeout(res, 1000)); // Реджектим в 50% случае if (Math.random() > 0.5) { throw new Error(\"Простите, число больше, чем нужно.\") } return \"Число подошло\"; } canRejectOrReturn() — это асинхронная функция, которая будет удачно завершатся с \"Число подошло\", либо неудачно завершаться с Error(\"Простите, число больше, чем нужно.\"). async function foo() { try { await canRejectOrReturn(); } catch (e) { return \"Ошибка обработана\"; } } Поскольку в коде выше ожидается выполнение canRejectOrReturn, то его собственное неудачное завершение вызовет исполнение блока catch. Поэтому функция foo завершится либо с undefined (т. к. в блоке try ничего не возвращается), либо с \"Ошибка обработана\". Поэтому у этой функции не будет неудачного завершения, т. к. try-catch блок будет обрабатывать  ошибку самой функции foo. Вот другой пример: async function foo() { try { return canRejectOrReturn(); } catch (e) { return \"Ошибка обработанa\"; } } Обратите внимание, что в коде выше из foo возвращается (без ожидания) canRejectOrReturn. foo завершится либо с \"число подошло\", либо с реджектом Error(\"Простите, число больше, чем нужно.\"). Блок catch никогда не будет исполняться. Это происходит из-за того, что foo возвращает промис, который передан от canRejectOrReturn. Следовательно, решение функции foo становится решением canRejectOrReturn. Такой код можно представить всего в двух строках: try { const promise = canRejectOrReturn(); return promise; } Вот что получится, если использовать await и return разом: async function foo() { try { return await canRejectOrReturn(); } catch (e) { return \"Ошибка обработана\"; } } В коде выше foo будет удачно завершаться и с  \"число подошло\", и с \"Ошибка обработана\". В таком коде реджектов не будет. Но в отличие от одного из примеров выше, foo завершится со значением canRejectOrReturn, а не с undefined. Вы можете убедиться в этом сами, убрав строку return await canRejectOrReturn(): try { const value  = await canRejectOrReturn(); return value; } // ...',\r\n      },\r\n      {\r\n        'Что, если функция, которая была вызвана с await, сама по себе не асинхронная? Как это сэмулировать?':\r\n          'Поставить сеттаймуат?',\r\n      },\r\n      {\r\n        'Как запустить выполнение нескольких асинхронных функций (созданных через async) и дождаться их общего выполнения?':\r\n          'С асинхронными функциями нам нужно немного поработать, чтобы получить такой же эффект. Если мы просто перечислим каждую функцию, ожидающую в очереди, они будут выполняться последовательно, так как await приостанавливает выполнение оставшейся части функции. async function inSequence() { await pause500ms(); await pause500ms(); console.log(\"I will be logged after 1000ms\"); } Это займет 1000 мс, так как второе ожидание не запустится, пока не завершится первое. Чтобы обойти это, мы должны ссылаться на функции таким образом: async function inParallel() { const await1 = await pause500ms(); const await2 = await pause500ms(); await await1; await await2; console.log(\"I will be logged after 500ms\"); } Теперь это займет всего 500 мс, потому что обе функции pause500ms () выполняются одновременно. С промисами мы можем выполнять несколько обещаний параллельно с помощью метода Promise.all (). function pause500ms() { return new Promise((res) => setTimeout(res, 500)); } const promise1 = pause500ms(); const promise2 = pause500ms(); Promise.all([promise1, promise2]).then(() => { console.log(\"I will be logged after 500ms\"); });',\r\n      },\r\n      {\r\n        'Какие есть способы выполнить функцию асинхронно?':\r\n          'Промисы и бесконечная цепочка обратных вызовов, Промисы, оболочки и цепочки Промисы не получили должного внимания, когда их впервые объявили, как новое дополнение к языку JavaScript. Они не являются новой концепцией, поскольку другие языки имели схожие реализации десятилетия до того. Однако, по правде говоря, они сильно изменили семантику и структуру большинства проектов, над которыми я работал с момента их появления. Промисы не только ввели встроенное решение для разработчиков для написания асинхронного кода, они открыли новый этап в веб-разработке, который послужил основой для создания более современных функций веб-спецификации, таких как fetch. Миграция методов от подхода обратных вызовов на методы, основанные на промисах, становилась все более обычным делом в проектах (таких как библиотеки и браузеры), и даже Node.js начал медленно переходить к ним.  Async и Await Промис определяется как неразрешенное значение во время выполнения, и создание экземпляра Promise является явным вызовом этого артефакта. Внутри асинхронного метода мы можем использовать зарезервированное слово await, чтобы определить разрешение Promise перед продолжением его выполнения.  Каждый раз, когда асинхронный метод находит оператор await, он прекращает выполнение до тех пор, пока не будет разрешено исходное значение или промис. Существует явное следствие использования нотации async / await, несмотря на асинхронное выполнение, код выглядит так, как если бы он был синхронным, что мы, разработчики, более привыкли видеть. Как насчет обработки ошибок? Для этого мы используем операторы, которые уже давно присутствуют в языке, try и catch.',\r\n      },\r\n      {\r\n        'Особенности JavaScript. Почему язык считается событийным и неблокирующим? Как осуществляется отлов событий? Возможно ли создание потоков в JS?':\r\n          'Разберёмся с видами ввода/вывода на примере сетевого сокета («socket» – дословно «место соединения»), через который пользователь интернета соединился с нашим сайтом, и загружает на него картинку для аватара. В этой статье мы будем сравнивать «асинхронную событийную модель» с «привычной» архитектурой, где весь ввод/вывод в коде приложения — «синхронный» и «блокирующий». «Привычной» — просто потому что раньше всякими «блокировками» никто не заморачивался, и все так писали, и всем хватало. Что такое «синхронный» и «блокирующий» ввод/вывод? Это самый простой и обычный ввод/вывод, на котором пишется большая часть сайтов: открыть файл начать его считывать ждать, пока не считается файл считался закрыть файл вывести считанное содержимое на экран В случае с нашим сокетом это будет: начать слушать сокет считать из него первую порцию данных картинки ждать, пока на него не придёт вторая порция данных картинки считать из него вторую порцию данных картинки ждать, следующую порцию данных картинки ... картинка считалась ставим картинку на аватар пользователю При этом в коде нашей программы возникает «блокировка», во время которой поток простаивает, хотя мог бы заняться чем-нибудь полезным. Для решения этой задачи был придуман «синхронный» и «неблокирующий» ввод/вывод: начать слушать сокет если на нём нет новых данных, перестать слушать сокет если на него уже поступила какая-нибудь порция данных картинки — считать эти данные перестать слушать сокет Если эти шаги выполнять в цикле, пока не будет считана последняя порция данных картинки, то мы опять же в итоге получим всю картинку полностью. С тем лишь отличием, что в этом цикле, помимо считывания данных с сокета, мы можем делать что-нибудь ещё полезное, а не простаивать под «блокировкой». Существует ещё «асинхронный» ввод/вывод. В нашей статье мы не будем его рассматривать, но вообще это когда мы вешаем на сокет «функцию обратного вызова» (callback) из нашего кода, которая будет вызываться операционной системой каждый раз, когда на этот сокет будет приходить очередная порция данных картинки. И дальше уже забываем о прослушивании этого сокета вообще, отправляясь делать другие дела. «Асинхронный» ввод/вывод, как и «синхронный», делится на «блокирующий» и «неблокирующий». Но в этой статье под словами «блокирующий» и «неблокирующий» мы будем иметь ввиду именно «синхронный» ввод / вывод.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Generator: [\r\n      {\r\n        'Что такое итераторы?':\r\n          'Перебираемые (или итерируемые) объекты – это концепция, которая позволяет использовать любой объект в цикле for..of. Конечно же, сами массивы являются перебираемыми объектами. Но есть и много других встроенных перебираемых объектов, например, строки. Объекты, которые можно использовать в цикле for..of, называются итерируемыми. Технически итерируемые объекты должны иметь метод Symbol.iterator. Результат вызова obj[Symbol.iterator] называется итератором. Он управляет процессом итерации. Итератор должен иметь метод next(), который возвращает объект {done: Boolean, value: any}, где done:true сигнализирует об окончании процесса итерации, в противном случае value – следующее значение. Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую. Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator. Строковой итератор знает про суррогатные пары. Объекты, имеющие индексированные свойства и length, называются псевдомассивами. Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов. Если мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают на то, что они будут работать с итерируемыми объектами или псевдомассивами вместо «настоящих» массивов, потому что эти объекты более абстрактны. Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта или псевдомассива obj, и затем мы можем применять к нему методы массивов. Необязательные аргументы mapFn и thisArg позволяют применять функцию с задаваемым контекстом к каждому элементу.',\r\n      },\r\n      {\r\n        'Рассказать про протоколы итерирования: Symbol.iterator, Symbol.asyncIterator':\r\n          'Мы легко поймём принцип устройства перебираемых объектов, создав один из них. Например, у нас есть объект. Это не массив, но он выглядит подходящим для for..of. Например, объект range, который представляет собой диапазон чисел: let range = { from: 1, to: 5 }; // Мы хотим, чтобы работал for..of: // for(let num of range) ... num=1,2,3,4,5 Чтобы сделать range итерируемым (и позволить for..of работать с ним), нам нужно добавить в объект метод с именем Symbol.iterator (специальный встроенный Symbol, созданный как раз для этого). Когда цикл for..of запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом next. Дальше for..of работает только с этим возвращённым объектом. Когда for..of хочет получить следующее значение, он вызывает метод next() этого объекта. Результат вызова next() должен иметь вид {done: Boolean, value: any}, где done=true означает, что итерация закончена, в противном случае value содержит очередное значение. Обратите внимание на ключевую особенность итераторов: разделение ответственности. У самого range нет метода next(). Вместо этого другой объект, так называемый «итератор», создаётся вызовом range[Symbol.iterator](), и именно его next() генерирует значения. Таким образом, итератор отделён от самого итерируемого объекта. Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код. Чтобы сделать объект итерируемым асинхронно: Используется Symbol.asyncIterator вместо Symbol.iterator. next() должен возвращать промис. Чтобы перебрать такой объект, используется цикл for await (let item of iterable). Давайте создадим итерируемый объект range, как и в предыдущем примере, но теперь он будет возвращать значения асинхронно, по одному в секунду: let range = { from: 1, to: 5, // for await..of вызывает этот метод один раз в самом начале [Symbol.asyncIterator]() { // (1) // ...возвращает объект-итератор: // далее for await..of работает только с этим объектом, // запрашивая у него следующие значения вызовом next() return { current: this.from, last: this.to, // next() вызывается на каждой итерации цикла for await..of async next() { // (2) // должен возвращать значение как объект {done:.., value :...} // (автоматически оборачивается в промис с помощью async) // можно использовать await внутри для асинхронности: await new Promise(resolve => setTimeout(resolve, 1000)); // (3) if (this.current <= this.last) { return { done: false, value: this.current++ }; } else { return { done: true }; } } }; } }; (async () => { for await (let value of range) { // (4) alert(value); // 1,2,3,4,5 } })() Как видим, структура похожа на обычные итераторы: Чтобы сделать объект асинхронно итерируемым, он должен иметь метод Symbol.asyncIterator (1). Этот метод должен возвращать объект с методом next(), который в свою очередь возвращает промис (2). Метод next() не обязательно должен быть async, он может быть обычным методом, возвращающим промис, но async позволяет использовать await, так что это удобно. Здесь мы просто делаем паузу на одну секунду (3). Для итерации мы используем for await (let value of range) (4), добавляя «await» после «for». Он вызовет range[Symbol.asyncIterator]() один раз, а затем его метод next() для получения значений. Вот небольшая шпаргалка: Итераторы\tАсинхронные итераторы Метод для создания итерируемого объекта\tSymbol.iterator\tSymbol.asyncIterator next() возвращает\tлюбое значение\tпромис для цикла используйте\tfor..of\tfor await..of',\r\n      },\r\n      {\r\n        'Зачем нужны итераторы, если уже есть массивы?':\r\n          'Практически везде, где нужен перебор, он осуществляется через итераторы. Это включает в себя не только строки, массивы, но и вызов функции с оператором spread f(...args), и многое другое. В отличие от массивов, «перебираемые» объекты могут не иметь «длины» length. Как мы увидим далее, итераторы дают возможность сделать «перебираемыми» любые объекты. В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые» (со свойством Symbol.iterator) объекты, например оператор spread .... Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.',\r\n      },\r\n      {\r\n        'В чём разница между перебором массива и итератора через конструкции: for, for of, for in?':\r\n          'Например, объект range, который представляет собой диапазон чисел: let range = { from: 1, to: 5 }; // Мы хотим, чтобы работал for..of: // for(let num of range) ... num=1,2,3,4,5 Чтобы сделать range итерируемым (и позволить for..of работать с ним), нам нужно добавить в объект метод с именем Symbol.iterator (специальный встроенный Symbol, созданный как раз для этого). Когда цикл for..of запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом next. Дальше for..of работает только с этим возвращённым объектом. Когда for..of хочет получить следующее значение, он вызывает метод next() этого объекта. Результат вызова next() должен иметь вид {done: Boolean, value: any}, где done=true означает, что итерация закончена, в противном случае value содержит очередное значение. Вот полная реализация range с пояснениями: let range = { from: 1, to: 5 }; // 1. вызов for..of сначала вызывает эту функцию range[Symbol.iterator] = function() { // ...она возвращает объект итератора: // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения return { current: this.from, last: this.to, // 3. next() вызывается на каждой итерации цикла for..of next() { // 4. он должен вернуть значение в виде объекта {done:.., value :...} if (this.current <= this.last) { return { done: false, value: this.current++ }; } else { return { done: true }; } } }; }; // теперь работает! for (let num of range) { alert(num); // 1, затем 2, 3, 4, 5 } Обратите внимание на ключевую особенность итераторов: разделение ответственности. У самого range нет метода next(). Вместо этого другой объект, так называемый «итератор», создаётся вызовом range[Symbol.iterator](), и именно его next() генерирует значения. Таким образом, итератор отделён от самого итерируемого объекта.',\r\n      },\r\n      {\r\n        'Что такое генераторы? Где они могут пригодиться?':\r\n          'Генераторы Обычные функции возвращают только одно-единственное значение (или ничего). Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных. Для объявления генератора используется специальная синтаксическая конструкция: function*, которая называется «функция-генератор». Выглядит она так: function* generateSequence() { yield 1; yield 2; return 3; } Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением. Вот, посмотрите: function* generateSequence() { yield 1; yield 2; return 3; } // \"функция-генератор\" создаёт объект \"генератор\" let generator = generateSequence(); alert(generator); // [object Generator] Основным методом генератора является next(). При вызове он запускает выполнение кода до ближайшей инструкции yield <значение> (значение может отсутствовать, в этом случае оно предполагается равным undefined). По достижении yield выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код: Результатом метода next() всегда является объект с двумя свойствами: value: значение из yield. done: true, если выполнение функции завершено, иначе false. Как вы, наверное, уже догадались по наличию метода next(), генераторы являются перебираемыми объектами. Возвращаемые ими значения можно перебирать через for..of Так как генераторы являются перебираемыми объектами, мы можем использовать всю связанную с ними функциональность, например оператор расширения ...  ',\r\n      },\r\n      {\r\n        'Как вы думаете, почему в качестве ключевого слова используется именно yield?':\r\n          'До этого момента генераторы сильно напоминали перебираемые объекты, со специальным синтаксисом для генерации значений. Но на самом деле они намного мощнее и гибче. Всё дело в том, что yield – дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор. Чтобы это сделать, нам нужно вызвать generator.next(arg) с аргументом. Этот аргумент становится результатом yield. Продемонстрируем это на примере: function* gen() { // Передаём вопрос во внешний код и ожидаем ответа let result = yield \"2 + 2 = ?\"; // (*) alert(result); } let generator = gen(); let question = generator.next().value; // <-- yield возвращает значение generator.next(4); // --> передаём результат в генератор Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и возвращает результат первого yield \"2+2=?\". На этой точке генератор приостанавливает выполнение. Затем, как показано на картинке выше, результат yield переходит во внешний код в переменную question. При generator.next(4) выполнение генератора возобновляется, а 4 выходит из присваивания как результат: let result = 4. Обратите внимание, что внешний код не обязан немедленно вызывать next(4). Ему может потребоваться время. Это не проблема, генератор подождёт. Генераторы создаются при помощи функций-генераторов function* f(…) {…}. Внутри генераторов и только внутри них существует оператор yield. Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.',\r\n      },\r\n      {\r\n        'Как происходит работа с async generators?':\r\n          'В обычных генераторах мы не можем использовать await. Все значения должны поступать синхронно: в for..of нет места для задержки, это синхронная конструкция. Но что если нам нужно использовать await в теле генератора? Для выполнения сетевых запросов, например. Нет проблем, просто добавьте в начале async, например, вот так: async function* generateSequence(start, end) { for (let i = start; i <= end; i++) { // ура, можно использовать await! await new Promise(resolve => setTimeout(resolve, 1000)); yield i; } } (async () => { let generator = generateSequence(1, 5); for await (let value of generator) { alert(value); // 1, потом 2, потом 3, потом 4, потом 5 } })(); Теперь у нас есть асинхронный генератор, который можно перебирать с помощью for await ... of. Это действительно очень просто. Мы добавляем ключевое слово async, и внутри генератора теперь можно использовать await, а также промисы и другие асинхронные функции. С технической точки зрения, ещё одно отличие асинхронного генератора заключается в том, что его метод generator.next() теперь тоже асинхронный и возвращает промисы. Из обычного генератора мы можем получить значения при помощи result = generator.next(). Для асинхронного нужно добавить await, вот так: result = await generator.next(); // result = {value: ..., done: true/false} https://learn.javascript.ru/async-iterators-generators',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    IzomorfRender: [\r\n      {\r\n        'Что такое серверный/клиентский/изоморфный рендеринг?':\r\n          'С давних времен для того, чтобы получить статическую разметку на странице использовался Server Side Rendering (SSR). Страницы полностью формировались на стороне сервера – это накладывало ряд ограничений на приложения. Их скорость могла зависеть от таких факторов, как: Скорость интернета у клиента; Расположение сервера; Количества пользователей, пытающихся получить доступ к приложению. Также, возникало много проблем с оптимизацией производительности клиентской части приложения. Для решения выше перечисленных проблем, рендеринг приложения стали переносить с сервера на клиент (Client Side Rendering). В связи с этим начали появляться Single Page Application (SPA). Достоинствами таких приложений стали: Отзывчивый интерфейс в загруженном приложении; Быстрый рендеринг в загруженном приложении; Простота кэширования. Но вместе со всеми преимуществами стали всплывать недостатки, которые очень просто решались при SSR, такие как: На плохом соединении загрузка приложения происходит очень медленно, из-за этого ухудшается User Experience (UX); Проблемы с SEO - так как на клиент загружается пустая страница, а весь контент расположен в JavaScript; Способность инициализировать приложение данными до первого отображения. В связи с этим возникает вопрос: возможно ли исправить недостатки CSR и сохранить все его достоинства. Решением этих проблем стало изоморфное приложение. Основные подходы к созданию изоморфного приложения При проектировании Server Side Rendering (SSR) приложения необходимо учитывать ряд факторов: Общая часть приложения не должна зависеть от среды исполнения (например, browser или node.js); Функциональность, зависящая от среды исполнения (например работа с LocalStorage), должна быть вынесена в отдельный модуль и входить в сборку для конкретной среды исполнения; Желательно, чтобы для клиентской и серверной части приложения был общий роутер, потому что рендер по URL на клиенте и на сервере должен давать одинаковый результат; Так как на каждый запрос сервер должен создавать новое состояние приложения, то в приложении не должно быть синглтонов и глобальных переменных; На стороне сервера нет необходимости в системе реактивности, потому что сервер просто создаёт статическую разметку; Необходима семантическая верстка, так как при гидратации приложения (построение Virtual DOM и добавление обработчиков событий) может произойти ошибка; Библиотеки для общей части приложения должны быть изоморфными (moment.js, lodash, axios и т.д.); Изоморфные приложения уменьшают пропускную способность сервера. Для работы с данными в изоморфном приложении выделяют две стратегии: Загружать пользовательские данные до клиентского отображения. Преимущество в том, что на клиент приходит полный контент, но если загрузка данных на сервере будет очень долгой, пользователь будет видеть пустую страницу и скорее всего покинет приложение. Загружать пользовательские данные после клиентского отображения. С данной стратегией интерфейс получается более отзывчивым, но после первого отображения необходимо перерендеривать представление с дозагруженными данными. Каждая из стратегий имеет свои особенности, и выбор стратегии производится от конкретной UX задачи.',\r\n      },\r\n      {\r\n        'Какие есть преимущества и недостатки у каждого из видов рендеринга?':\r\n          'При использовании серверного рендеринга пользователям не нужно ждать завершения работы JavaScript, отнимающего ресурсы процессора, прежде чем они смогут начать работать с сайтом. Даже если нельзя избежать использования стороннего JavaScript, серверный рендеринг позволяет уменьшить количество вашего собственного JavaScript и даёт больше «бюджета» для всего остального. Однако у этого подхода есть один существенный недостаток: формирование страницы на сервере занимает определённое время, что может привести к большему времени до первого байта.  Основной недостаток клиентского рендеринга заключается в том, что количество необходимого JavaScript обычно увеличивается вместе с ростом приложения. Ситуация ухудшается с подключением новых JavaScript-библиотек, полифиллов и прочего стороннего кода, который соревнуется между собой за вычислительные мощности и часто требует обработки, прежде чем содержимое страницы можно будет отобразить. Решениям с клиентским рендерингом, которые полагаются на большие JavaScript-бандлы, стоит рассмотреть сильное разделение кода и ленивую загрузку JavaScript — «загружайте только то, что вам нужно и только когда это нужно». Для решений с минимумом интерактивности или её отсутствием серверный рендеринг может предоставить более масштабируемое решение этих проблем. Если вы создаёте одностраничное приложение, то, определив основные части пользовательского интерфейса, которые используются на большинстве страниц, вы сможете использовать кеширование оболочки приложения. В сочетании с Service Worker’ами это даст сильный прирост ощущаемой производительности при повторных посещениях. ',\r\n      },\r\n      {\r\n        'Рассказать общую архитектуру серверного/клиентского/изоморфного рендера:Какие есть составляющие структуры для каждой архитектуры? Что обычно делает клиентский сервер при изоморфной архитектуре?Как в каждом случае осуществляется раутинг? Какие зоны ответственности у front-server, API-server и непосредственно самого клиента? Какие вычислительные нагрузки ложатся на каждую из этих частей?':\r\n          'Одним из главных преимуществ разработки изоморфным способом является то, что скорость подгрузки элементов значительно ускоряется за счет одновременного рендеринга на стороне сервера и на стороне клиента. Получается, что задача изоморфного приложения — не заменить привычный серверный API, а избавиться от потока нестилизованного контента, тем самым улучшив опыт взаимодействия пользователей со страницей (а их запросы постоянно растут). В React все несколько сложнее, чем простая передача разных компонентов. Когда Вы обрабатываете компоненты React на стороне сервера и отправляете скелет HTML кода клиенту, React на стороне клиента находит аналогичный HTML код и прикрепляет контейнеры с событиями к имеющимся элементам. Вуаля! Это означает, что достаточно отправлять только ту часть HTML кода, которая необходима для рендеринга страницы. Все дополнительные элементы могут быть извлечены и обработаны на стороне клиента. Вы получаете преимущество в виде быстрой загрузки со стороны сервера, а также в виде возможности реиспользования одних и тех же компонентов. Веб архитектура развивается циклами. Сначала рендеринг происходил только на стороне сервера с последующей отправкой данных клиенту. Затем, появился JavaScript, и мы стали использовать его для простых операций на странице. Наконец, JavaScript развился настолько, что стало возможным использовать его для создания больших приложений, которые будут осуществлять рендеринг на стороне клиента и использовать сервер для извлечения данных через API. В 2015 же году, мы начали понимать, что имеем в распоряжении мощные серверы, которые имеют достаточно процессоров и памяти для обработки практически любых данных. Изоморфный подход к разработке приложений может дать нам лучшее из двух миров: мы можем использовать JavaScript как на стороне сервера, так и на стороне клиента, что повышает скорость загрузки и позволяет пользователям видеть информацию на странице быстрее по мере того, как происходит подгрузка дополнительных элементов на стороне клиента.',\r\n      },\r\n      {\r\n        'Как из обычного приложения сделать изоморфное? (подробно рассказать про изоморфность, посмотреть примеры реализации)':\r\n          'Есть клиентское приложение, когда пользователь заходит на страниу, мы отправляем запрос на фронтенд сервер, который начинает рендерить и подхватывать данные с Апи, Апи отдает данные серверу, а он их отдает на клиент. Основная идея любого приложения с SSR в том, что оно должно генерировать одинаковую HTML-разметку при выполнении на сервере и на клиенте. Данные, которые подставляются в HTML, должны быть вытянуты по API, расположенному на том же или на другом сервере/домене. Настройка и разработка API-сервера выходит за рамки этой статьи, а вот в качестве клиента для него можно взять axios или любой другой изоморфный http-клиент. Также нужно помнить о том, что на сервере нет DOM, так что все манипуляции с document, window и прочими navigator либо вообще не должны использоваться, либо должны быть запущены только на клиенте, то есть в хуках beforeMount, mounted и т.п.',\r\n      },\r\n      {\r\n        'Можем ли мы добиться изоморфного SPA, не поднимая SSR-сервер?':\r\n          'SSR не накладывает почти никаких ограничений на разработку приложений. Достаточно просто помнить о том, что нельзя использовать браузерное API там, где код выполняется на сервере, в остальных же случаях выносить код в клиентские хуки beforeMount/mounted. Также приложение, созданное для работы с SSR, будет корректно работать и без SSR, так что подобный подход можно использовать для обычных SPA, чтобы при внезапном появлении требований к SEO не ломать голову и не писать костыли для оптимизации ваших сайтов. Могут быть проблемы с директивами, роль которых часто сводится к манипуляции с DOM, но их легко решить, отдавая альтернативную реализацию (пустую?) вместо самой директивы на сервере (docs).',\r\n      },\r\n      {\r\n        'Как можно осущестить pre-fetching данных в изоморфном приложении?':\r\n          'Для разработки приложения с SSR нужно исходить из того, что только root-компонент или компоненты, которые привязаны к роутам, имеют возможность асинхронно загрузить данные перед рендерингом. Для этих компонентов специальным образом нужно обрабатывать изменения роута и записывать данные, которые вернул сервер после рендеринга. Для этих целей хорошим решением будет создать mixin, который автоматически подключается к каждому компоненту при инициализации роутера. Пример кода подобного mixinа. В prefetch-mixin нужно добавить примерно следующее: created-хук, который будет брать поле prefetchData (при инициализации приложения в это поле пишется data компонента, пришедшая с сервера после рендеринга или просто записанная напрямую во время рендеринга на сервере) и полностью заменять значения полей this.$data на значения из this.constructor.extendOptions.prefetchData, но только до того, как приложение уже полностью инициализировано, что мы можем выяснить из поля this.$root._isMounted. beforeMount-хук будет вызывать prefetch только на клиенте уже после загрузки страницы в том случае, если произошёл переход на другой роут. beforeRouteUpdate-хук будет вызывать prefetch только на клиенте при изменении параметров роута.',\r\n      },\r\n      {\r\n        'Когда вы бы посоветовали заказчику использовать клиентский рендер, а когда изоморфный?':\r\n          'rjulf bcgjkmДля одностраничных приложений, которые не критичны к производительности и не имеют требований к SEO (например, приложений, использующих логин), изоморфный JavaScript может показаться больше проблемой, чем он того стоит. Точно так же многие компании и организации могут оказаться не в ситуации, когда они готовы использовать и поддерживать механизм выполнения JavaScript на стороне сервера. Например, предприятиям, специализирующимся на Java, Ruby, Python или PHP, может не хватать ноу-хау для мониторинга и устранения неполадок серверов приложений JavaScript (например, Node.js) в производственной среде. В таких случаях изоморфный JavaScript может представлять дополнительные эксплуатационные расходы, которые нелегко взять на себя.',\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    Testing: [\r\n      {\r\n        'Что такое пирамида тестирования? Какую роль там играют тесты? Какую роль там играет статический анализ кода?':\r\n          '',\r\n      },\r\n      { 'Являются ли типы полной заменой unit-тестам? Почему?': '' },\r\n      { 'Что такое end-to-end тесты? В чём отличие от интеграционных?': '' },\r\n      {\r\n        'Когда тесты действительно замедляют разработку, а когда ускоряют?': '',\r\n      },\r\n      { 'Являются ли тесты полноправной частью системы и кодовой базы?': '' },\r\n      {\r\n        'Почему тестирование становится менее удобным, если тестировать не только публичные, но и приватные методы?':\r\n          '',\r\n      },\r\n      { 'Что такое Test Double и Fake? В чём отличие от Mock и Stub?': '' },\r\n      {\r\n        'Какая разница между тестированием с behavior verification и со state verification?':\r\n          '',\r\n      },\r\n      { 'Почему применение Mocks провоцирует behavior verification?': '' },\r\n      {\r\n        'Что такое Solitary и Sociable тесты? В чём преимущества Solitary тестов? Есть ли преимущества у Sociable тестов?':\r\n          '',\r\n      },\r\n      {\r\n        'Почему применение Mocks упрощает проектирование методом \"outside-in\"?':\r\n          '',\r\n      },\r\n      {\r\n        'Зачем стремиться к тому, чтобы тесты можно было запускать максимально удобно и всего одной командой?':\r\n          '',\r\n      },\r\n      {\r\n        'Стоит ли писать \"учебные\" интеграционные тесты, которые запускаются только вручную и только для тестирования внешнего API (например, Web API Github)?':\r\n          '',\r\n      },\r\n    ],\r\n  },\r\n];\r\n\r\nexport default Middle01;\r\n","import Question from './question';\r\nexport default Question;\r\n","import React from 'react';\r\nimport { Collapse } from '../stage/stage';\r\n\r\nconst Question = (props) => {\r\n  const { tableValue } = props;\r\n  // console.log(tableValue);\r\n  let allItems = 0;\r\n  let counter = 0;\r\n\r\n  const value = tableValue.map((item) => {\r\n    const key = Object.keys(item);\r\n    allItems++;\r\n    if (item[key] == '') {\r\n      counter++;\r\n    }\r\n\r\n    return (\r\n      <div>\r\n        <ul>\r\n          <li>\r\n            <h5>{key}</h5>\r\n            <p>{item[key]}</p>\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    );\r\n  });\r\n  console.log(`Всего полей ${allItems}, осталось заполнить ${counter}`);\r\n  return value;\r\n};\r\n\r\nexport default Question;\r\n","import Theme from './theme';\r\nexport default Theme;\r\n","import React from 'react';\r\nimport Question from '../question';\r\nimport { Collapse } from '../stage/stage';\r\n//import getResource from '../../service/getResource';\r\n//const getter = new getResource();\r\n\r\nconst Theme = (props) => {\r\n  const theme = props.dataSet();\r\n\r\n  const themes = theme.map((item) => {\r\n    let key = Object.keys(item);\r\n    return (\r\n      <div>\r\n        {Collapse(`${key}`, <Question tableValue={item[key]} />, `${key}`)}\r\n        {/* <h4>{key}</h4>\r\n        <Question tableValue={item[key]} /> */}\r\n      </div>\r\n    );\r\n  });\r\n\r\n  return <div>{themes}</div>;\r\n};\r\nexport default Theme;\r\n","import React, { Component } from 'react';\r\nimport getResource from '../../service/getResource';\r\nimport Theme from '../theme';\r\nconst getter = new getResource();\r\n\r\nconst Collapse = (header, file, title) => {\r\n  return (\r\n    <>\r\n      <h1>\r\n        <button\r\n          className=\"btn btn-primary\"\r\n          type=\"button\"\r\n          data-toggle=\"collapse\"\r\n          data-target={`#${title}`}\r\n          aria-expanded=\"false\"\r\n          aria-controls={title}\r\n        >\r\n          {header}\r\n        </button>\r\n      </h1>\r\n      <div className=\"collapse\" id={title}>\r\n        <div className=\"card card-body\">{file}</div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nconst Stage = () => {\r\n  return (\r\n    <div>\r\n      {/* <div>\r\n        <h1>Junior01</h1>\r\n\r\n        <Theme dataSet={getter.getAllJunior01} />\r\n      </div>\r\n      <div>\r\n        <h1>Junior02</h1>\r\n\r\n        <Theme dataSet={getter.getAllJunior02} />\r\n      </div>\r\n      <div>\r\n        <h1>Junior03</h1>\r\n\r\n        <Theme dataSet={getter.getAllJunior03} />\r\n      </div> */}\r\n      {/* <div>\r\n        <h1>Middle01</h1>\r\n\r\n        <Theme dataSet={getter.getAllMiddle01} />\r\n      </div> */}\r\n      {Collapse(\r\n        'Junior01',\r\n        <Theme dataSet={getter.getAllJunior01} />,\r\n        'junior01'\r\n      )}\r\n      {Collapse(\r\n        'Junior02',\r\n        <Theme dataSet={getter.getAllJunior02} />,\r\n        'junior02'\r\n      )}\r\n      {Collapse(\r\n        'Junior03',\r\n        <Theme dataSet={getter.getAllJunior03} />,\r\n        'junior03'\r\n      )}\r\n      {Collapse(\r\n        'Middle01',\r\n        <Theme dataSet={getter.getAllMiddle01} />,\r\n        'middle01'\r\n      )}\r\n    </div>\r\n  );\r\n};\r\nexport default Stage;\r\nexport { Collapse };\r\n","import Junior01 from './junior01';\r\nimport Junior02 from './junior02';\r\nimport Junior03 from './junior03';\r\nimport Middle01 from './middle01';\r\n\r\nexport default class getResource {\r\n  getAllJunior01 = () => {\r\n    return Junior01;\r\n  };\r\n  getAllJunior02 = () => {\r\n    return Junior02;\r\n  };\r\n  getAllJunior03 = () => {\r\n    return Junior03;\r\n  };\r\n  getAllMiddle01 = () => {\r\n    return Middle01;\r\n  };\r\n\r\n  getTheme = (theme) => {\r\n    return Junior01[theme];\r\n  };\r\n  getQuestion = (theme, quetion) => {\r\n    return theme[quetion];\r\n  };\r\n}\r\n","import Stage from './stage';\r\nexport default Stage;\r\n","import App from './app';\r\nexport default App;\r\n","import React, { Component } from 'react';\r\nimport Stage from '../stage';\r\n\r\nexport default class App extends Component {\r\n  render() {\r\n    return <Stage />;\r\n  }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './component/app';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nfunction Animal(type) {\n  this.type = type;\n}\nAnimal.isAnimal = function (obj, type) {\n  if (!Animal.prototype.isPrototypeOf(obj)) {\n    return false;\n  }\n  return type ? obj.type === type : true;\n};\n"],"sourceRoot":""}